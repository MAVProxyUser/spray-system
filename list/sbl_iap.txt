; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\sbl_iap.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\sbl_iap.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\cstartup -I.\drivers\uart -I.\app\cfg -I.\iap -I.\drivers -I.\usb -I.\drivers\adc -I.\drivers\gpio -I.\drivers -I.\RTE\_lpc17xx_can_loader_debug -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DLPC175x_6x -D__DEBUG_UART2_PRINTF__ -D__UART0__ -D__UART1__ -D__UART2__ -D__UART3__ -D__UART2_ENABLE__ -D__UART3_ENABLE__ -D__UART0_ENABLE__ -D__UART1_ENABLE__ --omf_browse=.\output\sbl_iap.crf iap\sbl_iap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  iap_entry PROC
;;;199    
;;;200    void iap_entry(uint32_t param_tab[],uint32_t result_tab[])
000000  b570              PUSH     {r4-r6,lr}
;;;201    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;202        void (*iap)(uint32_t [],uint32_t []);
;;;203    
;;;204        iap = (void (*)(uint32_t [],uint32_t []))IAP_ADDRESS;
000006  4efb              LDR      r6,|L1.1012|
;;;205        iap(param_tab,result_tab);
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  47b0              BLX      r6
;;;206    }
00000e  bd70              POP      {r4-r6,pc}
;;;207    
                          ENDP

                  write_data PROC
;;;138    
;;;139    void write_data(uint32_t cclk,uint32_t flash_address,uint32_t * flash_data_buf, uint32_t count)
000010  e92d41f0          PUSH     {r4-r8,lr}
;;;140    {
000014  4604              MOV      r4,r0
000016  460d              MOV      r5,r1
000018  4616              MOV      r6,r2
00001a  461f              MOV      r7,r3
;;;141        CPU_SR_ALLOC();
00001c  f04f0800          MOV      r8,#0
;;;142    	
;;;143    	CPU_CRITICAL_ENTER();
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0
;;;144        param_table[0] = COPY_RAM_TO_FLASH;
000026  2033              MOVS     r0,#0x33
000028  49f3              LDR      r1,|L1.1016|
00002a  6008              STR      r0,[r1,#0]  ; param_table
;;;145        param_table[1] = flash_address;
00002c  4608              MOV      r0,r1
00002e  6045              STR      r5,[r0,#4]  ; param_table
;;;146        param_table[2] = (uint32_t)flash_data_buf;
000030  6086              STR      r6,[r0,#8]  ; param_table
;;;147        param_table[3] = count;
000032  60c7              STR      r7,[r0,#0xc]  ; param_table
;;;148        param_table[4] = cclk;
000034  6104              STR      r4,[r0,#0x10]  ; param_table
;;;149        iap_entry(param_table,result_table);
000036  49f1              LDR      r1,|L1.1020|
000038  f7fffffe          BL       iap_entry
;;;150    	CPU_CRITICAL_EXIT();
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       CPU_SR_Restore
;;;151    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;152    
                          ENDP

                  prepare_sector PROC
;;;166    
;;;167    void prepare_sector(uint32_t start_sector,uint32_t end_sector,uint32_t cclk)
000046  b570              PUSH     {r4-r6,lr}
;;;168    {
000048  4606              MOV      r6,r0
00004a  460c              MOV      r4,r1
00004c  4615              MOV      r5,r2
;;;169        param_table[0] = PREPARE_SECTOR_FOR_WRITE;
00004e  2032              MOVS     r0,#0x32
000050  49e9              LDR      r1,|L1.1016|
000052  6008              STR      r0,[r1,#0]  ; param_table
;;;170        param_table[1] = start_sector;
000054  4608              MOV      r0,r1
000056  6046              STR      r6,[r0,#4]  ; param_table
;;;171        param_table[2] = end_sector;
000058  6084              STR      r4,[r0,#8]  ; param_table
;;;172        param_table[3] = cclk;
00005a  60c5              STR      r5,[r0,#0xc]  ; param_table
;;;173        iap_entry(param_table,result_table);
00005c  49e7              LDR      r1,|L1.1020|
00005e  f7fffffe          BL       iap_entry
;;;174    }
000062  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

                  erase_sector PROC
;;;152    
;;;153    void erase_sector(uint32_t start_sector,uint32_t end_sector,uint32_t cclk)
000064  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
000068  4604              MOV      r4,r0
00006a  460d              MOV      r5,r1
00006c  4616              MOV      r6,r2
;;;155        CPU_SR_ALLOC();
00006e  2700              MOVS     r7,#0
;;;156    	
;;;157    	CPU_CRITICAL_ENTER();
000070  f7fffffe          BL       CPU_SR_Save
000074  4607              MOV      r7,r0
;;;158    	    
;;;159    	param_table[0] = ERASE_SECTOR;
000076  2034              MOVS     r0,#0x34
000078  49df              LDR      r1,|L1.1016|
00007a  6008              STR      r0,[r1,#0]  ; param_table
;;;160        param_table[1] = start_sector;
00007c  4608              MOV      r0,r1
00007e  6044              STR      r4,[r0,#4]  ; param_table
;;;161        param_table[2] = end_sector;
000080  6085              STR      r5,[r0,#8]  ; param_table
;;;162        param_table[3] = cclk;
000082  60c6              STR      r6,[r0,#0xc]  ; param_table
;;;163        iap_entry(param_table,result_table);
000084  49dd              LDR      r1,|L1.1020|
000086  f7fffffe          BL       iap_entry
;;;164    	CPU_CRITICAL_EXIT();
00008a  4638              MOV      r0,r7
00008c  f7fffffe          BL       CPU_SR_Restore
;;;165    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;166    
                          ENDP

                  find_erase_prepare_sector PROC
;;;105    
;;;106    void find_erase_prepare_sector(uint32_t cclk, uint32_t flash_address)
000094  e92d41f0          PUSH     {r4-r8,lr}
;;;107    {
000098  4606              MOV      r6,r0
00009a  460d              MOV      r5,r1
;;;108        uint32_t i;
;;;109        CPU_SR_ALLOC();
00009c  2700              MOVS     r7,#0
;;;110    	
;;;111    	CPU_CRITICAL_ENTER();
00009e  f7fffffe          BL       CPU_SR_Save
0000a2  4607              MOV      r7,r0
;;;112    
;;;113        for(i=USER_START_SECTOR;i<=MAX_USER_SECTOR;i++)
0000a4  240a              MOVS     r4,#0xa
0000a6  e01a              B        |L1.222|
                  |L1.168|
;;;114        {
;;;115            if(flash_address < sector_end_map[i])
0000a8  48d5              LDR      r0,|L1.1024|
0000aa  f8500024          LDR      r0,[r0,r4,LSL #2]
0000ae  42a8              CMP      r0,r5
0000b0  d914              BLS      |L1.220|
;;;116            {
;;;117                if( flash_address == sector_start_map[i])
0000b2  48d4              LDR      r0,|L1.1028|
0000b4  f8500024          LDR      r0,[r0,r4,LSL #2]
0000b8  42a8              CMP      r0,r5
0000ba  d109              BNE      |L1.208|
;;;118                {
;;;119                    prepare_sector(i,i,cclk);
0000bc  4632              MOV      r2,r6
0000be  4621              MOV      r1,r4
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       prepare_sector
;;;120                    erase_sector(i,i,cclk);
0000c6  4632              MOV      r2,r6
0000c8  4621              MOV      r1,r4
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       erase_sector
                  |L1.208|
;;;121                }
;;;122                prepare_sector(i,i,cclk);
0000d0  4632              MOV      r2,r6
0000d2  4621              MOV      r1,r4
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       prepare_sector
;;;123                break;
0000da  e002              B        |L1.226|
                  |L1.220|
0000dc  1c64              ADDS     r4,r4,#1              ;113
                  |L1.222|
0000de  2c14              CMP      r4,#0x14              ;113
0000e0  d9e2              BLS      |L1.168|
                  |L1.226|
0000e2  bf00              NOP      
;;;124            }
;;;125        }
;;;126    	CPU_CRITICAL_EXIT();
0000e4  4638              MOV      r0,r7
0000e6  f7fffffe          BL       CPU_SR_Restore
;;;127    }
0000ea  e8bd81f0          POP      {r4-r8,pc}
;;;128    
                          ENDP

                  write_flash PROC
;;;69     
;;;70     uint32_t write_flash(uint32_t * dst, uint8_t * src, uint32_t no_of_bytes)
0000ee  e92d41f0          PUSH     {r4-r8,lr}
;;;71     {
0000f2  4606              MOV      r6,r0
0000f4  460f              MOV      r7,r1
0000f6  4615              MOV      r5,r2
;;;72         uint32_t i;
;;;73     
;;;74       if (flash_address == 0)
0000f8  48c3              LDR      r0,|L1.1032|
0000fa  6800              LDR      r0,[r0,#0]  ; flash_address
0000fc  b908              CBNZ     r0,|L1.258|
;;;75     	{
;;;76     		/* Store flash start address */
;;;77     		flash_address = (uint32_t *)dst;
0000fe  48c2              LDR      r0,|L1.1032|
000100  6006              STR      r6,[r0,#0]  ; flash_address
                  |L1.258|
;;;78     	}
;;;79     	for( i = 0;i<no_of_bytes;i++ )
000102  2400              MOVS     r4,#0
000104  e006              B        |L1.276|
                  |L1.262|
;;;80     	{
;;;81     		flash_buf[(byte_ctr+i)] = *(src+i);
000106  5d38              LDRB     r0,[r7,r4]
000108  49c0              LDR      r1,|L1.1036|
00010a  6809              LDR      r1,[r1,#0]  ; byte_ctr
00010c  4421              ADD      r1,r1,r4
00010e  4ac0              LDR      r2,|L1.1040|
000110  5450              STRB     r0,[r2,r1]
000112  1c64              ADDS     r4,r4,#1              ;79
                  |L1.276|
000114  42ac              CMP      r4,r5                 ;79
000116  d3f6              BCC      |L1.262|
;;;82         }
;;;83     	byte_ctr = byte_ctr + no_of_bytes;
000118  48bc              LDR      r0,|L1.1036|
00011a  6800              LDR      r0,[r0,#0]  ; byte_ctr
00011c  4428              ADD      r0,r0,r5
00011e  49bb              LDR      r1,|L1.1036|
000120  6008              STR      r0,[r1,#0]  ; byte_ctr
;;;84     
;;;85     	if( byte_ctr == FLASH_BUF_SIZE)
000122  4608              MOV      r0,r1
000124  6800              LDR      r0,[r0,#0]  ; byte_ctr
000126  f5b07f80          CMP      r0,#0x100
00012a  d11e              BNE      |L1.362|
;;;86     	{
;;;87     	  /* We have accumulated enough bytes to trigger a flash write */
;;;88     	  find_erase_prepare_sector(cclk, (uint32_t)flash_address);
00012c  48b6              LDR      r0,|L1.1032|
00012e  6801              LDR      r1,[r0,#0]  ; flash_address
000130  48b8              LDR      r0,|L1.1044|
000132  6800              LDR      r0,[r0,#0]  ; cclk
000134  f7fffffe          BL       find_erase_prepare_sector
;;;89           if(result_table[0] != CMD_SUCCESS)
000138  48b0              LDR      r0,|L1.1020|
00013a  6800              LDR      r0,[r0,#0]  ; result_table
00013c  b110              CBZ      r0,|L1.324|
;;;90           {
;;;91             return (1); /* No way to recover. Just let Windows report a write failure */
00013e  2001              MOVS     r0,#1
                  |L1.320|
;;;92           }
;;;93           write_data(cclk,(uint32_t)flash_address,(uint32_t *)flash_buf,FLASH_BUF_SIZE);
;;;94           if(result_table[0] != CMD_SUCCESS)
;;;95           {
;;;96             return (1); /* No way to recover. Just let Windows report a write failure */
;;;97           }
;;;98     	  /* Reset byte counter and flash address */
;;;99     	  byte_ctr      = 0;
;;;100    	  flash_address = 0;
;;;101    	}
;;;102        return(CMD_SUCCESS);
;;;103    }
000140  e8bd81f0          POP      {r4-r8,pc}
                  |L1.324|
000144  f44f7380          MOV      r3,#0x100             ;93
000148  4ab1              LDR      r2,|L1.1040|
00014a  48af              LDR      r0,|L1.1032|
00014c  6801              LDR      r1,[r0,#0]            ;93  ; flash_address
00014e  48b1              LDR      r0,|L1.1044|
000150  6800              LDR      r0,[r0,#0]            ;93  ; cclk
000152  f7fffffe          BL       write_data
000156  48a9              LDR      r0,|L1.1020|
000158  6800              LDR      r0,[r0,#0]            ;94  ; result_table
00015a  b108              CBZ      r0,|L1.352|
00015c  2001              MOVS     r0,#1                 ;96
00015e  e7ef              B        |L1.320|
                  |L1.352|
000160  2000              MOVS     r0,#0                 ;99
000162  49aa              LDR      r1,|L1.1036|
000164  6008              STR      r0,[r1,#0]            ;99  ; byte_ctr
000166  49a8              LDR      r1,|L1.1032|
000168  6008              STR      r0,[r1,#0]            ;100  ; flash_address
                  |L1.362|
00016a  2000              MOVS     r0,#0                 ;102
00016c  e7e8              B        |L1.320|
;;;104    
                          ENDP

                  erase_user_area PROC
;;;128    
;;;129    uint8_t erase_user_area(void)
00016e  b510              PUSH     {r4,lr}
;;;130    {
;;;131     	prepare_sector(USER_START_SECTOR,MAX_USER_SECTOR,cclk);
000170  48a8              LDR      r0,|L1.1044|
000172  2114              MOVS     r1,#0x14
000174  6802              LDR      r2,[r0,#0]  ; cclk
000176  200a              MOVS     r0,#0xa
000178  f7fffffe          BL       prepare_sector
;;;132    	erase_sector(USER_START_SECTOR,MAX_USER_SECTOR,cclk);
00017c  48a5              LDR      r0,|L1.1044|
00017e  2114              MOVS     r1,#0x14
000180  6802              LDR      r2,[r0,#0]  ; cclk
000182  200a              MOVS     r0,#0xa
000184  f7fffffe          BL       erase_sector
;;;133    	if( result_table[0] != CMD_SUCCESS ) {
000188  489c              LDR      r0,|L1.1020|
00018a  6800              LDR      r0,[r0,#0]  ; result_table
00018c  b108              CBZ      r0,|L1.402|
;;;134    		return 0;
00018e  2000              MOVS     r0,#0
                  |L1.400|
;;;135    	}
;;;136    	return 1;
;;;137    }
000190  bd10              POP      {r4,pc}
                  |L1.402|
000192  2001              MOVS     r0,#1                 ;136
000194  e7fc              B        |L1.400|
;;;138    
                          ENDP

                  compare_data PROC
;;;181    */
;;;182    unsigned compare_data(unsigned flash_address,unsigned ram_address,unsigned length)
000196  e92d41f0          PUSH     {r4-r8,lr}
;;;183    {
00019a  4604              MOV      r4,r0
00019c  460d              MOV      r5,r1
00019e  4616              MOV      r6,r2
;;;184        CPU_SR_ALLOC();
0001a0  2700              MOVS     r7,#0
;;;185    	
;;;186    	CPU_CRITICAL_ENTER();
0001a2  f7fffffe          BL       CPU_SR_Save
0001a6  4607              MOV      r7,r0
;;;187    	param_table[0] = COMPARE;
0001a8  2038              MOVS     r0,#0x38
0001aa  4993              LDR      r1,|L1.1016|
0001ac  6008              STR      r0,[r1,#0]  ; param_table
;;;188        param_table[1] = flash_address;
0001ae  4608              MOV      r0,r1
0001b0  6044              STR      r4,[r0,#4]  ; param_table
;;;189        param_table[2] = ram_address;
0001b2  6085              STR      r5,[r0,#8]  ; param_table
;;;190    	param_table[3] = length;
0001b4  60c6              STR      r6,[r0,#0xc]  ; param_table
;;;191        iap_entry(param_table,result_table);
0001b6  4991              LDR      r1,|L1.1020|
0001b8  f7fffffe          BL       iap_entry
;;;192    	CPU_CRITICAL_EXIT();
0001bc  4638              MOV      r0,r7
0001be  f7fffffe          BL       CPU_SR_Restore
;;;193    	if(result_table[0] != CMD_SUCCESS)
0001c2  488e              LDR      r0,|L1.1020|
0001c4  6800              LDR      r0,[r0,#0]  ; result_table
0001c6  b110              CBZ      r0,|L1.462|
;;;194        {
;;;195            return (0); 
0001c8  2000              MOVS     r0,#0
                  |L1.458|
;;;196        }
;;;197    	return (1);
;;;198    }
0001ca  e8bd81f0          POP      {r4-r8,pc}
                  |L1.462|
0001ce  2001              MOVS     r0,#1                 ;197
0001d0  e7fb              B        |L1.458|
;;;199    
                          ENDP

                  execute_user_code PROC
;;;212    
;;;213    void execute_user_code(void)
0001d2  b510              PUSH     {r4,lr}
;;;214    {
;;;215    	/* Change the Vector Table to the USER_FLASH_START 
;;;216    	in case the user application uses interrupts */
;;;217    	SCB->VTOR = USER_FLASH_START & 0x1FFFFF80;
0001d4  488b              LDR      r0,|L1.1028|
0001d6  6a80              LDR      r0,[r0,#0x28]  ; sector_start_map
0001d8  498f              LDR      r1,|L1.1048|
0001da  4008              ANDS     r0,r0,r1
0001dc  498f              LDR      r1,|L1.1052|
0001de  6008              STR      r0,[r1,#0]
;;;218    
;;;219    	boot_jump(USER_FLASH_START);
0001e0  4988              LDR      r1,|L1.1028|
0001e2  6a88              LDR      r0,[r1,#0x28]  ; sector_start_map
0001e4  f7fffffe          BL       boot_jump
;;;220    }
0001e8  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  user_code_present PROC
;;;222    uint32_t user_code_present(void)
0001ea  b510              PUSH     {r4,lr}
;;;223    {
;;;224        param_table[0] = BLANK_CHECK_SECTOR;
0001ec  2035              MOVS     r0,#0x35
0001ee  4982              LDR      r1,|L1.1016|
0001f0  6008              STR      r0,[r1,#0]  ; param_table
;;;225        param_table[1] = USER_START_SECTOR;
0001f2  200a              MOVS     r0,#0xa
0001f4  6048              STR      r0,[r1,#4]  ; param_table
;;;226        param_table[2] = USER_START_SECTOR;
0001f6  6088              STR      r0,[r1,#8]  ; param_table
;;;227        iap_entry(param_table,result_table);
0001f8  4980              LDR      r1,|L1.1020|
0001fa  487f              LDR      r0,|L1.1016|
0001fc  f7fffffe          BL       iap_entry
;;;228    	if( result_table[0] == CMD_SUCCESS )
000200  487e              LDR      r0,|L1.1020|
000202  6800              LDR      r0,[r0,#0]  ; result_table
000204  b908              CBNZ     r0,|L1.522|
;;;229    	{
;;;230    	    return (0);
000206  2000              MOVS     r0,#0
                  |L1.520|
;;;231    	}
;;;232    	else
;;;233    	{
;;;234    	    return (1);
;;;235    	}
;;;236    }
000208  bd10              POP      {r4,pc}
                  |L1.522|
00020a  2001              MOVS     r0,#1                 ;234
00020c  e7fc              B        |L1.520|
;;;237    
                          ENDP

                  read_data32 PROC
;;;249    static 
;;;250    read_data32( uint32_t flash_addr,
00020e  b510              PUSH     {r4,lr}
;;;251                                 uint32_t *buf, uint32_t length )
;;;252    {
000210  4603              MOV      r3,r0
;;;253       uint32_t *des = (uint32_t *)flash_addr;
000212  461c              MOV      r4,r3
;;;254       while(length)
000214  e003              B        |L1.542|
                  |L1.534|
;;;255       {
;;;256           *buf++ = *des++;
000216  cc01              LDM      r4!,{r0}
000218  c101              STM      r1!,{r0}
;;;257    	   length -= 1;     /* 单为int型数据的个数 */ 
00021a  1e50              SUBS     r0,r2,#1
00021c  4602              MOV      r2,r0
                  |L1.542|
00021e  2a00              CMP      r2,#0                 ;254
000220  d1f9              BNE      |L1.534|
;;;258       }
;;;259    }
000222  bd10              POP      {r4,pc}
;;;260    
                          ENDP

                  read_flash_data PROC
;;;263    
;;;264    void read_flash_data( uint32_t *flash_addr,
000224  b530              PUSH     {r4,r5,lr}
;;;265                              uint8_t  *buf ,uint32_t len)
;;;266    {	
;;;267    	uint8_t *des = (uint8_t *)flash_addr;
000226  4603              MOV      r3,r0
;;;268    	while(len--)
000228  e003              B        |L1.562|
                  |L1.554|
;;;269    	{
;;;270    	   *buf++ = *des++;     
00022a  f8134b01          LDRB     r4,[r3],#1
00022e  f8014b01          STRB     r4,[r1],#1
                  |L1.562|
000232  1e14              SUBS     r4,r2,#0              ;268
000234  f1a20201          SUB      r2,r2,#1              ;268
000238  d1f7              BNE      |L1.554|
;;;271    	}
;;;272    }
00023a  bd30              POP      {r4,r5,pc}
;;;273    
                          ENDP

                  write_flash_data PROC
;;;274    uint8_t write_flash_data ( uint32_t OffSet, 
00023c  b570              PUSH     {r4-r6,lr}
;;;275                               uint8_t* buf, uint32_t len )
;;;276    {
00023e  4604              MOV      r4,r0
000240  460e              MOV      r6,r1
000242  4615              MOV      r5,r2
;;;277    	if( (OffSet+len) > MAX_LENGTH )
000244  1960              ADDS     r0,r4,r5
000246  f5b07f80          CMP      r0,#0x100
00024a  d901              BLS      |L1.592|
;;;278    	{
;;;279    	    return DEF_FALSE;
00024c  2001              MOVS     r0,#1
                  |L1.590|
;;;280    	}
;;;281    	
;;;282    	read_data32(FLASH_DATA_ADDR_START,&WriteBuf[0],64); /* 64*4 */
;;;283    	memcpy((uint8_t *)&WriteBuf[0]+OffSet,buf,len);
;;;284    	
;;;285    	prepare_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);        /* select sector */
;;;286    	erase_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);	         //erase sector for write
;;;287    	
;;;288    	prepare_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);        //select sector
;;;289    	
;;;290    	write_data(IAP_CCLK,FLASH_DATA_ADDR_START,(unsigned int*)&WriteBuf[0],256);
;;;291    
;;;292        
;;;293        return DEF_TRUE;
;;;294    }
00024e  bd70              POP      {r4-r6,pc}
                  |L1.592|
000250  2240              MOVS     r2,#0x40              ;282
000252  4973              LDR      r1,|L1.1056|
000254  f44f40e0          MOV      r0,#0x7000            ;282
000258  f7fffffe          BL       read_data32
00025c  4970              LDR      r1,|L1.1056|
00025e  1908              ADDS     r0,r1,r4              ;283
000260  462a              MOV      r2,r5                 ;283
000262  4631              MOV      r1,r6                 ;283
000264  f7fffffe          BL       __aeabi_memcpy
000268  4a6e              LDR      r2,|L1.1060|
00026a  2107              MOVS     r1,#7                 ;285
00026c  4608              MOV      r0,r1                 ;285
00026e  f7fffffe          BL       prepare_sector
000272  4a6c              LDR      r2,|L1.1060|
000274  2107              MOVS     r1,#7                 ;286
000276  4608              MOV      r0,r1                 ;286
000278  f7fffffe          BL       erase_sector
00027c  4a69              LDR      r2,|L1.1060|
00027e  2107              MOVS     r1,#7                 ;288
000280  4608              MOV      r0,r1                 ;288
000282  f7fffffe          BL       prepare_sector
000286  f44f7380          MOV      r3,#0x100             ;290
00028a  4a65              LDR      r2,|L1.1056|
00028c  f44f41e0          MOV      r1,#0x7000            ;290
000290  4864              LDR      r0,|L1.1060|
000292  f7fffffe          BL       write_data
000296  2000              MOVS     r0,#0                 ;293
000298  e7d9              B        |L1.590|
;;;295    
                          ENDP

                  read_flash_data_offset PROC
;;;296    /*从FLASH读取用户数据*/
;;;297    void read_flash_data_offset( uint32_t start_add , uint32_t OffSet,
00029a  b570              PUSH     {r4-r6,lr}
;;;298                              uint8_t  *buf ,uint32_t len)
;;;299    {
;;;300    	uint8_t *des = (uint8_t *)( start_add + OffSet );
00029c  1844              ADDS     r4,r0,r1
;;;301    
;;;302    	if( (OffSet+len) > USER_DATA_MAX_SIZE )
00029e  18cd              ADDS     r5,r1,r3
0002a0  f5b57f80          CMP      r5,#0x100
0002a4  d900              BLS      |L1.680|
                  |L1.678|
;;;303    	{
;;;304    	    return ;
;;;305    	}
;;;306    	while(len--)
;;;307    	{
;;;308    	   *buf++ = *des++;
;;;309    	}
;;;310    }
0002a6  bd70              POP      {r4-r6,pc}
                  |L1.680|
0002a8  e003              B        |L1.690|
                  |L1.682|
0002aa  f8145b01          LDRB     r5,[r4],#1            ;308
0002ae  f8025b01          STRB     r5,[r2],#1            ;308
                  |L1.690|
0002b2  1e1d              SUBS     r5,r3,#0              ;306
0002b4  f1a30301          SUB      r3,r3,#1              ;306
0002b8  d1f7              BNE      |L1.682|
0002ba  bf00              NOP      
0002bc  e7f3              B        |L1.678|
;;;311    
                          ENDP

                  write_flash_data_offset PROC
;;;312    uint8_t write_flash_data_offset (uint32_t start_add , uint32_t OffSet, 
0002be  e92d41f0          PUSH     {r4-r8,lr}
;;;313                               uint8_t* buf, uint32_t len )
;;;314    {
0002c2  4607              MOV      r7,r0
0002c4  460c              MOV      r4,r1
0002c6  4616              MOV      r6,r2
0002c8  461d              MOV      r5,r3
;;;315    	if( (OffSet+len) > MAX_LENGTH )
0002ca  1960              ADDS     r0,r4,r5
0002cc  f5b07f80          CMP      r0,#0x100
0002d0  d902              BLS      |L1.728|
;;;316    	{
;;;317    	    return DEF_FALSE;
0002d2  2001              MOVS     r0,#1
                  |L1.724|
;;;318    	}
;;;319    	
;;;320    	read_data32(start_add,&WriteBuf[0],64); /* 64*4 */
;;;321    	memcpy((uint8_t *)&WriteBuf[0]+OffSet,buf,len);
;;;322    	
;;;323    	prepare_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);        /* select sector */
;;;324    	erase_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);	         //erase sector for write
;;;325    	
;;;326    	prepare_sector(FLASH_DATA_SECTOR_START,FLASH_DATA_SECTOR_START,IAP_CCLK);        //select sector
;;;327    	
;;;328    	write_data(IAP_CCLK,FLASH_DATA_ADDR_START,(unsigned int*)&WriteBuf[0],256);
;;;329    
;;;330        return DEF_TRUE;
;;;331    }
0002d4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.728|
0002d8  2240              MOVS     r2,#0x40              ;320
0002da  4951              LDR      r1,|L1.1056|
0002dc  4638              MOV      r0,r7                 ;320
0002de  f7fffffe          BL       read_data32
0002e2  494f              LDR      r1,|L1.1056|
0002e4  1908              ADDS     r0,r1,r4              ;321
0002e6  462a              MOV      r2,r5                 ;321
0002e8  4631              MOV      r1,r6                 ;321
0002ea  f7fffffe          BL       __aeabi_memcpy
0002ee  4a4d              LDR      r2,|L1.1060|
0002f0  2107              MOVS     r1,#7                 ;323
0002f2  4608              MOV      r0,r1                 ;323
0002f4  f7fffffe          BL       prepare_sector
0002f8  4a4a              LDR      r2,|L1.1060|
0002fa  2107              MOVS     r1,#7                 ;324
0002fc  4608              MOV      r0,r1                 ;324
0002fe  f7fffffe          BL       erase_sector
000302  4a48              LDR      r2,|L1.1060|
000304  2107              MOVS     r1,#7                 ;326
000306  4608              MOV      r0,r1                 ;326
000308  f7fffffe          BL       prepare_sector
00030c  f44f7380          MOV      r3,#0x100             ;328
000310  4a43              LDR      r2,|L1.1056|
000312  f44f41e0          MOV      r1,#0x7000            ;328
000316  4843              LDR      r0,|L1.1060|
000318  f7fffffe          BL       write_data
00031c  2000              MOVS     r0,#0                 ;330
00031e  e7d9              B        |L1.724|
;;;332    
                          ENDP

                  check_iap_entry_init PROC
;;;333    void check_iap_entry_init( void )
000320  4841              LDR      r0,|L1.1064|
;;;334    {
;;;335    	PINSEL4 &= ~( ( 3ul << 4 ) | ( 3ul << 8 ) ); //p0.2,p0.3
000322  6900              LDR      r0,[r0,#0x10]
000324  f420704c          BIC      r0,r0,#0x330
000328  493f              LDR      r1,|L1.1064|
00032a  6108              STR      r0,[r1,#0x10]
;;;336    	ISP_ENTRY_PIN_00_IN;
00032c  483f              LDR      r0,|L1.1068|
00032e  6c00              LDR      r0,[r0,#0x40]
000330  f0200004          BIC      r0,r0,#4
000334  493d              LDR      r1,|L1.1068|
000336  6408              STR      r0,[r1,#0x40]
;;;337    	ISP_ENTRY_PIN_01_OUT;	
000338  4608              MOV      r0,r1
00033a  6c00              LDR      r0,[r0,#0x40]
00033c  f0400010          ORR      r0,r0,#0x10
000340  6408              STR      r0,[r1,#0x40]
;;;338    }
000342  4770              BX       lr
;;;339    
                          ENDP

                  check_iap_entry_pin PROC
;;;340    void check_iap_entry_pin( void )
000344  b570              PUSH     {r4-r6,lr}
;;;341    {
;;;342    	unsigned int i,cnt; //硬件入口虑波	
;;;343    	
;;;344    	cnt = 0;
000346  2500              MOVS     r5,#0
;;;345    	if( *( ( uint32_t * )PROGRAM_FLAG_ADDR ) == 0x77557755 ) {
000348  f44f4000          MOV      r0,#0x8000
00034c  6800              LDR      r0,[r0,#0]
00034e  4938              LDR      r1,|L1.1072|
000350  4288              CMP      r0,r1
000352  d171              BNE      |L1.1080|
;;;346    		ISP_ENTRY_PIN_01_OUT_H;
000354  2010              MOVS     r0,#0x10
000356  4935              LDR      r1,|L1.1068|
000358  6588              STR      r0,[r1,#0x58]
;;;347    		for( i = 50; i > 0; i-- ); // delay for gpio ready
00035a  2432              MOVS     r4,#0x32
00035c  e000              B        |L1.864|
                  |L1.862|
00035e  1e64              SUBS     r4,r4,#1
                  |L1.864|
000360  2c00              CMP      r4,#0
000362  d1fc              BNE      |L1.862|
;;;348    		if( ISP_ENTRY_PIN_00_RD ) {
000364  4831              LDR      r0,|L1.1068|
000366  6d40              LDR      r0,[r0,#0x54]
000368  f0000004          AND      r0,r0,#4
00036c  2800              CMP      r0,#0
00036e  d061              BEQ      |L1.1076|
;;;349    			for( i = 50; i > 0; i-- ) {
000370  2432              MOVS     r4,#0x32
000372  e006              B        |L1.898|
                  |L1.884|
;;;350    				if( !ISP_ENTRY_PIN_00_RD ) {
000374  482d              LDR      r0,|L1.1068|
000376  6d40              LDR      r0,[r0,#0x54]
000378  f0000004          AND      r0,r0,#4
00037c  b900              CBNZ     r0,|L1.896|
;;;351    					cnt++;
00037e  1c6d              ADDS     r5,r5,#1
                  |L1.896|
000380  1e64              SUBS     r4,r4,#1              ;349
                  |L1.898|
000382  2c00              CMP      r4,#0                 ;349
000384  d1f6              BNE      |L1.884|
;;;352    				}
;;;353    			}
;;;354    			if( cnt == 0 ) {
000386  2d00              CMP      r5,#0
000388  d154              BNE      |L1.1076|
;;;355    				ISP_ENTRY_PIN_01_OUT_L;
00038a  2010              MOVS     r0,#0x10
00038c  4927              LDR      r1,|L1.1068|
00038e  65c8              STR      r0,[r1,#0x5c]
;;;356    				for( i = 50; i > 0; i-- ); // delay for gpio ready
000390  2432              MOVS     r4,#0x32
000392  e000              B        |L1.918|
                  |L1.916|
000394  1e64              SUBS     r4,r4,#1
                  |L1.918|
000396  2c00              CMP      r4,#0
000398  d1fc              BNE      |L1.916|
;;;357    				if( !ISP_ENTRY_PIN_00_RD ) {
00039a  4824              LDR      r0,|L1.1068|
00039c  6d40              LDR      r0,[r0,#0x54]
00039e  f0000004          AND      r0,r0,#4
0003a2  bb28              CBNZ     r0,|L1.1008|
;;;358    					for( i = 50; i > 0; i-- ) {
0003a4  2432              MOVS     r4,#0x32
0003a6  e006              B        |L1.950|
                  |L1.936|
;;;359    						if( ISP_ENTRY_PIN_00_RD ) {
0003a8  4820              LDR      r0,|L1.1068|
0003aa  6d40              LDR      r0,[r0,#0x54]
0003ac  f0000004          AND      r0,r0,#4
0003b0  b100              CBZ      r0,|L1.948|
;;;360    							cnt++;
0003b2  1c6d              ADDS     r5,r5,#1
                  |L1.948|
0003b4  1e64              SUBS     r4,r4,#1              ;358
                  |L1.950|
0003b6  2c00              CMP      r4,#0                 ;358
0003b8  d1f6              BNE      |L1.936|
;;;361    						}
;;;362    					}
;;;363    					if( cnt == 0 ) {
0003ba  b9cd              CBNZ     r5,|L1.1008|
;;;364    						ISP_ENTRY_PIN_01_OUT_H;
0003bc  2010              MOVS     r0,#0x10
0003be  491b              LDR      r1,|L1.1068|
0003c0  6588              STR      r0,[r1,#0x58]
;;;365    						for( i = 50; i > 0; i-- ); // delay for gpio ready
0003c2  2432              MOVS     r4,#0x32
0003c4  e000              B        |L1.968|
                  |L1.966|
0003c6  1e64              SUBS     r4,r4,#1
                  |L1.968|
0003c8  2c00              CMP      r4,#0
0003ca  d1fc              BNE      |L1.966|
;;;366    						if( ISP_ENTRY_PIN_00_RD ) {
0003cc  4817              LDR      r0,|L1.1068|
0003ce  6d40              LDR      r0,[r0,#0x54]
0003d0  f0000004          AND      r0,r0,#4
0003d4  b160              CBZ      r0,|L1.1008|
;;;367    							for( i = 50; i > 0; i-- ) {
0003d6  2432              MOVS     r4,#0x32
0003d8  e006              B        |L1.1000|
                  |L1.986|
;;;368    								if( !ISP_ENTRY_PIN_00_RD ) {
0003da  4814              LDR      r0,|L1.1068|
0003dc  6d40              LDR      r0,[r0,#0x54]
0003de  f0000004          AND      r0,r0,#4
0003e2  b900              CBNZ     r0,|L1.998|
;;;369    									cnt++;
0003e4  1c6d              ADDS     r5,r5,#1
                  |L1.998|
0003e6  1e64              SUBS     r4,r4,#1              ;367
                  |L1.1000|
0003e8  2c00              CMP      r4,#0                 ;367
0003ea  d1f6              BNE      |L1.986|
;;;370    								}
;;;371    							}
;;;372    							if( cnt == 0 ) {
0003ec  b905              CBNZ     r5,|L1.1008|
;;;373    								return;
;;;374    							}
;;;375    						}
;;;376    					}
;;;377    				}
;;;378    			}
;;;379    		}
;;;380    //		place_aes_key();			
;;;381    		execute_user_code();		
;;;382    	}
;;;383    }
0003ee  bd70              POP      {r4-r6,pc}
                  |L1.1008|
0003f0  e020              B        |L1.1076|
0003f2  e021              B        |L1.1080|
                  |L1.1012|
                          DCD      0x1fff1ff1
                  |L1.1016|
                          DCD      param_table
                  |L1.1020|
                          DCD      result_table
                  |L1.1024|
                          DCD      sector_end_map
                  |L1.1028|
                          DCD      sector_start_map
                  |L1.1032|
                          DCD      flash_address
                  |L1.1036|
                          DCD      byte_ctr
                  |L1.1040|
                          DCD      flash_buf
                  |L1.1044|
                          DCD      cclk
                  |L1.1048|
                          DCD      0x1fffff80
                  |L1.1052|
                          DCD      0xe000ed08
                  |L1.1056|
                          DCD      WriteBuf
                  |L1.1060|
                          DCD      0x000186a0
                  |L1.1064|
                          DCD      0x4002c000
                  |L1.1068|
                          DCD      0x2009c000
                  |L1.1072|
                          DCD      0x77557755
                  |L1.1076|
000434  f7fffffe          BL       execute_user_code
                  |L1.1080|
000438  bf00              NOP      
00043a  bd70              POP      {r4-r6,pc}
;;;384    
                          ENDP

                  erase_user_flash PROC
;;;385    void erase_user_flash(void)
00043c  b510              PUSH     {r4,lr}
;;;386    {
;;;387        prepare_sector(USER_START_SECTOR,MAX_USER_SECTOR,cclk);
00043e  48fe              LDR      r0,|L1.2104|
000440  2114              MOVS     r1,#0x14
000442  6802              LDR      r2,[r0,#0]  ; cclk
000444  200a              MOVS     r0,#0xa
000446  f7fffffe          BL       prepare_sector
;;;388        erase_sector(USER_START_SECTOR,MAX_USER_SECTOR,cclk);
00044a  48fb              LDR      r0,|L1.2104|
00044c  2114              MOVS     r1,#0x14
00044e  6802              LDR      r2,[r0,#0]  ; cclk
000450  200a              MOVS     r0,#0xa
000452  f7fffffe          BL       erase_sector
;;;389    	if(result_table[0] != CMD_SUCCESS)
000456  48f9              LDR      r0,|L1.2108|
000458  6800              LDR      r0,[r0,#0]  ; result_table
00045a  b108              CBZ      r0,|L1.1120|
;;;390        {
;;;391          while(1); /* No way to recover. Just let Windows report a write failure */
00045c  bf00              NOP      
                  |L1.1118|
00045e  e7fe              B        |L1.1118|
                  |L1.1120|
;;;392        }
;;;393    }
000460  bd10              POP      {r4,pc}
;;;394    
                          ENDP

                  write_programming_done_flag PROC
;;;395    void write_programming_done_flag(void)
000462  b510              PUSH     {r4,lr}
;;;396    {
;;;397    	read_data32(PROGRAM_FLAG_ADDR,&WriteBuf[0],64);                       /* 64*4 */
000464  2240              MOVS     r2,#0x40
000466  49f6              LDR      r1,|L1.2112|
000468  0250              LSLS     r0,r2,#9
00046a  f7fffffe          BL       read_data32
;;;398    	*(unsigned int*)&WriteBuf[0] =  0x77557755;
00046e  48f5              LDR      r0,|L1.2116|
000470  49f3              LDR      r1,|L1.2112|
000472  6008              STR      r0,[r1,#0]  ; WriteBuf
;;;399    	*(unsigned int*)&WriteBuf[4] = ~0x77557755;
000474  43c0              MVNS     r0,r0
000476  6108              STR      r0,[r1,#0x10]  ; WriteBuf
;;;400        WDT_Feed();
000478  f7fffffe          BL       WDT_Feed
;;;401    	prepare_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);         //select sector
00047c  4af2              LDR      r2,|L1.2120|
00047e  2108              MOVS     r1,#8
000480  4608              MOV      r0,r1
000482  f7fffffe          BL       prepare_sector
;;;402    	erase_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);	          //erase sector for write
000486  4af0              LDR      r2,|L1.2120|
000488  2108              MOVS     r1,#8
00048a  4608              MOV      r0,r1
00048c  f7fffffe          BL       erase_sector
;;;403    	prepare_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);         //select sector
000490  4aed              LDR      r2,|L1.2120|
000492  2108              MOVS     r1,#8
000494  4608              MOV      r0,r1
000496  f7fffffe          BL       prepare_sector
;;;404    	write_data(CCLK,PROGRAM_FLAG_ADDR,(unsigned int*)&WriteBuf[0],256);   //count must be 256,512,1024,4096
00049a  f44f7380          MOV      r3,#0x100
00049e  4ae8              LDR      r2,|L1.2112|
0004a0  01d9              LSLS     r1,r3,#7
0004a2  48e9              LDR      r0,|L1.2120|
0004a4  f7fffffe          BL       write_data
;;;405    }
0004a8  bd10              POP      {r4,pc}
;;;406    
                          ENDP

                  erase_programming_done_flag PROC
;;;407    void erase_programming_done_flag(void)
0004aa  b510              PUSH     {r4,lr}
;;;408    {
;;;409    	read_data32(PROGRAM_FLAG_ADDR,&WriteBuf[0],64);                       /* 64*4 */
0004ac  2240              MOVS     r2,#0x40
0004ae  49e4              LDR      r1,|L1.2112|
0004b0  0250              LSLS     r0,r2,#9
0004b2  f7fffffe          BL       read_data32
;;;410    	*(unsigned int*)&WriteBuf[0] =  0x0;
0004b6  2000              MOVS     r0,#0
0004b8  49e1              LDR      r1,|L1.2112|
0004ba  6008              STR      r0,[r1,#0]  ; WriteBuf
;;;411    	*(unsigned int*)&WriteBuf[4] =  0x0;
0004bc  6108              STR      r0,[r1,#0x10]  ; WriteBuf
;;;412        WDT_Feed();
0004be  f7fffffe          BL       WDT_Feed
;;;413    	prepare_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);         //select sector
0004c2  4ae1              LDR      r2,|L1.2120|
0004c4  2108              MOVS     r1,#8
0004c6  4608              MOV      r0,r1
0004c8  f7fffffe          BL       prepare_sector
;;;414    	erase_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);	          //erase sector for write
0004cc  4ade              LDR      r2,|L1.2120|
0004ce  2108              MOVS     r1,#8
0004d0  4608              MOV      r0,r1
0004d2  f7fffffe          BL       erase_sector
;;;415    	prepare_sector(PROGRAM_FLAG_SECTOR,PROGRAM_FLAG_SECTOR,CCLK);         //select sector
0004d6  4adc              LDR      r2,|L1.2120|
0004d8  2108              MOVS     r1,#8
0004da  4608              MOV      r0,r1
0004dc  f7fffffe          BL       prepare_sector
;;;416    	write_data(CCLK,PROGRAM_FLAG_ADDR,(unsigned int*)&WriteBuf[0],256);   //count must be 256,512,1024,4096
0004e0  f44f7380          MOV      r3,#0x100
0004e4  4ad6              LDR      r2,|L1.2112|
0004e6  01d9              LSLS     r1,r3,#7
0004e8  48d7              LDR      r0,|L1.2120|
0004ea  f7fffffe          BL       write_data
;;;417    }
0004ee  bd10              POP      {r4,pc}
;;;418    
                          ENDP

                  hardware_id_read_flash PROC
;;;419    void hardware_id_read_flash(uint8_t *buf, uint32_t len)
0004f0  b530              PUSH     {r4,r5,lr}
;;;420    {
0004f2  4604              MOV      r4,r0
0004f4  460d              MOV      r5,r1
;;;421        read_flash_data((CPU_INT32U *)HARDWARE_ID_ADDR,buf,len);
0004f6  462a              MOV      r2,r5
0004f8  4621              MOV      r1,r4
0004fa  f44f4010          MOV      r0,#0x9000
0004fe  f7fffffe          BL       read_flash_data
;;;422    }
000502  bd30              POP      {r4,r5,pc}
;;;423    
                          ENDP

                  hardware_id_write_flash PROC
;;;424    bool hardware_id_write_flash(CPU_INT08U *buf, CPU_INT32U len)
000504  b570              PUSH     {r4-r6,lr}
;;;425    {
000506  4605              MOV      r5,r0
000508  460e              MOV      r6,r1
;;;426        uint32_t i = 0;
00050a  2400              MOVS     r4,#0
;;;427        WDT_Feed();
00050c  f7fffffe          BL       WDT_Feed
;;;428     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
000510  2240              MOVS     r2,#0x40
000512  49cb              LDR      r1,|L1.2112|
000514  f44f4010          MOV      r0,#0x9000
000518  f7fffffe          BL       read_data32
;;;429    
;;;430    	memcpy((CPU_INT08U *)&WriteBuf[0],buf,len);
00051c  4632              MOV      r2,r6
00051e  4629              MOV      r1,r5
000520  48c7              LDR      r0,|L1.2112|
000522  f7fffffe          BL       __aeabi_memcpy
;;;431    
;;;432    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000526  4ac8              LDR      r2,|L1.2120|
000528  2109              MOVS     r1,#9
00052a  4608              MOV      r0,r1
00052c  f7fffffe          BL       prepare_sector
;;;433    
;;;434        WDT_Feed();            /* feed watchdog */
000530  f7fffffe          BL       WDT_Feed
;;;435        erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
000534  4ac4              LDR      r2,|L1.2120|
000536  2109              MOVS     r1,#9
000538  4608              MOV      r0,r1
00053a  f7fffffe          BL       erase_sector
;;;436        WDT_Feed();            /* feed watchdog */
00053e  f7fffffe          BL       WDT_Feed
;;;437    
;;;438        prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000542  4ac1              LDR      r2,|L1.2120|
000544  2109              MOVS     r1,#9
000546  4608              MOV      r0,r1
000548  f7fffffe          BL       prepare_sector
;;;439        write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
00054c  f44f7380          MOV      r3,#0x100
000550  4abb              LDR      r2,|L1.2112|
000552  f44f4110          MOV      r1,#0x9000
000556  48bc              LDR      r0,|L1.2120|
000558  f7fffffe          BL       write_data
;;;440        WDT_Feed(); 
00055c  f7fffffe          BL       WDT_Feed
;;;441        read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
000560  2240              MOVS     r2,#0x40
000562  49b7              LDR      r1,|L1.2112|
000564  f44f4010          MOV      r0,#0x9000
000568  f7fffffe          BL       read_data32
;;;442        for( i = 0; i < len; i++ ) {
00056c  bf00              NOP      
00056e  e007              B        |L1.1408|
                  |L1.1392|
;;;443            if( buf[i] != *( ( uint8_t * )WriteBuf + i ) ) return false;
000570  5d28              LDRB     r0,[r5,r4]
000572  49b3              LDR      r1,|L1.2112|
000574  5d09              LDRB     r1,[r1,r4]
000576  4288              CMP      r0,r1
000578  d001              BEQ      |L1.1406|
00057a  2000              MOVS     r0,#0
                  |L1.1404|
;;;444        }
;;;445        return true;
;;;446    }
00057c  bd70              POP      {r4-r6,pc}
                  |L1.1406|
00057e  1c64              ADDS     r4,r4,#1              ;442
                  |L1.1408|
000580  42b4              CMP      r4,r6                 ;442
000582  d3f5              BCC      |L1.1392|
000584  2001              MOVS     r0,#1                 ;445
000586  e7f9              B        |L1.1404|
;;;447    
                          ENDP

                  place_aes_key PROC
;;;449    static uint32_t lader_n_version __attribute__((at(0x10007F74))) = 0;
;;;450    void place_aes_key(void)
000588  f04f7000          MOV      r0,#0x2000000
;;;451    {
;;;452    	lader_version =  DEVICE_LOADER_VERSION;
00058c  49af              LDR      r1,|L1.2124|
00058e  6008              STR      r0,[r1,#0]  ; lader_version
;;;453    	lader_n_version = ~DEVICE_LOADER_VERSION;
000590  43c0              MVNS     r0,r0
000592  49af              LDR      r1,|L1.2128|
000594  6008              STR      r0,[r1,#0]  ; lader_n_version
;;;454    }
000596  4770              BX       lr
;;;455    
                          ENDP

                  sbl_get_loader_version PROC
;;;456    uint32_t sbl_get_loader_version( void )
000598  48ae              LDR      r0,|L1.2132|
;;;457    {
;;;458        if( *( uint32_t * )0x10007F70 == ~( *( uint32_t * )0x10007F74 ) ) {
00059a  6800              LDR      r0,[r0,#0]
00059c  49ad              LDR      r1,|L1.2132|
00059e  1d09              ADDS     r1,r1,#4
0005a0  6809              LDR      r1,[r1,#0]
0005a2  43c9              MVNS     r1,r1
0005a4  4288              CMP      r0,r1
0005a6  d102              BNE      |L1.1454|
;;;459            return *( uint32_t * )0x10007F70;
0005a8  48aa              LDR      r0,|L1.2132|
0005aa  6800              LDR      r0,[r0,#0]
                  |L1.1452|
;;;460        } else {
;;;461    //        uart_printf( 0, "%.8X %.8X\r\n", *( uint32_t * )0x10007F70, *( uint32_t * )0x10007F74 );
;;;462            return 0xFFFFFFFF;
;;;463        }
;;;464    }
0005ac  4770              BX       lr
                  |L1.1454|
0005ae  f04f30ff          MOV      r0,#0xffffffff        ;462
0005b2  e7fb              B        |L1.1452|
;;;465    
                          ENDP

                  cali_pressure1_para_write_flash PROC
;;;466    bool cali_pressure1_para_write_flash( uint8_t *buf , uint32_t len )
0005b4  b570              PUSH     {r4-r6,lr}
;;;467    {
0005b6  4605              MOV      r5,r0
0005b8  460e              MOV      r6,r1
;;;468      uint32_t i = 0;
0005ba  2400              MOVS     r4,#0
;;;469      WDT_Feed();
0005bc  f7fffffe          BL       WDT_Feed
;;;470     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
0005c0  2240              MOVS     r2,#0x40
0005c2  499f              LDR      r1,|L1.2112|
0005c4  f44f4010          MOV      r0,#0x9000
0005c8  f7fffffe          BL       read_data32
;;;471    
;;;472    	memcpy((CPU_INT08U *)&WriteBuf[0]+CALI_PRESSURE1_PARA_OFFSET,buf,len);
0005cc  4632              MOV      r2,r6
0005ce  4629              MOV      r1,r5
0005d0  489b              LDR      r0,|L1.2112|
0005d2  3020              ADDS     r0,r0,#0x20
0005d4  f7fffffe          BL       __aeabi_memcpy
;;;473    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
0005d8  4a9b              LDR      r2,|L1.2120|
0005da  2109              MOVS     r1,#9
0005dc  4608              MOV      r0,r1
0005de  f7fffffe          BL       prepare_sector
;;;474    
;;;475       WDT_Feed();            /* feed watchdog */
0005e2  f7fffffe          BL       WDT_Feed
;;;476       erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
0005e6  4a98              LDR      r2,|L1.2120|
0005e8  2109              MOVS     r1,#9
0005ea  4608              MOV      r0,r1
0005ec  f7fffffe          BL       erase_sector
;;;477       WDT_Feed();            /* feed watchdog */
0005f0  f7fffffe          BL       WDT_Feed
;;;478    
;;;479        prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
0005f4  4a94              LDR      r2,|L1.2120|
0005f6  2109              MOVS     r1,#9
0005f8  4608              MOV      r0,r1
0005fa  f7fffffe          BL       prepare_sector
;;;480        write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
0005fe  f44f7380          MOV      r3,#0x100
000602  4a8f              LDR      r2,|L1.2112|
000604  f44f4110          MOV      r1,#0x9000
000608  488f              LDR      r0,|L1.2120|
00060a  f7fffffe          BL       write_data
;;;481        WDT_Feed(); 
00060e  f7fffffe          BL       WDT_Feed
;;;482        read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
000612  2240              MOVS     r2,#0x40
000614  498a              LDR      r1,|L1.2112|
000616  f44f4010          MOV      r0,#0x9000
00061a  f7fffffe          BL       read_data32
;;;483        for( i = 0; i < len; i++ ) {
00061e  bf00              NOP      
000620  e009              B        |L1.1590|
                  |L1.1570|
;;;484            if( buf[i] != *( ( uint8_t * )WriteBuf + i +CALI_PRESSURE1_PARA_OFFSET ) ) return false;
000622  5d28              LDRB     r0,[r5,r4]
000624  4986              LDR      r1,|L1.2112|
000626  4421              ADD      r1,r1,r4
000628  f8911020          LDRB     r1,[r1,#0x20]
00062c  4288              CMP      r0,r1
00062e  d001              BEQ      |L1.1588|
000630  2000              MOVS     r0,#0
                  |L1.1586|
;;;485        }
;;;486        return true;
;;;487    }
000632  bd70              POP      {r4-r6,pc}
                  |L1.1588|
000634  1c64              ADDS     r4,r4,#1              ;483
                  |L1.1590|
000636  42b4              CMP      r4,r6                 ;483
000638  d3f3              BCC      |L1.1570|
00063a  2001              MOVS     r0,#1                 ;486
00063c  e7f9              B        |L1.1586|
;;;488    
                          ENDP

                  cali_pressure2_para_write_flash PROC
;;;489    
;;;490    bool cali_pressure2_para_write_flash( uint8_t *buf , uint32_t len )
00063e  b570              PUSH     {r4-r6,lr}
;;;491    {
000640  4605              MOV      r5,r0
000642  460e              MOV      r6,r1
;;;492      uint32_t i = 0;
000644  2400              MOVS     r4,#0
;;;493      WDT_Feed();
000646  f7fffffe          BL       WDT_Feed
;;;494     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
00064a  2240              MOVS     r2,#0x40
00064c  497c              LDR      r1,|L1.2112|
00064e  f44f4010          MOV      r0,#0x9000
000652  f7fffffe          BL       read_data32
;;;495    
;;;496    	memcpy((CPU_INT08U *)&WriteBuf[0]+CALI_PRESSURE2_PARA_OFFSET,buf,len);
000656  4632              MOV      r2,r6
000658  4629              MOV      r1,r5
00065a  4879              LDR      r0,|L1.2112|
00065c  3060              ADDS     r0,r0,#0x60
00065e  f7fffffe          BL       __aeabi_memcpy
;;;497    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000662  4a79              LDR      r2,|L1.2120|
000664  2109              MOVS     r1,#9
000666  4608              MOV      r0,r1
000668  f7fffffe          BL       prepare_sector
;;;498    
;;;499       WDT_Feed();            /* feed watchdog */
00066c  f7fffffe          BL       WDT_Feed
;;;500       erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
000670  4a75              LDR      r2,|L1.2120|
000672  2109              MOVS     r1,#9
000674  4608              MOV      r0,r1
000676  f7fffffe          BL       erase_sector
;;;501       WDT_Feed();            /* feed watchdog */
00067a  f7fffffe          BL       WDT_Feed
;;;502    
;;;503        prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
00067e  4a72              LDR      r2,|L1.2120|
000680  2109              MOVS     r1,#9
000682  4608              MOV      r0,r1
000684  f7fffffe          BL       prepare_sector
;;;504        write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
000688  f44f7380          MOV      r3,#0x100
00068c  4a6c              LDR      r2,|L1.2112|
00068e  f44f4110          MOV      r1,#0x9000
000692  486d              LDR      r0,|L1.2120|
000694  f7fffffe          BL       write_data
;;;505        WDT_Feed(); 
000698  f7fffffe          BL       WDT_Feed
;;;506        read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
00069c  2240              MOVS     r2,#0x40
00069e  4968              LDR      r1,|L1.2112|
0006a0  f44f4010          MOV      r0,#0x9000
0006a4  f7fffffe          BL       read_data32
;;;507        for( i = 0; i < len; i++ ) {
0006a8  bf00              NOP      
0006aa  e009              B        |L1.1728|
                  |L1.1708|
;;;508            if( buf[i] != *( ( uint8_t * )WriteBuf + i +CALI_PRESSURE2_PARA_OFFSET ) ) return false;
0006ac  5d28              LDRB     r0,[r5,r4]
0006ae  4964              LDR      r1,|L1.2112|
0006b0  4421              ADD      r1,r1,r4
0006b2  f8911060          LDRB     r1,[r1,#0x60]
0006b6  4288              CMP      r0,r1
0006b8  d001              BEQ      |L1.1726|
0006ba  2000              MOVS     r0,#0
                  |L1.1724|
;;;509        }
;;;510        return true;
;;;511    }
0006bc  bd70              POP      {r4-r6,pc}
                  |L1.1726|
0006be  1c64              ADDS     r4,r4,#1              ;507
                  |L1.1728|
0006c0  42b4              CMP      r4,r6                 ;507
0006c2  d3f3              BCC      |L1.1708|
0006c4  2001              MOVS     r0,#1                 ;510
0006c6  e7f9              B        |L1.1724|
;;;512    
                          ENDP

                  cali_flow_para1_write_flash PROC
;;;513    
;;;514    bool cali_flow_para1_write_flash( uint8_t *buf , uint32_t len )
0006c8  b570              PUSH     {r4-r6,lr}
;;;515    {
0006ca  4605              MOV      r5,r0
0006cc  460e              MOV      r6,r1
;;;516      uint32_t i = 0;
0006ce  2400              MOVS     r4,#0
;;;517      WDT_Feed();
0006d0  f7fffffe          BL       WDT_Feed
;;;518     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
0006d4  2240              MOVS     r2,#0x40
0006d6  495a              LDR      r1,|L1.2112|
0006d8  f44f4010          MOV      r0,#0x9000
0006dc  f7fffffe          BL       read_data32
;;;519    
;;;520    	memcpy((CPU_INT08U *)&WriteBuf[0]+CALI_FLOW1_PARA_OFFSET,buf,len);
0006e0  4632              MOV      r2,r6
0006e2  4629              MOV      r1,r5
0006e4  4856              LDR      r0,|L1.2112|
0006e6  3040              ADDS     r0,r0,#0x40
0006e8  f7fffffe          BL       __aeabi_memcpy
;;;521    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
0006ec  4a56              LDR      r2,|L1.2120|
0006ee  2109              MOVS     r1,#9
0006f0  4608              MOV      r0,r1
0006f2  f7fffffe          BL       prepare_sector
;;;522    
;;;523       WDT_Feed();            /* feed watchdog */
0006f6  f7fffffe          BL       WDT_Feed
;;;524       erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
0006fa  4a53              LDR      r2,|L1.2120|
0006fc  2109              MOVS     r1,#9
0006fe  4608              MOV      r0,r1
000700  f7fffffe          BL       erase_sector
;;;525       WDT_Feed();            /* feed watchdog */
000704  f7fffffe          BL       WDT_Feed
;;;526    
;;;527        prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000708  4a4f              LDR      r2,|L1.2120|
00070a  2109              MOVS     r1,#9
00070c  4608              MOV      r0,r1
00070e  f7fffffe          BL       prepare_sector
;;;528        write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
000712  f44f7380          MOV      r3,#0x100
000716  4a4a              LDR      r2,|L1.2112|
000718  f44f4110          MOV      r1,#0x9000
00071c  484a              LDR      r0,|L1.2120|
00071e  f7fffffe          BL       write_data
;;;529        WDT_Feed(); 
000722  f7fffffe          BL       WDT_Feed
;;;530        read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
000726  2240              MOVS     r2,#0x40
000728  4945              LDR      r1,|L1.2112|
00072a  f44f4010          MOV      r0,#0x9000
00072e  f7fffffe          BL       read_data32
;;;531        for( i = 0; i < len; i++ ) {
000732  bf00              NOP      
000734  e009              B        |L1.1866|
                  |L1.1846|
;;;532            if( buf[i] != *( ( uint8_t * )WriteBuf + i +CALI_FLOW1_PARA_OFFSET ) ) return false;
000736  5d28              LDRB     r0,[r5,r4]
000738  4941              LDR      r1,|L1.2112|
00073a  4421              ADD      r1,r1,r4
00073c  f8911040          LDRB     r1,[r1,#0x40]
000740  4288              CMP      r0,r1
000742  d001              BEQ      |L1.1864|
000744  2000              MOVS     r0,#0
                  |L1.1862|
;;;533        }
;;;534        return true;
;;;535    }
000746  bd70              POP      {r4-r6,pc}
                  |L1.1864|
000748  1c64              ADDS     r4,r4,#1              ;531
                  |L1.1866|
00074a  42b4              CMP      r4,r6                 ;531
00074c  d3f3              BCC      |L1.1846|
00074e  2001              MOVS     r0,#1                 ;534
000750  e7f9              B        |L1.1862|
;;;536    
                          ENDP

                  cali_flow_para2_write_flash PROC
;;;537    bool cali_flow_para2_write_flash( uint8_t *buf , uint32_t len )
000752  b570              PUSH     {r4-r6,lr}
;;;538    {
000754  4605              MOV      r5,r0
000756  460e              MOV      r6,r1
;;;539      uint32_t i = 0;
000758  2400              MOVS     r4,#0
;;;540      WDT_Feed();
00075a  f7fffffe          BL       WDT_Feed
;;;541     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
00075e  2240              MOVS     r2,#0x40
000760  4937              LDR      r1,|L1.2112|
000762  f44f4010          MOV      r0,#0x9000
000766  f7fffffe          BL       read_data32
;;;542    
;;;543    	memcpy((CPU_INT08U *)&WriteBuf[0]+CALI_FLOW2_PARA_OFFSET,buf,len);
00076a  4632              MOV      r2,r6
00076c  4629              MOV      r1,r5
00076e  4834              LDR      r0,|L1.2112|
000770  3080              ADDS     r0,r0,#0x80
000772  f7fffffe          BL       __aeabi_memcpy
;;;544    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000776  4a34              LDR      r2,|L1.2120|
000778  2109              MOVS     r1,#9
00077a  4608              MOV      r0,r1
00077c  f7fffffe          BL       prepare_sector
;;;545    
;;;546       WDT_Feed();            /* feed watchdog */
000780  f7fffffe          BL       WDT_Feed
;;;547       erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
000784  4a30              LDR      r2,|L1.2120|
000786  2109              MOVS     r1,#9
000788  4608              MOV      r0,r1
00078a  f7fffffe          BL       erase_sector
;;;548       WDT_Feed();            /* feed watchdog */
00078e  f7fffffe          BL       WDT_Feed
;;;549    
;;;550        prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000792  4a2d              LDR      r2,|L1.2120|
000794  2109              MOVS     r1,#9
000796  4608              MOV      r0,r1
000798  f7fffffe          BL       prepare_sector
;;;551        write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
00079c  f44f7380          MOV      r3,#0x100
0007a0  4a27              LDR      r2,|L1.2112|
0007a2  f44f4110          MOV      r1,#0x9000
0007a6  4828              LDR      r0,|L1.2120|
0007a8  f7fffffe          BL       write_data
;;;552        WDT_Feed(); 
0007ac  f7fffffe          BL       WDT_Feed
;;;553        read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
0007b0  2240              MOVS     r2,#0x40
0007b2  4923              LDR      r1,|L1.2112|
0007b4  f44f4010          MOV      r0,#0x9000
0007b8  f7fffffe          BL       read_data32
;;;554        for( i = 0; i < len; i++ ) {
0007bc  bf00              NOP      
0007be  e009              B        |L1.2004|
                  |L1.1984|
;;;555            if( buf[i] != *( ( uint8_t * )WriteBuf + i +CALI_FLOW2_PARA_OFFSET ) ) return false;
0007c0  5d28              LDRB     r0,[r5,r4]
0007c2  491f              LDR      r1,|L1.2112|
0007c4  4421              ADD      r1,r1,r4
0007c6  f8911080          LDRB     r1,[r1,#0x80]
0007ca  4288              CMP      r0,r1
0007cc  d001              BEQ      |L1.2002|
0007ce  2000              MOVS     r0,#0
                  |L1.2000|
;;;556        }
;;;557        return true;
;;;558    }
0007d0  bd70              POP      {r4-r6,pc}
                  |L1.2002|
0007d2  1c64              ADDS     r4,r4,#1              ;554
                  |L1.2004|
0007d4  42b4              CMP      r4,r6                 ;554
0007d6  d3f3              BCC      |L1.1984|
0007d8  2001              MOVS     r0,#1                 ;557
0007da  e7f9              B        |L1.2000|
;;;559    bool residual_volume_para_write_flash( uint8_t *buf , uint32_t len )
                          ENDP

                  residual_volume_para_write_flash PROC
0007dc  b570              PUSH     {r4-r6,lr}
;;;560    {
0007de  4605              MOV      r5,r0
0007e0  460e              MOV      r6,r1
;;;561      uint32_t i = 0;
0007e2  2400              MOVS     r4,#0
;;;562      WDT_Feed();
0007e4  f7fffffe          BL       WDT_Feed
;;;563     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
0007e8  2240              MOVS     r2,#0x40
0007ea  4915              LDR      r1,|L1.2112|
0007ec  f44f4010          MOV      r0,#0x9000
0007f0  f7fffffe          BL       read_data32
;;;564    
;;;565    	memcpy((CPU_INT08U *)&WriteBuf[0]+RESIDUAL_VOLUME_PARA_OFFSET,buf,len);
0007f4  4632              MOV      r2,r6
0007f6  4629              MOV      r1,r5
0007f8  4811              LDR      r0,|L1.2112|
0007fa  30a0              ADDS     r0,r0,#0xa0
0007fc  f7fffffe          BL       __aeabi_memcpy
;;;566    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
000800  4a11              LDR      r2,|L1.2120|
000802  2109              MOVS     r1,#9
000804  4608              MOV      r0,r1
000806  f7fffffe          BL       prepare_sector
;;;567    
;;;568      WDT_Feed();            /* feed watchdog */
00080a  f7fffffe          BL       WDT_Feed
;;;569      erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
00080e  4a0e              LDR      r2,|L1.2120|
000810  2109              MOVS     r1,#9
000812  4608              MOV      r0,r1
000814  f7fffffe          BL       erase_sector
;;;570      WDT_Feed();            /* feed watchdog */
000818  f7fffffe          BL       WDT_Feed
;;;571    
;;;572      prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
00081c  4a0a              LDR      r2,|L1.2120|
00081e  2109              MOVS     r1,#9
000820  4608              MOV      r0,r1
000822  f7fffffe          BL       prepare_sector
;;;573      write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
000826  f44f7380          MOV      r3,#0x100
00082a  4a05              LDR      r2,|L1.2112|
00082c  f44f4110          MOV      r1,#0x9000
000830  4805              LDR      r0,|L1.2120|
000832  f7fffffe          BL       write_data
;;;574      WDT_Feed(); 
000836  e00f              B        |L1.2136|
                  |L1.2104|
                          DCD      cclk
                  |L1.2108|
                          DCD      result_table
                  |L1.2112|
                          DCD      WriteBuf
                  |L1.2116|
                          DCD      0x77557755
                  |L1.2120|
                          DCD      0x000186a0
                  |L1.2124|
                          DCD      lader_version
                  |L1.2128|
                          DCD      lader_n_version
                  |L1.2132|
                          DCD      0x10007f70
                  |L1.2136|
000858  f7fffffe          BL       WDT_Feed
;;;575      read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
00085c  2240              MOVS     r2,#0x40
00085e  494e              LDR      r1,|L1.2456|
000860  f44f4010          MOV      r0,#0x9000
000864  f7fffffe          BL       read_data32
;;;576      for( i = 0; i < len; i++ ) {
000868  bf00              NOP      
00086a  e009              B        |L1.2176|
                  |L1.2156|
;;;577            if( buf[i] != *( ( uint8_t * )WriteBuf + i +RESIDUAL_VOLUME_PARA_OFFSET ) ) return false;
00086c  5d28              LDRB     r0,[r5,r4]
00086e  494a              LDR      r1,|L1.2456|
000870  4421              ADD      r1,r1,r4
000872  f89110a0          LDRB     r1,[r1,#0xa0]
000876  4288              CMP      r0,r1
000878  d001              BEQ      |L1.2174|
00087a  2000              MOVS     r0,#0
                  |L1.2172|
;;;578       }
;;;579      return true;
;;;580    }
00087c  bd70              POP      {r4-r6,pc}
                  |L1.2174|
00087e  1c64              ADDS     r4,r4,#1              ;576
                  |L1.2176|
000880  42b4              CMP      r4,r6                 ;576
000882  d3f3              BCC      |L1.2156|
000884  2001              MOVS     r0,#1                 ;579
000886  e7f9              B        |L1.2172|
;;;581    
                          ENDP

                  flowmeter_para_write_flash PROC
;;;582    bool flowmeter_para_write_flash( uint8_t *buf , uint32_t len )
000888  b570              PUSH     {r4-r6,lr}
;;;583    {
00088a  4605              MOV      r5,r0
00088c  460e              MOV      r6,r1
;;;584      uint32_t i = 0;
00088e  2400              MOVS     r4,#0
;;;585      WDT_Feed();
000890  f7fffffe          BL       WDT_Feed
;;;586     	read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);              /* 64*4 */
000894  2240              MOVS     r2,#0x40
000896  4940              LDR      r1,|L1.2456|
000898  f44f4010          MOV      r0,#0x9000
00089c  f7fffffe          BL       read_data32
;;;587    
;;;588    	memcpy((CPU_INT08U *)&WriteBuf[0]+FLOWMETER_PARA_OFFSET,buf,len);
0008a0  4632              MOV      r2,r6
0008a2  4629              MOV      r1,r5
0008a4  483c              LDR      r0,|L1.2456|
0008a6  30c0              ADDS     r0,r0,#0xc0
0008a8  f7fffffe          BL       __aeabi_memcpy
;;;589    	prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
0008ac  4a3b              LDR      r2,|L1.2460|
0008ae  2109              MOVS     r1,#9
0008b0  4608              MOV      r0,r1
0008b2  f7fffffe          BL       prepare_sector
;;;590    
;;;591      WDT_Feed();            /* feed watchdog */
0008b6  f7fffffe          BL       WDT_Feed
;;;592      erase_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);	    //erase sector for write
0008ba  4a38              LDR      r2,|L1.2460|
0008bc  2109              MOVS     r1,#9
0008be  4608              MOV      r0,r1
0008c0  f7fffffe          BL       erase_sector
;;;593      WDT_Feed();            /* feed watchdog */
0008c4  f7fffffe          BL       WDT_Feed
;;;594    
;;;595      prepare_sector(HARDWARE_ID_SECTOR,HARDWARE_ID_SECTOR,CCLK);      //select sector
0008c8  4a34              LDR      r2,|L1.2460|
0008ca  2109              MOVS     r1,#9
0008cc  4608              MOV      r0,r1
0008ce  f7fffffe          BL       prepare_sector
;;;596      write_data(CCLK,HARDWARE_ID_ADDR,(CPU_INT32U*)&WriteBuf[0],256); //write length must be 256,512,1024,4096
0008d2  f44f7380          MOV      r3,#0x100
0008d6  4a30              LDR      r2,|L1.2456|
0008d8  f44f4110          MOV      r1,#0x9000
0008dc  482f              LDR      r0,|L1.2460|
0008de  f7fffffe          BL       write_data
;;;597      WDT_Feed(); 
0008e2  f7fffffe          BL       WDT_Feed
;;;598      read_data32(HARDWARE_ID_ADDR,&WriteBuf[0],64);
0008e6  2240              MOVS     r2,#0x40
0008e8  492b              LDR      r1,|L1.2456|
0008ea  f44f4010          MOV      r0,#0x9000
0008ee  f7fffffe          BL       read_data32
;;;599      for( i = 0; i < len; i++ ) {
0008f2  bf00              NOP      
0008f4  e009              B        |L1.2314|
                  |L1.2294|
;;;600            if( buf[i] != *( ( uint8_t * )WriteBuf + i +FLOWMETER_PARA_OFFSET ) ) return false;
0008f6  5d28              LDRB     r0,[r5,r4]
0008f8  4927              LDR      r1,|L1.2456|
0008fa  4421              ADD      r1,r1,r4
0008fc  f89110c0          LDRB     r1,[r1,#0xc0]
000900  4288              CMP      r0,r1
000902  d001              BEQ      |L1.2312|
000904  2000              MOVS     r0,#0
                  |L1.2310|
;;;601       }
;;;602      return true;
;;;603    }
000906  bd70              POP      {r4-r6,pc}
                  |L1.2312|
000908  1c64              ADDS     r4,r4,#1              ;599
                  |L1.2314|
00090a  42b4              CMP      r4,r6                 ;599
00090c  d3f3              BCC      |L1.2294|
00090e  2001              MOVS     r0,#1                 ;602
000910  e7f9              B        |L1.2310|
;;;604    
                          ENDP

                  cali_pressure1_para_read_flash PROC
;;;605    
;;;606    void cali_pressure1_para_read_flash(uint8_t *buf, uint32_t len)
000912  b530              PUSH     {r4,r5,lr}
;;;607    {
000914  4604              MOV      r4,r0
000916  460d              MOV      r5,r1
;;;608        read_flash_data_offset(HARDWARE_ID_ADDR,CALI_PRESSURE1_PARA_OFFSET,buf,len);
000918  462b              MOV      r3,r5
00091a  4622              MOV      r2,r4
00091c  2120              MOVS     r1,#0x20
00091e  f44f4010          MOV      r0,#0x9000
000922  f7fffffe          BL       read_flash_data_offset
;;;609    }
000926  bd30              POP      {r4,r5,pc}
;;;610    
                          ENDP

                  cali_pressure2_para_read_flash PROC
;;;611    void cali_pressure2_para_read_flash(uint8_t *buf, uint32_t len)
000928  b530              PUSH     {r4,r5,lr}
;;;612    {
00092a  4604              MOV      r4,r0
00092c  460d              MOV      r5,r1
;;;613        read_flash_data_offset(HARDWARE_ID_ADDR,CALI_PRESSURE2_PARA_OFFSET,buf,len);
00092e  462b              MOV      r3,r5
000930  4622              MOV      r2,r4
000932  2160              MOVS     r1,#0x60
000934  f44f4010          MOV      r0,#0x9000
000938  f7fffffe          BL       read_flash_data_offset
;;;614    }
00093c  bd30              POP      {r4,r5,pc}
;;;615    
                          ENDP

                  cali_flow_para1_read_flash PROC
;;;616    void cali_flow_para1_read_flash(uint8_t *buf, uint32_t len)
00093e  b530              PUSH     {r4,r5,lr}
;;;617    {
000940  4604              MOV      r4,r0
000942  460d              MOV      r5,r1
;;;618        read_flash_data_offset(HARDWARE_ID_ADDR,CALI_FLOW1_PARA_OFFSET,buf,len);
000944  462b              MOV      r3,r5
000946  4622              MOV      r2,r4
000948  2140              MOVS     r1,#0x40
00094a  f44f4010          MOV      r0,#0x9000
00094e  f7fffffe          BL       read_flash_data_offset
;;;619    }
000952  bd30              POP      {r4,r5,pc}
;;;620    void cali_flow_para2_read_flash(uint8_t *buf, uint32_t len)
                          ENDP

                  cali_flow_para2_read_flash PROC
000954  b530              PUSH     {r4,r5,lr}
;;;621    {
000956  4604              MOV      r4,r0
000958  460d              MOV      r5,r1
;;;622        read_flash_data_offset(HARDWARE_ID_ADDR,CALI_FLOW2_PARA_OFFSET,buf,len);
00095a  462b              MOV      r3,r5
00095c  4622              MOV      r2,r4
00095e  2180              MOVS     r1,#0x80
000960  f44f4010          MOV      r0,#0x9000
000964  f7fffffe          BL       read_flash_data_offset
;;;623    }
000968  bd30              POP      {r4,r5,pc}
;;;624    
                          ENDP

                  cali_volume_para_read_flash PROC
;;;625    void cali_volume_para_read_flash(uint8_t *buf, uint32_t len)
00096a  b530              PUSH     {r4,r5,lr}
;;;626    {
00096c  4604              MOV      r4,r0
00096e  460d              MOV      r5,r1
;;;627        read_flash_data_offset(HARDWARE_ID_ADDR,RESIDUAL_VOLUME_PARA_OFFSET,buf,len);
000970  462b              MOV      r3,r5
000972  4622              MOV      r2,r4
000974  21a0              MOVS     r1,#0xa0
000976  f44f4010          MOV      r0,#0x9000
00097a  f7fffffe          BL       read_flash_data_offset
;;;628    }
00097e  bd30              POP      {r4,r5,pc}
;;;629    
                          ENDP

                  flowmeter_para_read_flash PROC
;;;630    void flowmeter_para_read_flash(uint8_t *buf, uint32_t len)
000980  b530              PUSH     {r4,r5,lr}
;;;631    {
000982  4604              MOV      r4,r0
000984  460d              MOV      r5,r1
;;;632        read_flash_data_offset(HARDWARE_ID_ADDR,FLOWMETER_PARA_OFFSET,buf,len);
000986  462b              MOV      r3,r5
000988  4622              MOV      r2,r4
00098a  21c0              MOVS     r1,#0xc0
00098c  f44f4010          MOV      r0,#0x9000
000990  f7fffffe          BL       read_flash_data_offset
;;;633    }
000994  bd30              POP      {r4,r5,pc}
                          ENDP

000996  0000              DCW      0x0000
                  |L1.2456|
                          DCD      WriteBuf
                  |L1.2460|
                          DCD      0x000186a0

                          AREA ||.ARM.__AT_0x10007F70||, DATA, NOINIT, ALIGN=2

                  lader_version
                          %        4

                          AREA ||.ARM.__AT_0x10007F74||, DATA, NOINIT, ALIGN=2

                  lader_n_version
                          %        4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param_table
                          %        20
                  result_table
                          %        20
                  flash_buf
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  sector_start_map
                          DCD      0x00000000
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00003000
                          DCD      0x00004000
                          DCD      0x00005000
                          DCD      0x00006000
                          DCD      0x00007000
                          DCD      0x00008000
                          DCD      0x00009000
                          DCD      0x0000a000
                          DCD      0x0000b000
                          DCD      0x0000c000
                          DCD      0x0000d000
                          DCD      0x0000e000
                          DCD      0x0000f000
                          DCD      0x00010000
                          DCD      0x00018000
                          DCD      0x00020000
                          DCD      0x00028000
                          DCD      0x00030000
                          DCD      0x00038000
                          DCD      0x00040000
                          DCD      0x00048000
                          DCD      0x00050000
                          DCD      0x00058000
                          DCD      0x00060000
                          DCD      0x00068000
                          DCD      0x00070000
                          DCD      0x00078000
                  sector_end_map
                          DCD      0x00000fff
                          DCD      0x00001fff
                          DCD      0x00002fff
                          DCD      0x00003fff
                          DCD      0x00004fff
                          DCD      0x00005fff
                          DCD      0x00006fff
                          DCD      0x00007fff
                          DCD      0x00008fff
                          DCD      0x00009fff
                          DCD      0x0000afff
                          DCD      0x0000bfff
                          DCD      0x0000cfff
                          DCD      0x0000dfff
                          DCD      0x0000efff
                          DCD      0x0000ffff
                          DCD      0x00017fff
                          DCD      0x0001ffff
                          DCD      0x00027fff
                          DCD      0x0002ffff
                          DCD      0x00037fff
                          DCD      0x0003ffff
                          DCD      0x00047fff
                          DCD      0x0004ffff
                          DCD      0x00057fff
                          DCD      0x0005ffff
                          DCD      0x00067fff
                          DCD      0x0006ffff
                          DCD      0x00077fff
                          DCD      0x0007ffff

                          AREA ||.data||, DATA, ALIGN=2

                  cclk
                          DCD      0x000186a0
                  flash_address
                          DCD      0x00000000
                  byte_ctr
                          DCD      0x00000000

                          AREA ETHERNET_RAM, DATA, ALIGN=3

                  WriteBuf
                          %        256

;*** Start embedded assembler ***

#line 1 "iap\\sbl_iap.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |boot_jump|
#line 208
|boot_jump| PROC
#line 208

 LDR SP, [R0] 
 LDR PC, [R0, #4] 
	ENDP

;*** End   embedded assembler ***
