; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\aes.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\aes.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\cstartup -I.\drivers\uart -I.\app\cfg -I.\iap -I.\drivers -I.\usb -I.\drivers\adc -I.\drivers\gpio -I.\drivers -I.\RTE\_lpc17xx_can_loader_debug -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DLPC175x_6x -D__DEBUG_UART2_PRINTF__ -D__UART0__ -D__UART1__ -D__UART2__ -D__UART3__ -D__UART2_ENABLE__ -D__UART3_ENABLE__ -D__UART0_ENABLE__ -D__UART1_ENABLE__ --omf_browse=.\output\aes.crf app\aes\aes.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CalcPowLog PROC
;;;66     
;;;67     void CalcPowLog(unsigned char *powTbl, unsigned char *logTbl)
000000  b510              PUSH     {r4,lr}
;;;68     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;69       	unsigned char i = 0;
000006  2100              MOVS     r1,#0
;;;70       	unsigned char t = 1;
000008  2001              MOVS     r0,#1
;;;71     
;;;72       	do {
00000a  bf00              NOP      
                  |L1.12|
;;;73         	// Use 0x03 as root for exponentiation and logarithms.
;;;74         	powTbl[i] = t;
00000c  5450              STRB     r0,[r2,r1]
;;;75         	logTbl[t] = i;
00000e  5419              STRB     r1,[r3,r0]
;;;76         	i++;
000010  1c4c              ADDS     r4,r1,#1
000012  b2e1              UXTB     r1,r4
;;;77     
;;;78         	// Muliply t by 3 in GF(2^8).
;;;79         	t ^= (t << 1) ^ (t & 0x80 ? BPOLY : 0);
000014  f0000480          AND      r4,r0,#0x80
000018  b10c              CBZ      r4,|L1.30|
00001a  241b              MOVS     r4,#0x1b
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  2400              MOVS     r4,#0
                  |L1.32|
000020  ea840440          EOR      r4,r4,r0,LSL #1
000024  4044              EORS     r4,r4,r0
000026  b2e0              UXTB     r0,r4
;;;80       	}while( t != 1 ); // Cyclic properties ensure that i < 255.
000028  2801              CMP      r0,#1
00002a  d1ef              BNE      |L1.12|
;;;81     
;;;82       	powTbl[255] = powTbl[0]; // 255 = '-0', 254 = -1, etc.
00002c  7814              LDRB     r4,[r2,#0]
00002e  f88240ff          STRB     r4,[r2,#0xff]
;;;83     }
000032  bd10              POP      {r4,pc}
;;;84     
                          ENDP

                  CalcSBox PROC
;;;85     //获得sBOX表
;;;86     void CalcSBox( unsigned char * sBox )
000034  b570              PUSH     {r4-r6,lr}
;;;87     {
000036  4602              MOV      r2,r0
;;;88       	unsigned char i, rot;
;;;89       	unsigned char temp;
;;;90       	unsigned char result;
;;;91     
;;;92       	// Fill all entries of sBox[].
;;;93       	i = 0;
000038  2000              MOVS     r0,#0
;;;94       	do {
00003a  bf00              NOP      
                  |L1.60|
;;;95         	//Inverse in GF(2^8).
;;;96         	if( i > 0 ) 
00003c  2800              CMP      r0,#0
00003e  dd08              BLE      |L1.82|
;;;97         	{
;;;98           		temp = powTbl[ 255 - logTbl[i] ];
000040  4df7              LDR      r5,|L1.1056|
000042  682d              LDR      r5,[r5,#0]  ; logTbl
000044  5c2d              LDRB     r5,[r5,r0]
000046  f1c505ff          RSB      r5,r5,#0xff
00004a  4ef6              LDR      r6,|L1.1060|
00004c  6836              LDR      r6,[r6,#0]  ; powTbl
00004e  5d71              LDRB     r1,[r6,r5]
000050  e000              B        |L1.84|
                  |L1.82|
;;;99         	} 
;;;100        	else 
;;;101        	{
;;;102          		temp = 0;
000052  2100              MOVS     r1,#0
                  |L1.84|
;;;103        	}
;;;104    
;;;105        	// Affine transformation in GF(2).
;;;106        	result = temp ^ 0x63; // Start with adding a vector in GF(2).
000054  f0810463          EOR      r4,r1,#0x63
;;;107        	for( rot = 4; rot > 0; rot-- )
000058  2304              MOVS     r3,#4
00005a  e006              B        |L1.106|
                  |L1.92|
;;;108        	{
;;;109          		// Rotate left.
;;;110          		temp = (temp<<1) | (temp>>7);
00005c  004d              LSLS     r5,r1,#1
00005e  ea4515e1          ORR      r5,r5,r1,ASR #7
000062  b2e9              UXTB     r1,r5
;;;111    
;;;112          		// Add rotated byte in GF(2).
;;;113          		result ^= temp;
000064  404c              EORS     r4,r4,r1
000066  1e5d              SUBS     r5,r3,#1              ;107
000068  b2eb              UXTB     r3,r5                 ;107
                  |L1.106|
00006a  2b00              CMP      r3,#0                 ;107
00006c  dcf6              BGT      |L1.92|
;;;114        	}
;;;115    
;;;116        	// Put result in table.
;;;117        	sBox[i] = result;
00006e  5414              STRB     r4,[r2,r0]
;;;118      	} while( ++i != 0 );
000070  1c45              ADDS     r5,r0,#1
000072  b2ed              UXTB     r5,r5
000074  1e28              SUBS     r0,r5,#0
000076  d1e1              BNE      |L1.60|
;;;119    }
000078  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP

                  CalcSBoxInv PROC
;;;121    void CalcSBoxInv( unsigned char * sBox, unsigned char * sBoxInv )
00007a  b510              PUSH     {r4,lr}
;;;122    {
00007c  4602              MOV      r2,r0
00007e  460b              MOV      r3,r1
;;;123      	unsigned char i = 0;
000080  2000              MOVS     r0,#0
;;;124      	unsigned char j = 0;
000082  2100              MOVS     r1,#0
;;;125    
;;;126      	// Iterate through all elements in sBoxInv using  i.
;;;127      	do {
000084  bf00              NOP      
                  |L1.134|
;;;128    	// Search through sBox using j.
;;;129        	do {
000086  bf00              NOP      
                  |L1.136|
;;;130          		// Check if current j is the inverse of current i.
;;;131          		if( sBox[ j ] == i )
000088  5c54              LDRB     r4,[r2,r1]
00008a  4284              CMP      r4,r0
00008c  d101              BNE      |L1.146|
;;;132          		{
;;;133            		// If so, set sBoxInc and indicate search finished.
;;;134            		sBoxInv[ i ] = j;
00008e  5419              STRB     r1,[r3,r0]
;;;135            		j = 255;
000090  21ff              MOVS     r1,#0xff
                  |L1.146|
;;;136          		}
;;;137        	} while( ++j != 0 );
000092  1c4c              ADDS     r4,r1,#1
000094  b2e4              UXTB     r4,r4
000096  1e21              SUBS     r1,r4,#0
000098  d1f6              BNE      |L1.136|
;;;138      	} while( ++i != 0 );
00009a  1c44              ADDS     r4,r0,#1
00009c  b2e4              UXTB     r4,r4
00009e  1e20              SUBS     r0,r4,#0
0000a0  d1f1              BNE      |L1.134|
;;;139    }
0000a2  bd10              POP      {r4,pc}
;;;140    
                          ENDP

                  CycleLeft PROC
;;;142    
;;;143    void CycleLeft( unsigned char * row )
0000a4  7801              LDRB     r1,[r0,#0]
;;;144    {
;;;145      	// Cycle 4 bytes in an array left once.
;;;146      	unsigned char temp = row[0];
;;;147    
;;;148      	row[0] = row[1];
0000a6  7842              LDRB     r2,[r0,#1]
0000a8  7002              STRB     r2,[r0,#0]
;;;149      	row[1] = row[2];
0000aa  7882              LDRB     r2,[r0,#2]
0000ac  7042              STRB     r2,[r0,#1]
;;;150      	row[2] = row[3];
0000ae  78c2              LDRB     r2,[r0,#3]
0000b0  7082              STRB     r2,[r0,#2]
;;;151      	row[3] = temp;
0000b2  70c1              STRB     r1,[r0,#3]
;;;152    }
0000b4  4770              BX       lr
;;;153    
                          ENDP

                  CalcCols PROC
;;;154    
;;;155    void CalcCols(unsigned char *col)
0000b6  2104              MOVS     r1,#4
;;;156    {
;;;157      	unsigned char i;
;;;158    
;;;159      	for(i = 4; i > 0; i--)
0000b8  e00d              B        |L1.214|
                  |L1.186|
;;;160      	{
;;;161        	*col = (*col << 1) ^ (*col & 0x80 ? BPOLY : 0);
0000ba  7802              LDRB     r2,[r0,#0]
0000bc  f0020280          AND      r2,r2,#0x80
0000c0  b10a              CBZ      r2,|L1.198|
0000c2  221b              MOVS     r2,#0x1b
0000c4  e000              B        |L1.200|
                  |L1.198|
0000c6  2200              MOVS     r2,#0
                  |L1.200|
0000c8  7803              LDRB     r3,[r0,#0]
0000ca  ea820243          EOR      r2,r2,r3,LSL #1
0000ce  7002              STRB     r2,[r0,#0]
;;;162        	col++;
0000d0  1c40              ADDS     r0,r0,#1
0000d2  1e4a              SUBS     r2,r1,#1              ;159
0000d4  b2d1              UXTB     r1,r2                 ;159
                  |L1.214|
0000d6  2900              CMP      r1,#0                 ;159
0000d8  dcef              BGT      |L1.186|
;;;163      	}
;;;164    }
0000da  4770              BX       lr
;;;165    
                          ENDP

                  InvMixColumn PROC
;;;166    void InvMixColumn( unsigned char * column )
0000dc  b518              PUSH     {r3,r4,lr}
;;;167    {
0000de  4604              MOV      r4,r0
;;;168      	unsigned char r[4];
;;;169    
;;;170      	r[0] = column[1] ^ column[2] ^ column[3];
0000e0  7860              LDRB     r0,[r4,#1]
0000e2  78a1              LDRB     r1,[r4,#2]
0000e4  4048              EORS     r0,r0,r1
0000e6  78e1              LDRB     r1,[r4,#3]
0000e8  4048              EORS     r0,r0,r1
0000ea  f88d0000          STRB     r0,[sp,#0]
;;;171      	r[1] = column[0] ^ column[2] ^ column[3];
0000ee  7820              LDRB     r0,[r4,#0]
0000f0  78a1              LDRB     r1,[r4,#2]
0000f2  4048              EORS     r0,r0,r1
0000f4  78e1              LDRB     r1,[r4,#3]
0000f6  4048              EORS     r0,r0,r1
0000f8  f88d0001          STRB     r0,[sp,#1]
;;;172      	r[2] = column[0] ^ column[1] ^ column[3];
0000fc  7820              LDRB     r0,[r4,#0]
0000fe  7861              LDRB     r1,[r4,#1]
000100  4048              EORS     r0,r0,r1
000102  78e1              LDRB     r1,[r4,#3]
000104  4048              EORS     r0,r0,r1
000106  f88d0002          STRB     r0,[sp,#2]
;;;173      	r[3] = column[0] ^ column[1] ^ column[2];
00010a  7820              LDRB     r0,[r4,#0]
00010c  7861              LDRB     r1,[r4,#1]
00010e  4048              EORS     r0,r0,r1
000110  78a1              LDRB     r1,[r4,#2]
000112  4048              EORS     r0,r0,r1
000114  f88d0003          STRB     r0,[sp,#3]
;;;174    
;;;175      	/*column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
;;;176      	column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
;;;177      	column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
;;;178      	column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);*/
;;;179      	CalcCols(column);
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       CalcCols
;;;180    
;;;181      	r[0] ^= column[0] ^ column[1];
00011e  7820              LDRB     r0,[r4,#0]
000120  7861              LDRB     r1,[r4,#1]
000122  4048              EORS     r0,r0,r1
000124  f89d1000          LDRB     r1,[sp,#0]
000128  4048              EORS     r0,r0,r1
00012a  f88d0000          STRB     r0,[sp,#0]
;;;182      	r[1] ^= column[1] ^ column[2];
00012e  7860              LDRB     r0,[r4,#1]
000130  78a1              LDRB     r1,[r4,#2]
000132  4048              EORS     r0,r0,r1
000134  f89d1001          LDRB     r1,[sp,#1]
000138  4048              EORS     r0,r0,r1
00013a  f88d0001          STRB     r0,[sp,#1]
;;;183      	r[2] ^= column[2] ^ column[3];
00013e  78a0              LDRB     r0,[r4,#2]
000140  78e1              LDRB     r1,[r4,#3]
000142  4048              EORS     r0,r0,r1
000144  f89d1002          LDRB     r1,[sp,#2]
000148  4048              EORS     r0,r0,r1
00014a  f88d0002          STRB     r0,[sp,#2]
;;;184      	r[3] ^= column[0] ^ column[3];
00014e  7820              LDRB     r0,[r4,#0]
000150  78e1              LDRB     r1,[r4,#3]
000152  4048              EORS     r0,r0,r1
000154  f89d1003          LDRB     r1,[sp,#3]
000158  4048              EORS     r0,r0,r1
00015a  f88d0003          STRB     r0,[sp,#3]
;;;185    
;;;186      	/*column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
;;;187      	column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
;;;188      	column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
;;;189      	column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);*/
;;;190      	CalcCols(column);
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       CalcCols
;;;191    
;;;192      	r[0] ^= column[0] ^ column[2];
000164  7820              LDRB     r0,[r4,#0]
000166  78a1              LDRB     r1,[r4,#2]
000168  4048              EORS     r0,r0,r1
00016a  f89d1000          LDRB     r1,[sp,#0]
00016e  4048              EORS     r0,r0,r1
000170  f88d0000          STRB     r0,[sp,#0]
;;;193      	r[1] ^= column[1] ^ column[3];
000174  7860              LDRB     r0,[r4,#1]
000176  78e1              LDRB     r1,[r4,#3]
000178  4048              EORS     r0,r0,r1
00017a  f89d1001          LDRB     r1,[sp,#1]
00017e  4048              EORS     r0,r0,r1
000180  f88d0001          STRB     r0,[sp,#1]
;;;194      	r[2] ^= column[0] ^ column[2];
000184  7820              LDRB     r0,[r4,#0]
000186  78a1              LDRB     r1,[r4,#2]
000188  4048              EORS     r0,r0,r1
00018a  f89d1002          LDRB     r1,[sp,#2]
00018e  4048              EORS     r0,r0,r1
000190  f88d0002          STRB     r0,[sp,#2]
;;;195      	r[3] ^= column[1] ^ column[3];
000194  7860              LDRB     r0,[r4,#1]
000196  78e1              LDRB     r1,[r4,#3]
000198  4048              EORS     r0,r0,r1
00019a  f89d1003          LDRB     r1,[sp,#3]
00019e  4048              EORS     r0,r0,r1
0001a0  f88d0003          STRB     r0,[sp,#3]
;;;196    
;;;197      	/*column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
;;;198      	column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
;;;199      	column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
;;;200      	column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);*/
;;;201      	CalcCols(column);
0001a4  4620              MOV      r0,r4
0001a6  f7fffffe          BL       CalcCols
;;;202    
;;;203      	column[0] ^= column[1] ^ column[2] ^ column[3];
0001aa  7860              LDRB     r0,[r4,#1]
0001ac  78a1              LDRB     r1,[r4,#2]
0001ae  4048              EORS     r0,r0,r1
0001b0  78e1              LDRB     r1,[r4,#3]
0001b2  4048              EORS     r0,r0,r1
0001b4  7821              LDRB     r1,[r4,#0]
0001b6  4048              EORS     r0,r0,r1
0001b8  7020              STRB     r0,[r4,#0]
;;;204      	r[0] ^= column[0];
0001ba  f89d0000          LDRB     r0,[sp,#0]
0001be  7821              LDRB     r1,[r4,#0]
0001c0  4048              EORS     r0,r0,r1
0001c2  f88d0000          STRB     r0,[sp,#0]
;;;205      	r[1] ^= column[0];
0001c6  f89d0001          LDRB     r0,[sp,#1]
0001ca  7821              LDRB     r1,[r4,#0]
0001cc  4048              EORS     r0,r0,r1
0001ce  f88d0001          STRB     r0,[sp,#1]
;;;206      	r[2] ^= column[0];
0001d2  f89d0002          LDRB     r0,[sp,#2]
0001d6  7821              LDRB     r1,[r4,#0]
0001d8  4048              EORS     r0,r0,r1
0001da  f88d0002          STRB     r0,[sp,#2]
;;;207      	r[3] ^= column[0];
0001de  f89d0003          LDRB     r0,[sp,#3]
0001e2  7821              LDRB     r1,[r4,#0]
0001e4  4048              EORS     r0,r0,r1
0001e6  f88d0003          STRB     r0,[sp,#3]
;;;208      
;;;209      	column[0] = r[0];
0001ea  f89d0000          LDRB     r0,[sp,#0]
0001ee  7020              STRB     r0,[r4,#0]
;;;210      	column[1] = r[1];
0001f0  f89d0001          LDRB     r0,[sp,#1]
0001f4  7060              STRB     r0,[r4,#1]
;;;211      	column[2] = r[2];
0001f6  f89d0002          LDRB     r0,[sp,#2]
0001fa  70a0              STRB     r0,[r4,#2]
;;;212      	column[3] = r[3];
0001fc  f89d0003          LDRB     r0,[sp,#3]
000200  70e0              STRB     r0,[r4,#3]
;;;213    
;;;214      	//CopyBytes(column, r, 4);
;;;215    }
000202  bd18              POP      {r3,r4,pc}
;;;216    
                          ENDP

                  SubBytes PROC
;;;217    void SubBytes( unsigned char * bytes, unsigned char count )
000204  bf00              NOP      
                  |L1.518|
;;;218    {
;;;219    	do {
;;;220    	    *bytes = sBox[ *bytes ]; // Substitute every byte in state.
000206  7802              LDRB     r2,[r0,#0]
000208  4b87              LDR      r3,|L1.1064|
00020a  681b              LDR      r3,[r3,#0]  ; sBox
00020c  5c9a              LDRB     r2,[r3,r2]
00020e  7002              STRB     r2,[r0,#0]
;;;221    	    bytes++;
000210  1c40              ADDS     r0,r0,#1
;;;222    	} while( --count );
000212  1e4a              SUBS     r2,r1,#1
000214  b2d2              UXTB     r2,r2
000216  1e11              SUBS     r1,r2,#0
000218  d1f5              BNE      |L1.518|
;;;223    }
00021a  4770              BX       lr
;;;224    
                          ENDP

                  InvSubBytesAndXOR PROC
;;;225    void InvSubBytesAndXOR( unsigned char * bytes, unsigned char * key, unsigned char count )
00021c  b510              PUSH     {r4,lr}
;;;226    {
;;;227    	do {
00021e  bf00              NOP      
                  |L1.544|
;;;228    	    // *bytes = sBoxInv[ *bytes ] ^ *key; // Inverse substitute every byte in state and add key.
;;;229    	    *bytes = block2[ *bytes ] ^ *key; // Use block2 directly. Increases speed.
000220  7803              LDRB     r3,[r0,#0]
000222  4c82              LDR      r4,|L1.1068|
000224  5ce3              LDRB     r3,[r4,r3]
000226  780c              LDRB     r4,[r1,#0]
000228  4063              EORS     r3,r3,r4
00022a  7003              STRB     r3,[r0,#0]
;;;230    	    bytes++;
00022c  1c40              ADDS     r0,r0,#1
;;;231    	    key++;
00022e  1c49              ADDS     r1,r1,#1
;;;232    	} while( --count );
000230  1e53              SUBS     r3,r2,#1
000232  b2db              UXTB     r3,r3
000234  1e1a              SUBS     r2,r3,#0
000236  d1f3              BNE      |L1.544|
;;;233    }
000238  bd10              POP      {r4,pc}
;;;234    
                          ENDP

                  InvShiftRows PROC
;;;235    void InvShiftRows( unsigned char * state )
00023a  7b41              LDRB     r1,[r0,#0xd]
;;;236    {
;;;237      	unsigned char temp;
;;;238    
;;;239      	// Note: State is arranged column by column.
;;;240    
;;;241      	// Cycle second row right one time.
;;;242      	temp = state[ 1 + 3*4 ];
;;;243      	state[ 1 + 3*4 ] = state[ 1 + 2*4 ];
00023c  7a42              LDRB     r2,[r0,#9]
00023e  7342              STRB     r2,[r0,#0xd]
;;;244      	state[ 1 + 2*4 ] = state[ 1 + 1*4 ];
000240  7942              LDRB     r2,[r0,#5]
000242  7242              STRB     r2,[r0,#9]
;;;245      	state[ 1 + 1*4 ] = state[ 1 + 0*4 ];
000244  7842              LDRB     r2,[r0,#1]
000246  7142              STRB     r2,[r0,#5]
;;;246      	state[ 1 + 0*4 ] = temp;
000248  7041              STRB     r1,[r0,#1]
;;;247    
;;;248      	// Cycle third row right two times.
;;;249      	temp = state[ 2 + 0*4 ];
00024a  7881              LDRB     r1,[r0,#2]
;;;250      	state[ 2 + 0*4 ] = state[ 2 + 2*4 ];
00024c  7a82              LDRB     r2,[r0,#0xa]
00024e  7082              STRB     r2,[r0,#2]
;;;251      	state[ 2 + 2*4 ] = temp;
000250  7281              STRB     r1,[r0,#0xa]
;;;252      	temp = state[ 2 + 1*4 ];
000252  7981              LDRB     r1,[r0,#6]
;;;253      	state[ 2 + 1*4 ] = state[ 2 + 3*4 ];
000254  7b82              LDRB     r2,[r0,#0xe]
000256  7182              STRB     r2,[r0,#6]
;;;254      	state[ 2 + 3*4 ] = temp;
000258  7381              STRB     r1,[r0,#0xe]
;;;255    
;;;256      	// Cycle fourth row right three times, ie. left once.
;;;257      	temp = state[ 3 + 0*4 ];
00025a  78c1              LDRB     r1,[r0,#3]
;;;258      	state[ 3 + 0*4 ] = state[ 3 + 1*4 ];
00025c  79c2              LDRB     r2,[r0,#7]
00025e  70c2              STRB     r2,[r0,#3]
;;;259      	state[ 3 + 1*4 ] = state[ 3 + 2*4 ];
000260  7ac2              LDRB     r2,[r0,#0xb]
000262  71c2              STRB     r2,[r0,#7]
;;;260      	state[ 3 + 2*4 ] = state[ 3 + 3*4 ];
000264  7bc2              LDRB     r2,[r0,#0xf]
000266  72c2              STRB     r2,[r0,#0xb]
;;;261      	state[ 3 + 3*4 ] = temp;
000268  73c1              STRB     r1,[r0,#0xf]
;;;262    }
00026a  4770              BX       lr
;;;263    
                          ENDP

                  XORBytes PROC
;;;273    
;;;274    void XORBytes( unsigned char * bytes1, unsigned char * bytes2, unsigned char count )
00026c  b510              PUSH     {r4,lr}
;;;275    {
;;;276    	do {
00026e  bf00              NOP      
                  |L1.624|
;;;277    	    *bytes1 ^= *bytes2; // Add in GF(2), ie. XOR.
000270  7803              LDRB     r3,[r0,#0]
000272  780c              LDRB     r4,[r1,#0]
000274  4063              EORS     r3,r3,r4
000276  7003              STRB     r3,[r0,#0]
;;;278    	    bytes1++;
000278  1c40              ADDS     r0,r0,#1
;;;279    	    bytes2++;
00027a  1c49              ADDS     r1,r1,#1
;;;280    	} while( --count );
00027c  1e53              SUBS     r3,r2,#1
00027e  b2db              UXTB     r3,r3
000280  1e1a              SUBS     r2,r3,#0
000282  d1f5              BNE      |L1.624|
;;;281    }
000284  bd10              POP      {r4,pc}
;;;282    
                          ENDP

                  CopyBytes PROC
;;;283    void CopyBytes( unsigned char * to, unsigned char * from, unsigned char count )
000286  bf00              NOP      
                  |L1.648|
;;;284    {
;;;285    	do {
;;;286    	    *to = *from;
000288  780b              LDRB     r3,[r1,#0]
00028a  7003              STRB     r3,[r0,#0]
;;;287    	    to++;
00028c  1c40              ADDS     r0,r0,#1
;;;288    	    from++;
00028e  1c49              ADDS     r1,r1,#1
;;;289    	} while( --count );
000290  1e53              SUBS     r3,r2,#1
000292  b2db              UXTB     r3,r3
000294  1e1a              SUBS     r2,r3,#0
000296  d1f7              BNE      |L1.648|
;;;290    }
000298  4770              BX       lr
;;;291    
                          ENDP

                  KeyExpansion PROC
;;;292    void KeyExpansion( unsigned char * expandedKey )
00029a  b57c              PUSH     {r2-r6,lr}
;;;293    {
00029c  4604              MOV      r4,r0
;;;294      	unsigned char temp[4];
;;;295      	unsigned char i;
;;;296      	unsigned char Rcon[4] = { 0x01, 0x00, 0x00, 0x00 }; // Round constant.
00029e  a064              ADR      r0,|L1.1072|
0002a0  6800              LDR      r0,[r0,#0]
0002a2  9000              STR      r0,[sp,#0]
;;;297    
;;;298      	const unsigned char * key = kTable;
0002a4  4e63              LDR      r6,|L1.1076|
;;;299    
;;;300      	// Copy key to start of expanded key.
;;;301      	i = KEYLENGTH;
0002a6  2510              MOVS     r5,#0x10
;;;302      	do {
0002a8  bf00              NOP      
                  |L1.682|
;;;303        	*expandedKey = *key;
0002aa  7830              LDRB     r0,[r6,#0]
0002ac  7020              STRB     r0,[r4,#0]
;;;304        	expandedKey++;
0002ae  1c64              ADDS     r4,r4,#1
;;;305        	key++;
0002b0  1c76              ADDS     r6,r6,#1
;;;306      	} while( --i );
0002b2  1e68              SUBS     r0,r5,#1
0002b4  b2c0              UXTB     r0,r0
0002b6  1e05              SUBS     r5,r0,#0
0002b8  d1f7              BNE      |L1.682|
;;;307    
;;;308      	// Prepare last 4 bytes of key in temp.
;;;309      	/*expandedKey -= 4;
;;;310      	temp[0] = *(expandedKey++);
;;;311      	temp[1] = *(expandedKey++);
;;;312      	temp[2] = *(expandedKey++);
;;;313      	temp[3] = *(expandedKey++);*/
;;;314      	CopyBytes(temp, expandedKey-4, 4);
0002ba  1f21              SUBS     r1,r4,#4
0002bc  2204              MOVS     r2,#4
0002be  a801              ADD      r0,sp,#4
0002c0  f7fffffe          BL       CopyBytes
;;;315    
;;;316      	// Expand key.
;;;317      	i = KEYLENGTH;
0002c4  2510              MOVS     r5,#0x10
;;;318      	//j = BLOCKSIZE*(ROUNDS+1) - KEYLENGTH;
;;;319      	while( i < BLOCKSIZE*(ROUNDS+1) ) 
0002c6  e039              B        |L1.828|
                  |L1.712|
;;;320      	{
;;;321        	// Are we at the start of a multiple of the key size?
;;;322        	if( (i % KEYLENGTH) == 0 )
0002c8  17e9              ASRS     r1,r5,#31
0002ca  eb057111          ADD      r1,r5,r1,LSR #28
0002ce  1109              ASRS     r1,r1,#4
0002d0  eba51101          SUB      r1,r5,r1,LSL #4
0002d4  b9d1              CBNZ     r1,|L1.780|
;;;323        	{
;;;324          		CycleLeft( temp ); // Cycle left once.
0002d6  a801              ADD      r0,sp,#4
0002d8  f7fffffe          BL       CycleLeft
;;;325          		SubBytes( temp, 4 ); // Substitute each byte.
0002dc  2104              MOVS     r1,#4
0002de  a801              ADD      r0,sp,#4
0002e0  f7fffffe          BL       SubBytes
;;;326          		XORBytes( temp, Rcon, 4 ); // Add constant in GF(2).
0002e4  2204              MOVS     r2,#4
0002e6  4669              MOV      r1,sp
0002e8  a801              ADD      r0,sp,#4
0002ea  f7fffffe          BL       XORBytes
;;;327          		*Rcon = (*Rcon << 1) ^ (*Rcon & 0x80 ? BPOLY : 0);
0002ee  f89d0000          LDRB     r0,[sp,#0]
0002f2  f0000080          AND      r0,r0,#0x80
0002f6  b108              CBZ      r0,|L1.764|
0002f8  201b              MOVS     r0,#0x1b
0002fa  e000              B        |L1.766|
                  |L1.764|
0002fc  2000              MOVS     r0,#0
                  |L1.766|
0002fe  f89d1000          LDRB     r1,[sp,#0]
000302  ea800041          EOR      r0,r0,r1,LSL #1
000306  b2c0              UXTB     r0,r0
000308  f88d0000          STRB     r0,[sp,#0]
                  |L1.780|
;;;328        	}
;;;329    
;;;330        	// Keysize larger than 24 bytes, ie. larger that 192 bits?
;;;331        	#if KEYLENGTH > 24
;;;332        	// Are we right past a block size?
;;;333        	else if( (i % KEYLENGTH) == BLOCKSIZE ) {
;;;334          		SubBytes( temp, 4 ); // Substitute each byte.
;;;335        	}
;;;336        	#endif
;;;337    
;;;338        	// Add bytes in GF(2) one KEYLENGTH away.
;;;339        	XORBytes( temp, expandedKey - KEYLENGTH, 4 );
00030c  f1a40110          SUB      r1,r4,#0x10
000310  2204              MOVS     r2,#4
000312  a801              ADD      r0,sp,#4
000314  f7fffffe          BL       XORBytes
;;;340    
;;;341        	// Copy result to current 4 bytes.
;;;342        	*(expandedKey++) = temp[ 0 ];
000318  f89d0004          LDRB     r0,[sp,#4]
00031c  f8040b01          STRB     r0,[r4],#1
;;;343        	*(expandedKey++) = temp[ 1 ];
000320  f89d0005          LDRB     r0,[sp,#5]
000324  f8040b01          STRB     r0,[r4],#1
;;;344        	*(expandedKey++) = temp[ 2 ];
000328  f89d0006          LDRB     r0,[sp,#6]
00032c  f8040b01          STRB     r0,[r4],#1
;;;345        	*(expandedKey++) = temp[ 3 ];
000330  f89d0007          LDRB     r0,[sp,#7]
000334  f8040b01          STRB     r0,[r4],#1
;;;346        	//CopyBytes(expandedKey, temp, 4);
;;;347        	//expandedKey += 4;
;;;348    
;;;349        	i += 4; // Next 4 bytes.
000338  1d28              ADDS     r0,r5,#4
00033a  b2c5              UXTB     r5,r0
                  |L1.828|
00033c  2db0              CMP      r5,#0xb0              ;319
00033e  dbc3              BLT      |L1.712|
;;;350      	}
;;;351    }
000340  bd7c              POP      {r2-r6,pc}
;;;352    
                          ENDP

                  KeyExpansionAt88 PROC
;;;353    void KeyExpansionAt88( unsigned char * expandedKey )
000342  b57c              PUSH     {r2-r6,lr}
;;;354    {
000344  4604              MOV      r4,r0
;;;355      	unsigned char temp[4];
;;;356      	unsigned char i;
;;;357      	unsigned char Rcon[4] = { 0x01, 0x00, 0x00, 0x00 }; // Round constant.
000346  a03a              ADR      r0,|L1.1072|
000348  6800              LDR      r0,[r0,#0]
00034a  9000              STR      r0,[sp,#0]
;;;358    
;;;359      	const unsigned char * key = kTableAt88;
00034c  4e3a              LDR      r6,|L1.1080|
;;;360    
;;;361      	// Copy key to start of expanded key.
;;;362      	i = KEYLENGTH;
00034e  2510              MOVS     r5,#0x10
;;;363      	do {
000350  bf00              NOP      
                  |L1.850|
;;;364        	*expandedKey = *key;
000352  7830              LDRB     r0,[r6,#0]
000354  7020              STRB     r0,[r4,#0]
;;;365        	expandedKey++;
000356  1c64              ADDS     r4,r4,#1
;;;366        	key++;
000358  1c76              ADDS     r6,r6,#1
;;;367      	} while( --i );
00035a  1e68              SUBS     r0,r5,#1
00035c  b2c0              UXTB     r0,r0
00035e  1e05              SUBS     r5,r0,#0
000360  d1f7              BNE      |L1.850|
;;;368    
;;;369      	// Prepare last 4 bytes of key in temp.
;;;370      	/*expandedKey -= 4;
;;;371      	temp[0] = *(expandedKey++);
;;;372      	temp[1] = *(expandedKey++);
;;;373      	temp[2] = *(expandedKey++);
;;;374      	temp[3] = *(expandedKey++);*/
;;;375      	CopyBytes(temp, expandedKey-4, 4);
000362  1f21              SUBS     r1,r4,#4
000364  2204              MOVS     r2,#4
000366  a801              ADD      r0,sp,#4
000368  f7fffffe          BL       CopyBytes
;;;376    
;;;377      	// Expand key.
;;;378      	i = KEYLENGTH;
00036c  2510              MOVS     r5,#0x10
;;;379      	//j = BLOCKSIZE*(ROUNDS+1) - KEYLENGTH;
;;;380      	while( i < BLOCKSIZE*(ROUNDS+1) ) 
00036e  e039              B        |L1.996|
                  |L1.880|
;;;381      	{
;;;382        	// Are we at the start of a multiple of the key size?
;;;383        	if( (i % KEYLENGTH) == 0 )
000370  17e9              ASRS     r1,r5,#31
000372  eb057111          ADD      r1,r5,r1,LSR #28
000376  1109              ASRS     r1,r1,#4
000378  eba51101          SUB      r1,r5,r1,LSL #4
00037c  b9d1              CBNZ     r1,|L1.948|
;;;384        	{
;;;385          		CycleLeft( temp ); // Cycle left once.
00037e  a801              ADD      r0,sp,#4
000380  f7fffffe          BL       CycleLeft
;;;386          		SubBytes( temp, 4 ); // Substitute each byte.
000384  2104              MOVS     r1,#4
000386  a801              ADD      r0,sp,#4
000388  f7fffffe          BL       SubBytes
;;;387          		XORBytes( temp, Rcon, 4 ); // Add constant in GF(2).
00038c  2204              MOVS     r2,#4
00038e  4669              MOV      r1,sp
000390  a801              ADD      r0,sp,#4
000392  f7fffffe          BL       XORBytes
;;;388          		*Rcon = (*Rcon << 1) ^ (*Rcon & 0x80 ? BPOLY : 0);
000396  f89d0000          LDRB     r0,[sp,#0]
00039a  f0000080          AND      r0,r0,#0x80
00039e  b108              CBZ      r0,|L1.932|
0003a0  201b              MOVS     r0,#0x1b
0003a2  e000              B        |L1.934|
                  |L1.932|
0003a4  2000              MOVS     r0,#0
                  |L1.934|
0003a6  f89d1000          LDRB     r1,[sp,#0]
0003aa  ea800041          EOR      r0,r0,r1,LSL #1
0003ae  b2c0              UXTB     r0,r0
0003b0  f88d0000          STRB     r0,[sp,#0]
                  |L1.948|
;;;389        	}
;;;390    
;;;391        	// Keysize larger than 24 bytes, ie. larger that 192 bits?
;;;392        	#if KEYLENGTH > 24
;;;393        	// Are we right past a block size?
;;;394        	else if( (i % KEYLENGTH) == BLOCKSIZE ) {
;;;395          		SubBytes( temp, 4 ); // Substitute each byte.
;;;396        	}
;;;397        	#endif
;;;398    
;;;399        	// Add bytes in GF(2) one KEYLENGTH away.
;;;400        	XORBytes( temp, expandedKey - KEYLENGTH, 4 );
0003b4  f1a40110          SUB      r1,r4,#0x10
0003b8  2204              MOVS     r2,#4
0003ba  a801              ADD      r0,sp,#4
0003bc  f7fffffe          BL       XORBytes
;;;401    
;;;402        	// Copy result to current 4 bytes.
;;;403        	*(expandedKey++) = temp[ 0 ];
0003c0  f89d0004          LDRB     r0,[sp,#4]
0003c4  f8040b01          STRB     r0,[r4],#1
;;;404        	*(expandedKey++) = temp[ 1 ];
0003c8  f89d0005          LDRB     r0,[sp,#5]
0003cc  f8040b01          STRB     r0,[r4],#1
;;;405        	*(expandedKey++) = temp[ 2 ];
0003d0  f89d0006          LDRB     r0,[sp,#6]
0003d4  f8040b01          STRB     r0,[r4],#1
;;;406        	*(expandedKey++) = temp[ 3 ];
0003d8  f89d0007          LDRB     r0,[sp,#7]
0003dc  f8040b01          STRB     r0,[r4],#1
;;;407        	//CopyBytes(expandedKey, temp, 4);
;;;408        	//expandedKey += 4;
;;;409    
;;;410        	i += 4; // Next 4 bytes.
0003e0  1d28              ADDS     r0,r5,#4
0003e2  b2c5              UXTB     r5,r0
                  |L1.996|
0003e4  2db0              CMP      r5,#0xb0              ;380
0003e6  dbc3              BLT      |L1.880|
;;;411      	}
;;;412    }
0003e8  bd7c              POP      {r2-r6,pc}
;;;413    
                          ENDP

                  InvCipher PROC
;;;414    void InvCipher( unsigned char * block, unsigned char * expandedKey )
0003ea  e92d41f0          PUSH     {r4-r8,lr}
;;;415    {
0003ee  4605              MOV      r5,r0
0003f0  460c              MOV      r4,r1
;;;416      	unsigned char i, j;
;;;417      	unsigned char round = ROUNDS-1;
0003f2  f04f0809          MOV      r8,#9
;;;418      	expandedKey += BLOCKSIZE * ROUNDS;
0003f6  34a0              ADDS     r4,r4,#0xa0
;;;419    
;;;420      	XORBytes( block, expandedKey, 16 );
0003f8  2210              MOVS     r2,#0x10
0003fa  4621              MOV      r1,r4
0003fc  4628              MOV      r0,r5
0003fe  f7fffffe          BL       XORBytes
;;;421      	expandedKey -= BLOCKSIZE;
000402  3c10              SUBS     r4,r4,#0x10
;;;422    
;;;423      	do {
000404  bf00              NOP      
                  |L1.1030|
;;;424        	InvShiftRows( block );
000406  4628              MOV      r0,r5
000408  f7fffffe          BL       InvShiftRows
;;;425        	InvSubBytesAndXOR( block, expandedKey, 16 );
00040c  2210              MOVS     r2,#0x10
00040e  4621              MOV      r1,r4
000410  4628              MOV      r0,r5
000412  f7fffffe          BL       InvSubBytesAndXOR
;;;426        	expandedKey -= BLOCKSIZE;
000416  3c10              SUBS     r4,r4,#0x10
;;;427        	//InvMixColumns( block );
;;;428        	for(i = 4, j = 0; i > 0; i--, j+=4)
000418  2604              MOVS     r6,#4
00041a  2700              MOVS     r7,#0
00041c  e015              B        |L1.1098|
00041e  0000              DCW      0x0000
                  |L1.1056|
                          DCD      logTbl
                  |L1.1060|
                          DCD      powTbl
                  |L1.1064|
                          DCD      sBox
                  |L1.1068|
                          DCD      block2
                  |L1.1072|
000430  0100              DCB      1,0
000432  00                DCB      0
000433  00                DCB      0
                  |L1.1076|
                          DCD      kTable
                  |L1.1080|
                          DCD      kTableAt88
                  |L1.1084|
;;;429          	InvMixColumn( block + j );
00043c  19e8              ADDS     r0,r5,r7
00043e  f7fffffe          BL       InvMixColumn
000442  1e70              SUBS     r0,r6,#1              ;428
000444  b2c6              UXTB     r6,r0                 ;428
000446  1d38              ADDS     r0,r7,#4              ;428
000448  b2c7              UXTB     r7,r0                 ;428
                  |L1.1098|
00044a  2e00              CMP      r6,#0                 ;428
00044c  dcf6              BGT      |L1.1084|
;;;430      	} while( --round );
00044e  f1a80001          SUB      r0,r8,#1
000452  b2c0              UXTB     r0,r0
000454  f1b00800          SUBS     r8,r0,#0
000458  d1d5              BNE      |L1.1030|
;;;431    
;;;432      	InvShiftRows( block );
00045a  4628              MOV      r0,r5
00045c  f7fffffe          BL       InvShiftRows
;;;433      	InvSubBytesAndXOR( block, expandedKey, 16 );
000460  2210              MOVS     r2,#0x10
000462  4621              MOV      r1,r4
000464  4628              MOV      r0,r5
000466  f7fffffe          BL       InvSubBytesAndXOR
;;;434    }
00046a  e8bd81f0          POP      {r4-r8,pc}
;;;435    
                          ENDP

                  aesDecInit PROC
;;;436    void aesDecInit(void)
00046e  b500              PUSH     {lr}
;;;437    {
;;;438      	powTbl = block1;
000470  48e1              LDR      r0,|L1.2040|
000472  49e2              LDR      r1,|L1.2044|
000474  6008              STR      r0,[r1,#0]  ; powTbl
;;;439      	logTbl = block2;
000476  48e2              LDR      r0,|L1.2048|
000478  49e2              LDR      r1,|L1.2052|
00047a  6008              STR      r0,[r1,#0]  ; logTbl
;;;440      	CalcPowLog( powTbl, logTbl );
00047c  4608              MOV      r0,r1
00047e  6801              LDR      r1,[r0,#0]  ; logTbl
000480  48de              LDR      r0,|L1.2044|
000482  6800              LDR      r0,[r0,#0]  ; powTbl
000484  f7fffffe          BL       CalcPowLog
;;;441    
;;;442      	sBox = tempbuf;
000488  48df              LDR      r0,|L1.2056|
00048a  49e0              LDR      r1,|L1.2060|
00048c  6008              STR      r0,[r1,#0]  ; sBox
;;;443      	CalcSBox( sBox );
00048e  4608              MOV      r0,r1
000490  6800              LDR      r0,[r0,#0]  ; sBox
000492  f7fffffe          BL       CalcSBox
;;;444    
;;;445      	expandedKey = block1;
000496  48d8              LDR      r0,|L1.2040|
000498  49dd              LDR      r1,|L1.2064|
00049a  6008              STR      r0,[r1,#0]  ; expandedKey
;;;446      	KeyExpansion( expandedKey );
00049c  4608              MOV      r0,r1
00049e  6800              LDR      r0,[r0,#0]  ; expandedKey
0004a0  f7fffffe          BL       KeyExpansion
;;;447    
;;;448      	sBoxInv = block2; // Must be block2.
0004a4  48d6              LDR      r0,|L1.2048|
0004a6  49db              LDR      r1,|L1.2068|
0004a8  6008              STR      r0,[r1,#0]  ; sBoxInv
;;;449      	CalcSBoxInv( sBox, sBoxInv );
0004aa  4608              MOV      r0,r1
0004ac  6801              LDR      r1,[r0,#0]  ; sBoxInv
0004ae  48d7              LDR      r0,|L1.2060|
0004b0  6800              LDR      r0,[r0,#0]  ; sBox
0004b2  f7fffffe          BL       CalcSBoxInv
;;;450    }
0004b6  bd00              POP      {pc}
;;;451    
                          ENDP

                  aesDecrypt PROC
;;;452    void aesDecrypt( unsigned char * buffer, unsigned char * chainBlock )
0004b8  b530              PUSH     {r4,r5,lr}
;;;453    {
0004ba  4604              MOV      r4,r0
0004bc  460d              MOV      r5,r1
;;;454      	CopyBytes( tempbuf, buffer, BLOCKSIZE );
0004be  2210              MOVS     r2,#0x10
0004c0  4621              MOV      r1,r4
0004c2  48d1              LDR      r0,|L1.2056|
0004c4  f7fffffe          BL       CopyBytes
;;;455      	InvCipher( buffer, expandedKey );
0004c8  48d1              LDR      r0,|L1.2064|
0004ca  6801              LDR      r1,[r0,#0]  ; expandedKey
0004cc  4620              MOV      r0,r4
0004ce  f7fffffe          BL       InvCipher
;;;456      	XORBytes( buffer, chainBlock, BLOCKSIZE );
0004d2  2210              MOVS     r2,#0x10
0004d4  4629              MOV      r1,r5
0004d6  4620              MOV      r0,r4
0004d8  f7fffffe          BL       XORBytes
;;;457      	CopyBytes( chainBlock, tempbuf, BLOCKSIZE );
0004dc  2210              MOVS     r2,#0x10
0004de  49ca              LDR      r1,|L1.2056|
0004e0  4628              MOV      r0,r5
0004e2  f7fffffe          BL       CopyBytes
;;;458    }
0004e6  bd30              POP      {r4,r5,pc}
;;;459    
                          ENDP

                  aesDecryptBlock PROC
;;;463    */
;;;464    void aesDecryptBlock(unsigned char *buffer, unsigned int nSize)
0004e8  b570              PUSH     {r4-r6,lr}
;;;465    {
0004ea  4605              MOV      r5,r0
0004ec  460e              MOV      r6,r1
;;;466      	unsigned int n;
;;;467    	//add 2010-07-27
;;;468    	for(n = 0; n < 16; n++)
0004ee  2400              MOVS     r4,#0
0004f0  e003              B        |L1.1274|
                  |L1.1266|
;;;469    		chainBlock[n] = 0;
0004f2  2000              MOVS     r0,#0
0004f4  49c8              LDR      r1,|L1.2072|
0004f6  5508              STRB     r0,[r1,r4]
0004f8  1c64              ADDS     r4,r4,#1              ;468
                  |L1.1274|
0004fa  2c10              CMP      r4,#0x10              ;468
0004fc  d3f9              BCC      |L1.1266|
;;;470    
;;;471      	for(n = nSize; n > 0; n -= 16)
0004fe  4634              MOV      r4,r6
000500  e015              B        |L1.1326|
                  |L1.1282|
;;;472      	{
;;;473        	CopyBytes( tempbuf, buffer, BLOCKSIZE );
000502  2210              MOVS     r2,#0x10
000504  4629              MOV      r1,r5
000506  48c0              LDR      r0,|L1.2056|
000508  f7fffffe          BL       CopyBytes
;;;474        	InvCipher( buffer, expandedKey );
00050c  48c0              LDR      r0,|L1.2064|
00050e  6801              LDR      r1,[r0,#0]  ; expandedKey
000510  4628              MOV      r0,r5
000512  f7fffffe          BL       InvCipher
;;;475    		// 在aes加密的基础上，增加了一异或
;;;476        	XORBytes( buffer, chainBlock, BLOCKSIZE );
000516  2210              MOVS     r2,#0x10
000518  49bf              LDR      r1,|L1.2072|
00051a  4628              MOV      r0,r5
00051c  f7fffffe          BL       XORBytes
;;;477        	CopyBytes( chainBlock, tempbuf, BLOCKSIZE );
000520  2210              MOVS     r2,#0x10
000522  49b9              LDR      r1,|L1.2056|
000524  48bc              LDR      r0,|L1.2072|
000526  f7fffffe          BL       CopyBytes
;;;478        	buffer += 16;
00052a  3510              ADDS     r5,r5,#0x10
00052c  3c10              SUBS     r4,r4,#0x10           ;471
                  |L1.1326|
00052e  2c00              CMP      r4,#0                 ;471
000530  d1e7              BNE      |L1.1282|
;;;479      	}
;;;480    }
000532  bd70              POP      {r4-r6,pc}
;;;481    
                          ENDP

                  aesDecryptAt88 PROC
;;;482    //add 2010-10-19
;;;483    void aesDecryptAt88(unsigned char *buffer)
000534  b530              PUSH     {r4,r5,lr}
;;;484    {
000536  4605              MOV      r5,r0
;;;485      	unsigned int n;
;;;486    
;;;487    	//add 2010-10-19
;;;488    	powTbl = block1;
000538  48af              LDR      r0,|L1.2040|
00053a  49b0              LDR      r1,|L1.2044|
00053c  6008              STR      r0,[r1,#0]  ; powTbl
;;;489      	logTbl = block2;
00053e  48b0              LDR      r0,|L1.2048|
000540  49b0              LDR      r1,|L1.2052|
000542  6008              STR      r0,[r1,#0]  ; logTbl
;;;490      	CalcPowLog( powTbl, logTbl );
000544  4608              MOV      r0,r1
000546  6801              LDR      r1,[r0,#0]  ; logTbl
000548  48ac              LDR      r0,|L1.2044|
00054a  6800              LDR      r0,[r0,#0]  ; powTbl
00054c  f7fffffe          BL       CalcPowLog
;;;491    
;;;492      	sBox = tempbuf;
000550  48ad              LDR      r0,|L1.2056|
000552  49ae              LDR      r1,|L1.2060|
000554  6008              STR      r0,[r1,#0]  ; sBox
;;;493      	CalcSBox( sBox );
000556  4608              MOV      r0,r1
000558  6800              LDR      r0,[r0,#0]  ; sBox
00055a  f7fffffe          BL       CalcSBox
;;;494    
;;;495      	expandedKey = block1;
00055e  48a6              LDR      r0,|L1.2040|
000560  49ab              LDR      r1,|L1.2064|
000562  6008              STR      r0,[r1,#0]  ; expandedKey
;;;496      	KeyExpansionAt88( expandedKey );
000564  4608              MOV      r0,r1
000566  6800              LDR      r0,[r0,#0]  ; expandedKey
000568  f7fffffe          BL       KeyExpansionAt88
;;;497    
;;;498      	sBoxInv = block2; // Must be block2.
00056c  48a4              LDR      r0,|L1.2048|
00056e  49a9              LDR      r1,|L1.2068|
000570  6008              STR      r0,[r1,#0]  ; sBoxInv
;;;499      	CalcSBoxInv( sBox, sBoxInv );
000572  4608              MOV      r0,r1
000574  6801              LDR      r1,[r0,#0]  ; sBoxInv
000576  48a5              LDR      r0,|L1.2060|
000578  6800              LDR      r0,[r0,#0]  ; sBox
00057a  f7fffffe          BL       CalcSBoxInv
;;;500    
;;;501    	//add 2010-07-27
;;;502    	for(n = 0; n < 16; n++)
00057e  2400              MOVS     r4,#0
000580  e003              B        |L1.1418|
                  |L1.1410|
;;;503    		chainBlock[n] = 0;
000582  2000              MOVS     r0,#0
000584  49a4              LDR      r1,|L1.2072|
000586  5508              STRB     r0,[r1,r4]
000588  1c64              ADDS     r4,r4,#1              ;502
                  |L1.1418|
00058a  2c10              CMP      r4,#0x10              ;502
00058c  d3f9              BCC      |L1.1410|
;;;504    
;;;505        CopyBytes( tempbuf, buffer, BLOCKSIZE );
00058e  2210              MOVS     r2,#0x10
000590  4629              MOV      r1,r5
000592  489d              LDR      r0,|L1.2056|
000594  f7fffffe          BL       CopyBytes
;;;506        InvCipher( buffer, expandedKey );
000598  489d              LDR      r0,|L1.2064|
00059a  6801              LDR      r1,[r0,#0]  ; expandedKey
00059c  4628              MOV      r0,r5
00059e  f7fffffe          BL       InvCipher
;;;507    	// 在aes加密的基础上，增加了一异或
;;;508        XORBytes( buffer, chainBlock, BLOCKSIZE );
0005a2  2210              MOVS     r2,#0x10
0005a4  499c              LDR      r1,|L1.2072|
0005a6  4628              MOV      r0,r5
0005a8  f7fffffe          BL       XORBytes
;;;509    }
0005ac  bd30              POP      {r4,r5,pc}
;;;510    
                          ENDP

                  Multiply PROC
;;;511    unsigned char Multiply( unsigned char num, unsigned char factor )
0005ae  b510              PUSH     {r4,lr}
;;;512    {
0005b0  4602              MOV      r2,r0
0005b2  460b              MOV      r3,r1
;;;513      	unsigned char mask = 1;
0005b4  2101              MOVS     r1,#1
;;;514      	unsigned char result = 0;
0005b6  2000              MOVS     r0,#0
;;;515    
;;;516      	while( mask != 0 ) 
0005b8  e00e              B        |L1.1496|
                  |L1.1466|
;;;517      	{
;;;518        	// Check bit of factor given by mask.
;;;519        	if( mask & factor ) 
0005ba  ea010403          AND      r4,r1,r3
0005be  b104              CBZ      r4,|L1.1474|
;;;520        	{
;;;521          		// Add current multiple of num in GF(2).
;;;522          		result ^= num;
0005c0  4050              EORS     r0,r0,r2
                  |L1.1474|
;;;523        	}
;;;524    
;;;525        	// Shift mask to indicate next bit.
;;;526        	mask <<= 1;
0005c2  064c              LSLS     r4,r1,#25
0005c4  0e21              LSRS     r1,r4,#24
;;;527    
;;;528        	// Double num.
;;;529        	num = (num << 1) ^ (num & 0x80 ? BPOLY : 0);
0005c6  f0020480          AND      r4,r2,#0x80
0005ca  b10c              CBZ      r4,|L1.1488|
0005cc  241b              MOVS     r4,#0x1b
0005ce  e000              B        |L1.1490|
                  |L1.1488|
0005d0  2400              MOVS     r4,#0
                  |L1.1490|
0005d2  ea840442          EOR      r4,r4,r2,LSL #1
0005d6  b2e2              UXTB     r2,r4
                  |L1.1496|
0005d8  2900              CMP      r1,#0                 ;516
0005da  d1ee              BNE      |L1.1466|
;;;530      	}
;;;531    
;;;532      	return result;
;;;533    }
0005dc  bd10              POP      {r4,pc}
;;;534    
                          ENDP

                  DotProduct PROC
;;;535    unsigned char DotProduct( const unsigned char * vector1, unsigned char * vector2 )
0005de  b5f0              PUSH     {r4-r7,lr}
;;;536    {
0005e0  4604              MOV      r4,r0
0005e2  460d              MOV      r5,r1
;;;537      	unsigned char result = 0 ,i;
0005e4  2600              MOVS     r6,#0
;;;538    
;;;539      	//result ^= Multiply( *vector1++, *vector2++ );
;;;540      	//result ^= Multiply( *vector1++, *vector2++ );
;;;541      	//result ^= Multiply( *vector1++, *vector2++ );
;;;542      	//result ^= Multiply( *vector1  , *vector2   );
;;;543    
;;;544      	for(i = 4; i > 0; i--)
0005e6  2704              MOVS     r7,#4
0005e8  e008              B        |L1.1532|
                  |L1.1514|
;;;545        	result ^= Multiply( *vector1++, *vector2++ );
0005ea  f8151b01          LDRB     r1,[r5],#1
0005ee  f8140b01          LDRB     r0,[r4],#1
0005f2  f7fffffe          BL       Multiply
0005f6  4046              EORS     r6,r6,r0
0005f8  1e78              SUBS     r0,r7,#1              ;544
0005fa  b2c7              UXTB     r7,r0                 ;544
                  |L1.1532|
0005fc  2f00              CMP      r7,#0                 ;544
0005fe  dcf4              BGT      |L1.1514|
;;;546    
;;;547      	return result;
000600  4630              MOV      r0,r6
;;;548    }
000602  bdf0              POP      {r4-r7,pc}
;;;549      
                          ENDP

                  MixColumn PROC
;;;553    }; // Prepare first row of matrix twice, to eliminate need for cycling.
;;;554    void MixColumn( unsigned char * column )
000604  b518              PUSH     {r3,r4,lr}
;;;555    {
000606  4604              MOV      r4,r0
;;;556      	unsigned char result[4];
;;;557    
;;;558      	// Take dot products of each matrix row and the column vector.
;;;559      	result[0] = DotProduct( row+0, column );
000608  4621              MOV      r1,r4
00060a  4884              LDR      r0,|L1.2076|
00060c  f7fffffe          BL       DotProduct
000610  f88d0000          STRB     r0,[sp,#0]
;;;560      	result[1] = DotProduct( row+3, column );
000614  4621              MOV      r1,r4
000616  4881              LDR      r0,|L1.2076|
000618  1cc0              ADDS     r0,r0,#3
00061a  f7fffffe          BL       DotProduct
00061e  f88d0001          STRB     r0,[sp,#1]
;;;561      	result[2] = DotProduct( row+2, column );
000622  4621              MOV      r1,r4
000624  487d              LDR      r0,|L1.2076|
000626  1c80              ADDS     r0,r0,#2
000628  f7fffffe          BL       DotProduct
00062c  f88d0002          STRB     r0,[sp,#2]
;;;562      	result[3] = DotProduct( row+1, column );
000630  4621              MOV      r1,r4
000632  487a              LDR      r0,|L1.2076|
000634  1c40              ADDS     r0,r0,#1
000636  f7fffffe          BL       DotProduct
00063a  f88d0003          STRB     r0,[sp,#3]
;;;563    
;;;564      	// Copy temporary result to original column.
;;;565      	//column[0] = result[0];
;;;566      	//column[1] = result[1];
;;;567      	//column[2] = result[2];
;;;568      	//column[3] = result[3];
;;;569      	CopyBytes(column, result, 4);
00063e  2204              MOVS     r2,#4
000640  4669              MOV      r1,sp
000642  4620              MOV      r0,r4
000644  f7fffffe          BL       CopyBytes
;;;570    }
000648  bd18              POP      {r3,r4,pc}
;;;571    
                          ENDP

                  ShiftRows PROC
;;;580    */
;;;581    void ShiftRows( unsigned char * state )
00064a  7841              LDRB     r1,[r0,#1]
;;;582    {
;;;583      	unsigned char temp;
;;;584      	
;;;585    	// Note: State is arranged column by column.
;;;586    
;;;587      	// Cycle second row left one time.
;;;588      	temp = state[ 1 + 0*4 ];
;;;589      	state[ 1 + 0*4 ] = state[ 1 + 1*4 ];
00064c  7942              LDRB     r2,[r0,#5]
00064e  7042              STRB     r2,[r0,#1]
;;;590      	state[ 1 + 1*4 ] = state[ 1 + 2*4 ];
000650  7a42              LDRB     r2,[r0,#9]
000652  7142              STRB     r2,[r0,#5]
;;;591      	state[ 1 + 2*4 ] = state[ 1 + 3*4 ];
000654  7b42              LDRB     r2,[r0,#0xd]
000656  7242              STRB     r2,[r0,#9]
;;;592      	state[ 1 + 3*4 ] = temp;
000658  7341              STRB     r1,[r0,#0xd]
;;;593    
;;;594      	// Cycle third row left two times.
;;;595      	temp = state[ 2 + 0*4 ];
00065a  7881              LDRB     r1,[r0,#2]
;;;596      	state[ 2 + 0*4 ] = state[ 2 + 2*4 ];
00065c  7a82              LDRB     r2,[r0,#0xa]
00065e  7082              STRB     r2,[r0,#2]
;;;597      	state[ 2 + 2*4 ] = temp;
000660  7281              STRB     r1,[r0,#0xa]
;;;598      	temp = state[ 2 + 1*4 ];
000662  7981              LDRB     r1,[r0,#6]
;;;599      	state[ 2 + 1*4 ] = state[ 2 + 3*4 ];
000664  7b82              LDRB     r2,[r0,#0xe]
000666  7182              STRB     r2,[r0,#6]
;;;600      	state[ 2 + 3*4 ] = temp;
000668  7381              STRB     r1,[r0,#0xe]
;;;601    
;;;602      	// Cycle fourth row left three times, ie. right once.
;;;603      	temp = state[ 3 + 3*4 ];
00066a  7bc1              LDRB     r1,[r0,#0xf]
;;;604      	state[ 3 + 3*4 ] = state[ 3 + 2*4 ];
00066c  7ac2              LDRB     r2,[r0,#0xb]
00066e  73c2              STRB     r2,[r0,#0xf]
;;;605      	state[ 3 + 2*4 ] = state[ 3 + 1*4 ];
000670  79c2              LDRB     r2,[r0,#7]
000672  72c2              STRB     r2,[r0,#0xb]
;;;606      	state[ 3 + 1*4 ] = state[ 3 + 0*4 ];
000674  78c2              LDRB     r2,[r0,#3]
000676  71c2              STRB     r2,[r0,#7]
;;;607      	state[ 3 + 0*4 ] = temp;
000678  70c1              STRB     r1,[r0,#3]
;;;608    }
00067a  4770              BX       lr
;;;609    
                          ENDP

                  Cipher PROC
;;;610    void Cipher( unsigned char * block, unsigned char * expandedKey )
00067c  e92d41f0          PUSH     {r4-r8,lr}
;;;611    {
000680  4605              MOV      r5,r0
000682  460c              MOV      r4,r1
;;;612      	unsigned char i, j;
;;;613      	unsigned char round = ROUNDS-1;
000684  f04f0809          MOV      r8,#9
;;;614    
;;;615      	XORBytes( block, expandedKey, 16 );
000688  2210              MOVS     r2,#0x10
00068a  4621              MOV      r1,r4
00068c  4628              MOV      r0,r5
00068e  f7fffffe          BL       XORBytes
;;;616      	expandedKey += BLOCKSIZE;
000692  3410              ADDS     r4,r4,#0x10
;;;617    
;;;618      	do {
000694  bf00              NOP      
                  |L1.1686|
;;;619        	SubBytes( block, 16 );
000696  2110              MOVS     r1,#0x10
000698  4628              MOV      r0,r5
00069a  f7fffffe          BL       SubBytes
;;;620        	ShiftRows( block );
00069e  4628              MOV      r0,r5
0006a0  f7fffffe          BL       ShiftRows
;;;621        	//MixColumns( block );
;;;622        	for(i = 4, j = 0; i > 0; i--, j+=4)
0006a4  2604              MOVS     r6,#4
0006a6  2700              MOVS     r7,#0
0006a8  e006              B        |L1.1720|
                  |L1.1706|
;;;623          	MixColumn( block + j );
0006aa  19e8              ADDS     r0,r5,r7
0006ac  f7fffffe          BL       MixColumn
0006b0  1e70              SUBS     r0,r6,#1              ;622
0006b2  b2c6              UXTB     r6,r0                 ;622
0006b4  1d38              ADDS     r0,r7,#4              ;622
0006b6  b2c7              UXTB     r7,r0                 ;622
                  |L1.1720|
0006b8  2e00              CMP      r6,#0                 ;622
0006ba  dcf6              BGT      |L1.1706|
;;;624        	XORBytes( block, expandedKey, 16 );
0006bc  2210              MOVS     r2,#0x10
0006be  4621              MOV      r1,r4
0006c0  4628              MOV      r0,r5
0006c2  f7fffffe          BL       XORBytes
;;;625        	expandedKey += BLOCKSIZE;
0006c6  3410              ADDS     r4,r4,#0x10
;;;626      	} while( --round );
0006c8  f1a80001          SUB      r0,r8,#1
0006cc  b2c0              UXTB     r0,r0
0006ce  f1b00800          SUBS     r8,r0,#0
0006d2  d1e0              BNE      |L1.1686|
;;;627    
;;;628      	SubBytes( block, 16 );
0006d4  2110              MOVS     r1,#0x10
0006d6  4628              MOV      r0,r5
0006d8  f7fffffe          BL       SubBytes
;;;629      	ShiftRows( block );
0006dc  4628              MOV      r0,r5
0006de  f7fffffe          BL       ShiftRows
;;;630      	XORBytes( block, expandedKey, 16 );
0006e2  2210              MOVS     r2,#0x10
0006e4  4621              MOV      r1,r4
0006e6  4628              MOV      r0,r5
0006e8  f7fffffe          BL       XORBytes
;;;631    }
0006ec  e8bd81f0          POP      {r4-r8,pc}
;;;632    
                          ENDP

                  aesEncInit PROC
;;;633    void aesEncInit(void)
0006f0  b500              PUSH     {lr}
;;;634    {
;;;635      	powTbl = block1;
0006f2  4841              LDR      r0,|L1.2040|
0006f4  4941              LDR      r1,|L1.2044|
0006f6  6008              STR      r0,[r1,#0]  ; powTbl
;;;636      	logTbl = block2;
0006f8  4841              LDR      r0,|L1.2048|
0006fa  4942              LDR      r1,|L1.2052|
0006fc  6008              STR      r0,[r1,#0]  ; logTbl
;;;637      	CalcPowLog( powTbl, logTbl );
0006fe  4608              MOV      r0,r1
000700  6801              LDR      r1,[r0,#0]  ; logTbl
000702  483e              LDR      r0,|L1.2044|
000704  6800              LDR      r0,[r0,#0]  ; powTbl
000706  f7fffffe          BL       CalcPowLog
;;;638    
;;;639      	sBox = block2;
00070a  483d              LDR      r0,|L1.2048|
00070c  493f              LDR      r1,|L1.2060|
00070e  6008              STR      r0,[r1,#0]  ; sBox
;;;640      	CalcSBox( sBox );
000710  4608              MOV      r0,r1
000712  6800              LDR      r0,[r0,#0]  ; sBox
000714  f7fffffe          BL       CalcSBox
;;;641    
;;;642      	expandedKey = block1;
000718  4837              LDR      r0,|L1.2040|
00071a  493d              LDR      r1,|L1.2064|
00071c  6008              STR      r0,[r1,#0]  ; expandedKey
;;;643      	KeyExpansion( expandedKey );
00071e  4608              MOV      r0,r1
000720  6800              LDR      r0,[r0,#0]  ; expandedKey
000722  f7fffffe          BL       KeyExpansion
;;;644    }
000726  bd00              POP      {pc}
;;;645    
                          ENDP

                  aesEncrypt PROC
;;;646    void aesEncrypt( unsigned char * buffer, unsigned char * chainBlock )
000728  b530              PUSH     {r4,r5,lr}
;;;647    {
00072a  4604              MOV      r4,r0
00072c  460d              MOV      r5,r1
;;;648      	XORBytes( buffer, chainBlock, BLOCKSIZE );
00072e  2210              MOVS     r2,#0x10
000730  4629              MOV      r1,r5
000732  4620              MOV      r0,r4
000734  f7fffffe          BL       XORBytes
;;;649      	Cipher( buffer, expandedKey );
000738  4835              LDR      r0,|L1.2064|
00073a  6801              LDR      r1,[r0,#0]  ; expandedKey
00073c  4620              MOV      r0,r4
00073e  f7fffffe          BL       Cipher
;;;650      	CopyBytes( chainBlock, buffer, BLOCKSIZE );
000742  2210              MOVS     r2,#0x10
000744  4621              MOV      r1,r4
000746  4628              MOV      r0,r5
000748  f7fffffe          BL       CopyBytes
;;;651    }
00074c  bd30              POP      {r4,r5,pc}
;;;652    
                          ENDP

                  aesEncryptBlock PROC
;;;656    */
;;;657    void aesEncryptBlock(unsigned char *buffer,unsigned int nSize)
00074e  b570              PUSH     {r4-r6,lr}
;;;658    {
000750  4605              MOV      r5,r0
000752  460e              MOV      r6,r1
;;;659    	unsigned int n;
;;;660    
;;;661    	//add 2010-07-27
;;;662    	for(n = 0; n < 16; n++)
000754  2400              MOVS     r4,#0
000756  e003              B        |L1.1888|
                  |L1.1880|
;;;663    		chainBlock[n] = 0;
000758  2000              MOVS     r0,#0
00075a  492f              LDR      r1,|L1.2072|
00075c  5508              STRB     r0,[r1,r4]
00075e  1c64              ADDS     r4,r4,#1              ;662
                  |L1.1888|
000760  2c10              CMP      r4,#0x10              ;662
000762  d3f9              BCC      |L1.1880|
;;;664    
;;;665    	for(n = nSize;n > 0;n -= 16)
000764  4634              MOV      r4,r6
000766  e010              B        |L1.1930|
                  |L1.1896|
;;;666    	{
;;;667    		XORBytes( buffer, chainBlock, BLOCKSIZE );
000768  2210              MOVS     r2,#0x10
00076a  492b              LDR      r1,|L1.2072|
00076c  4628              MOV      r0,r5
00076e  f7fffffe          BL       XORBytes
;;;668      		Cipher( buffer, expandedKey );
000772  4827              LDR      r0,|L1.2064|
000774  6801              LDR      r1,[r0,#0]  ; expandedKey
000776  4628              MOV      r0,r5
000778  f7fffffe          BL       Cipher
;;;669      		CopyBytes( chainBlock, buffer, BLOCKSIZE );
00077c  2210              MOVS     r2,#0x10
00077e  4629              MOV      r1,r5
000780  4825              LDR      r0,|L1.2072|
000782  f7fffffe          BL       CopyBytes
;;;670    		buffer += 16;
000786  3510              ADDS     r5,r5,#0x10
000788  3c10              SUBS     r4,r4,#0x10           ;665
                  |L1.1930|
00078a  2c00              CMP      r4,#0                 ;665
00078c  d1ec              BNE      |L1.1896|
;;;671    	}
;;;672    }
00078e  bd70              POP      {r4-r6,pc}
;;;673    
                          ENDP

                  aesEncryptAt88 PROC
;;;675    //add 2010-10-19
;;;676    void aesEncryptAt88(unsigned char *buffer)
000790  b530              PUSH     {r4,r5,lr}
;;;677    {
000792  4605              MOV      r5,r0
;;;678    	unsigned int n;
;;;679    
;;;680    	powTbl = block1;
000794  4818              LDR      r0,|L1.2040|
000796  4919              LDR      r1,|L1.2044|
000798  6008              STR      r0,[r1,#0]  ; powTbl
;;;681      	logTbl = block2;
00079a  4819              LDR      r0,|L1.2048|
00079c  4919              LDR      r1,|L1.2052|
00079e  6008              STR      r0,[r1,#0]  ; logTbl
;;;682      	CalcPowLog( powTbl, logTbl );
0007a0  4608              MOV      r0,r1
0007a2  6801              LDR      r1,[r0,#0]  ; logTbl
0007a4  4815              LDR      r0,|L1.2044|
0007a6  6800              LDR      r0,[r0,#0]  ; powTbl
0007a8  f7fffffe          BL       CalcPowLog
;;;683    
;;;684      	sBox = block2;
0007ac  4814              LDR      r0,|L1.2048|
0007ae  4917              LDR      r1,|L1.2060|
0007b0  6008              STR      r0,[r1,#0]  ; sBox
;;;685      	CalcSBox( sBox );
0007b2  4608              MOV      r0,r1
0007b4  6800              LDR      r0,[r0,#0]  ; sBox
0007b6  f7fffffe          BL       CalcSBox
;;;686    
;;;687      	expandedKey = block1;
0007ba  480f              LDR      r0,|L1.2040|
0007bc  4914              LDR      r1,|L1.2064|
0007be  6008              STR      r0,[r1,#0]  ; expandedKey
;;;688      	KeyExpansionAt88( expandedKey );
0007c0  4608              MOV      r0,r1
0007c2  6800              LDR      r0,[r0,#0]  ; expandedKey
0007c4  f7fffffe          BL       KeyExpansionAt88
;;;689    	//add 2010-07-27
;;;690    	for(n = 0; n < 16; n++)
0007c8  2400              MOVS     r4,#0
0007ca  e003              B        |L1.2004|
                  |L1.1996|
;;;691    		chainBlock[n] = 0;
0007cc  2000              MOVS     r0,#0
0007ce  4912              LDR      r1,|L1.2072|
0007d0  5508              STRB     r0,[r1,r4]
0007d2  1c64              ADDS     r4,r4,#1              ;690
                  |L1.2004|
0007d4  2c10              CMP      r4,#0x10              ;690
0007d6  d3f9              BCC      |L1.1996|
;;;692    
;;;693    	XORBytes( buffer, chainBlock, BLOCKSIZE );
0007d8  2210              MOVS     r2,#0x10
0007da  490f              LDR      r1,|L1.2072|
0007dc  4628              MOV      r0,r5
0007de  f7fffffe          BL       XORBytes
;;;694      	Cipher( buffer, expandedKey );
0007e2  480b              LDR      r0,|L1.2064|
0007e4  6801              LDR      r1,[r0,#0]  ; expandedKey
0007e6  4628              MOV      r0,r5
0007e8  f7fffffe          BL       Cipher
;;;695      	CopyBytes( chainBlock, buffer, BLOCKSIZE );
0007ec  2210              MOVS     r2,#0x10
0007ee  4629              MOV      r1,r5
0007f0  4809              LDR      r0,|L1.2072|
0007f2  f7fffffe          BL       CopyBytes
;;;696    }
0007f6  bd30              POP      {r4,r5,pc}
;;;697    
                          ENDP

                  |L1.2040|
                          DCD      block1
                  |L1.2044|
                          DCD      powTbl
                  |L1.2048|
                          DCD      block2
                  |L1.2052|
                          DCD      logTbl
                  |L1.2056|
                          DCD      tempbuf
                  |L1.2060|
                          DCD      sBox
                  |L1.2064|
                          DCD      expandedKey
                  |L1.2068|
                          DCD      sBoxInv
                  |L1.2072|
                          DCD      chainBlock
                  |L1.2076|
                          DCD      ||row||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  block1
                          %        256
                  block2
                          %        256
                  tempbuf
                          %        256
                  chainBlock
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  kTable
000000  96709ad3          DCB      0x96,0x70,0x9a,0xd3
000004  26674ac3          DCB      0x26,0x67,0x4a,0xc3
000008  82b66927          DCB      0x82,0xb6,0x69,0x27
00000c  e6d88421          DCB      0xe6,0xd8,0x84,0x21
000010  25f8a88c          DCB      0x25,0xf8,0xa8,0x8c
000014  292a1593          DCB      0x29,0x2a,0x15,0x93
000018  d5a5a3b2          DCB      0xd5,0xa5,0xa3,0xb2
00001c  7b912867          DCB      0x7b,0x91,0x28,0x67
                  kTableAt88
000020  82314e66          DCB      0x82,0x31,0x4e,0x66
000024  e1d1f513          DCB      0xe1,0xd1,0xf5,0x13
000028  b653d2c6          DCB      0xb6,0x53,0xd2,0xc6
00002c  937f3972          DCB      0x93,0x7f,0x39,0x72
000030  c1a83f8c          DCB      0xc1,0xa8,0x3f,0x8c
000034  295515c6          DCB      0x29,0x55,0x15,0xc6
000038  9bb36628          DCB      0x9b,0xb3,0x66,0x28
00003c  0a26e12f          DCB      0x0a,0x26,0xe1,0x2f
                  ||row||
000040  02030101          DCB      0x02,0x03,0x01,0x01
000044  02030101          DCB      0x02,0x03,0x01,0x01

                          AREA ||.data||, DATA, ALIGN=2

                  powTbl
                          DCD      0x00000000
                  logTbl
                          DCD      0x00000000
                  sBox
                          DCD      0x00000000
                  sBoxInv
                          DCD      0x00000000
                  expandedKey
                          DCD      0x00000000
