L 1 "app\cfg\cfg_unpack.c"
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_MAIN.uvproj
N  * @File Name          : cfg_unpack.c
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2012-05-28 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    Begginning of application   
N  */
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 14 "app\cfg\cfg_unpack.c" 2
N#include "../../cstartup/type.h"
L 1 "app\cfg\../../cstartup/type.h" 1
N/*****************************************************************************
N *   type.h:  Type definition Header file for NXP LPC17xx Family 
N *   Microprocessors
N *
N *   Copyright(C) 2009, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2009.05.25  ver 1.00    Prelimnary version, first Release
N *
N******************************************************************************/
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 13 "app\cfg\../../cstartup/type.h" 2
N
N#ifndef __TYPE_H__
N#define __TYPE_H__
N
N#ifndef NULL
S#define NULL    ((void *)0)
N#endif
N
N#ifndef FALSE
N#define FALSE   (0)
N#endif
N
N#ifndef TRUE
N#define TRUE    (1)
N#endif
N
N#ifndef __FALSE
N#define __FALSE   (0)
N#endif
N
N#ifndef __TRUE
N#define __TRUE    (1)
N#endif
N
Ntypedef char			   C08;			/* 8 bit character					*/
Ntypedef char               S08;
Ntypedef unsigned char      U08;
Ntypedef short              S16;
Ntypedef unsigned short     U16;
Ntypedef int                S32;
Ntypedef unsigned int       U32;
Ntypedef long long          S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char      BIT;
Ntypedef void*			   VP;				/* pointer to variable data type	*/
Ntypedef unsigned int       BOOL;
N
N#endif  /* __TYPE_H__ */
L 15 "app\cfg\cfg_unpack.c" 2
N#include "../../drivers/drivers.h"
L 1 "app\cfg\../../drivers/drivers.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : drivers.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-01-27 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx on chip peripheral derivers        
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __DRIVERS_H__
N#define __DRIVERS_H__
N
N/* Includes ------------------------------------------------------------------*/
N/* STANDARD LIBRARIES */
N#include  <string.h>
N#include  <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 23 "app\cfg\../../drivers/drivers.h" 2
N#include  <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 24 "app\cfg\../../drivers/drivers.h" 2
N#include  <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 25 "app\cfg\../../drivers/drivers.h" 2
N#include <LPC17xx.h>
L 1 ".\cstartup\LPC17xx.h" 1
N/******************************************************************************
N * @file:    LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File for 
N *           NXP LPC17xx Device Series 
N * @version: V1.04
N * @date:    2. July 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2008 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /* USB Activity interrupt                             */
N  CANActivity_IRQn              = 34,       /* CAN Activity interrupt                             */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include <core_cm3.h>                       /* Cortex-M3 processor and core peripherals           */
L 1 ".\cstartup\core_cm3.h" 1
N/******************************************************************************
N * @file:    core_cm3.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version: V1.20
N * @date:    22. May 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N/**
N *  Lint configuration \n
N *  ----------------------- \n
N *
N *  The following Lint messages will be suppressed and not shown: \n
N *  \n
N *    --- Error 10: --- \n
N *    register uint32_t __regBasePri         __asm("basepri"); \n
N *    Error 10: Expecting ';' \n
N *     \n
N *    --- Error 530: --- \n
N *    return(__regBasePri); \n
N *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
N *     \n
N *    --- Error 550: --- \n
N *      __regBasePri = (basePri & 0x1ff); \n
N *    } \n
N *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
N *     \n
N *    --- Error 754: --- \n
N *    uint32_t RESERVED0[24]; \n
N *    Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 750: --- \n
N *    #define __CM3_CORE_H__ \n
N *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 528: --- \n
N *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 751: --- \n
N *    } InterruptType_Type; \n
N *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
N * \n
N * \n
N *    Note:  To re-enable a Message, insert a space before 'lint' * \n
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N#include <stdint.h>                           /* Include standard types */
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S#define     __I     volatile                  /*!< defines 'read only' permissions      */
N#else
N#define     __I     volatile const            /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N
N
N/* System Reset */
N#define NVIC_VECTRESET              0         /*!< Vector Reset Bit             */
N#define NVIC_SYSRESETREQ            2         /*!< System Reset Request         */
N#define NVIC_AIRCR_VECTKEY    (0x5FA << 16)   /*!< AIRCR Key for write access   */
N#define NVIC_AIRCR_ENDIANESS        15        /*!< Endianess                    */
N
N/* Core Debug */
N#define CoreDebug_DEMCR_TRCENA (1 << 24)      /*!< DEMCR TRCENA enable          */
N#define ITM_TCR_ITMENA              1         /*!< ITM enable                   */
N
N
N
N
N/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Interrupt Set Enable Register            */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Interrupt Active bit Register            */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Interrupt Priority Register, 8Bit wide   */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Software Trigger Interrupt Register      */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N
N
N/* memory mapping struct for System Control Block */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< CPU ID Base Register                                     */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Interrupt Control State Register                         */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Vector Table Offset Register                             */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Application Interrupt / Reset Control Register           */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< System Control Register                                  */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Configuration Control Register                           */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< System Handlers Priority Registers (4-7, 8-11, 12-15)    */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< System Handler Control and State Register                */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Configurable Fault Status Register                       */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Hard Fault Status Register                               */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Debug Fault Status Register                              */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Mem Manage Address Register                              */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Bus Fault Address Register                               */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Auxiliary Fault Status Register                          */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Processor Feature Register                               */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Debug Feature Register                                   */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Auxiliary Feature Register                               */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Memory Model Feature Register                            */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< ISA Feature Register                                     */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N
N/* memory mapping struct for SysTick */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N
N/* memory mapping structur for ITM */
Ntypedef struct
N{
N  __O  union  
X  volatile  union  
N  {
N    __O  uint8_t    u8;                       /*!< ITM Stimulus Port 8-bit               */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< ITM Stimulus Port 16-bit              */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< ITM Stimulus Port 32-bit              */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< ITM Stimulus Port Registers           */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< ITM Trace Enable Register             */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< ITM Trace Privilege Register          */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< ITM Trace Control Register            */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< ITM Integration Write Register        */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< ITM Integration Read Register         */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< ITM Lock Access Register              */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< ITM Lock Status Register              */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< ITM Product ID Registers              */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;
X  volatile const  uint32_t PID5;
N  __I  uint32_t PID6;
X  volatile const  uint32_t PID6;
N  __I  uint32_t PID7;
X  volatile const  uint32_t PID7;
N  __I  uint32_t PID0;
X  volatile const  uint32_t PID0;
N  __I  uint32_t PID1;
X  volatile const  uint32_t PID1;
N  __I  uint32_t PID2;
X  volatile const  uint32_t PID2;
N  __I  uint32_t PID3;
X  volatile const  uint32_t PID3;
N  __I  uint32_t CID0;
X  volatile const  uint32_t CID0;
N  __I  uint32_t CID1;
X  volatile const  uint32_t CID1;
N  __I  uint32_t CID2;
X  volatile const  uint32_t CID2;
N  __I  uint32_t CID3;
X  volatile const  uint32_t CID3;
N} ITM_Type;
N
N
N/* memory mapped struct for Interrupt Type */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Interrupt Control Type Register  */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Auxiliary Control Register       */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N
N/* Memory Protection Unit */
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< MPU Type Register                               */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< MPU Control Register                            */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< MPU Region RNRber Register                      */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< MPU Region Base Address Register                */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< MPU Region Attribute and Size Register          */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< MPU Alias 1 Region Base Address Register        */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< MPU Alias 1 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< MPU Alias 2 Region Base Address Register        */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< MPU Alias 2 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< MPU Alias 3 Region Base Address Register        */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< MPU Alias 3 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N#endif
N
N
N/* Core Debug Register */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Debug Halting Control and Status Register       */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Debug Core Register Selector Register           */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Debug Core Register Data Register               */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Debug Exception and Monitor Control Register    */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address    */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                     */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address              */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address                 */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                    */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address    */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register              */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct             */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct         */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct            */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct             */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct      */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit               */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit               */
N#endif
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler           */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler       */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @param  none
N * @return uint32_t ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  uint32_t Process Stack Pointer
N * @return none
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @param  none
N * @return uint32_t Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  uint32_t Main Stack Pointer
N * @return none
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param  uint16_t value to reverse
N * @return uint32_t reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/*
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param  int16_t value to reverse
N * @return int32_t reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5060422 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * @param  none
S * @return none
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @param  none
S * @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * @param  none
N * @return none
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @param  none
N * @return uint32_t BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  uint32_t BasePriority
N * @return none
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0x1ff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @param  none
N * @return uint32_t PriMask
N *
N * Return the state of the priority mask bit from the priority mask
N * register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  uint32_t PriMask
N * @return none
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @param  none
N * @return uint32_t FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  uint32_t faultMask value
N * @return none
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @param  none
N * @return uint32_t Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  uint32_t Control value
N * @return none
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation()          /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @param  none
S*  @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/*
S * Reverse byte order in signed short value with sign extension to integer
S *
S * @param  int16_t value to reverse
S * @return int32_t reversed value
S *
S * @brief  Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N
N/* ##########################   NVIC functions  #################################### */
N
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  uint32_t priority_grouping is priority grouping field
N * @return none 
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field 
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  
N  reg_value  = SCB->AIRCR;                                                    /* read old register configuration    */
X  reg_value  = ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                     
N  reg_value &= ~((0xFFFFU << 16) | (0x0F << 8));                              /* clear bits to change               */
N  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp << 8)));  /* Insert write key and priorty group */
X  reg_value  = ((reg_value | (0x5FA << 16) | (PriorityGroupTmp << 8)));   
N  SCB->AIRCR = reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR = reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @param  none
N * @return uint32_t   priority grouping field 
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR >> 8) & 0x07);                                          /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR >> 8) & 0x07);                                           
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn_Type IRQn specifies the interrupt number
N * @return none 
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn_Type IRQn is the positive number of the external interrupt
N * @return none
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn_Type IRQn is the number of the device specifc interrupt
N * @return uint32_t 1 if pending interrupt else 0
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn_Type  IRQn is the Number of the interrupt
N * @return uint32_t   1 if active else 0
N *
N * Read the active register in NVIC and returns 1 if its status is active, 
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @param  priority is the priority for the interrupt
N * @return none
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt. \n
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return uint32_t  priority is the priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  uint32_t PriorityGroup   is the used priority group
N * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
N * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
N * @return uint32_t                    the priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N 
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  uint32_t   Priority       the priority for the interrupt
N * @param  uint32_t   PrioGroup   is the used priority group
N * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
N * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
N * @return none
N *
N * Decode an interrupt priority value with the given priority group to 
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N  
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/* SysTick constants */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param  uint32_t ticks is the number of ticks between two interrupts
N * @return  none
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
X  if (ticks > ((1<<24) -1))  return (1);                                              
N
N  SysTick->LOAD  =  (ticks & SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  =  (ticks & ((1<<24) -1)) - 1;                                       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);                             
N  SysTick->VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   =  (0x00);                                                               
N  SysTick->CTRL = (1 << SYSTICK_CLKSOURCE) | (1<<SYSTICK_ENABLE) | (1<<SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1 << 2) | (1<<0) | (1<<1);  
N  return (0);                                                                            /* Function successful */
N}
N
N#endif
N
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * @param   none
N * @return  none
N *
N * Initialize a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB->AIRCR & (0x700)) | (1<<NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16) | (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (0x700)) | (1<<2));  
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N
N/* ##################################    Debug Output  function  ############################################ */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param   uint32_t character to output
N * @return  uint32_t input character
N *
N * The function outputs a character via the ITM channel 0. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (ch == '\n') ITM_SendChar('\r');
N  
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA)  &&
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1 << 24))  &&
N      (ITM->TCR & ITM_TCR_ITMENA)                  &&
X      (((ITM_Type *) (0xE0000000))->TCR & 1)                  &&
N      (ITM->TER & (1UL << 0))  ) 
X      (((ITM_Type *) (0xE0000000))->TER & (1UL << 0))  ) 
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }  
N  return (ch);
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CM3_CORE_H__ */
N
N/*lint -restore */
L 97 ".\cstartup\LPC17xx.h" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 ".\cstartup\system_LPC17xx.h" 1
N/******************************************************************************
N * @file:    system_LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Device Peripheral Access Layer Header File
N *           for the NXP LPC17xx Device Series 
N * @version: V1.01
N * @date:    22. Jul. 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
Nvoid SystemCoreClockUpdate (void);       
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
Nextern uint32_t SystemFrequency;    /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemFrequency variable.
N */
Nextern void SystemInit (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC17xx_H */
L 98 ".\cstartup\LPC17xx.h" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#pragma anon_unions
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
X  volatile uint32_t FLASHCFG;                
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                /* Clocking and Power Control         */
X  volatile uint32_t PLL0CON;                 
N  __IO uint32_t PLL0CFG;
X  volatile uint32_t PLL0CFG;
N  __I  uint32_t PLL0STAT;
X  volatile const  uint32_t PLL0STAT;
N  __O  uint32_t PLL0FEED;
X  volatile  uint32_t PLL0FEED;
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;
X  volatile uint32_t PLL1CON;
N  __IO uint32_t PLL1CFG;
X  volatile uint32_t PLL1CFG;
N  __I  uint32_t PLL1STAT;
X  volatile const  uint32_t PLL1STAT;
N  __O  uint32_t PLL1FEED;
X  volatile  uint32_t PLL1FEED;
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;
X  volatile uint32_t PCON;
N  __IO uint32_t PCONP;
X  volatile uint32_t PCONP;
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;
X  volatile uint32_t CCLKCFG;
N  __IO uint32_t USBCLKCFG;
X  volatile uint32_t USBCLKCFG;
N  __IO uint32_t CLKSRCSEL;
X  volatile uint32_t CLKSRCSEL;
N  __IO uint32_t	CANSLEEPCLR;
X  volatile uint32_t	CANSLEEPCLR;
N  __IO uint32_t	CANWAKEFLAGS;
X  volatile uint32_t	CANWAKEFLAGS;
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                 /* External Interrupts                */
X  volatile uint32_t EXTINT;                  
N       uint32_t RESERVED5;
N  __IO uint32_t EXTMODE;
X  volatile uint32_t EXTMODE;
N  __IO uint32_t EXTPOLAR;
X  volatile uint32_t EXTPOLAR;
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                   /* Reset                              */
X  volatile uint32_t RSID;                    
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                    /* Syscon Miscellaneous Registers     */
X  volatile uint32_t SCS;                     
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;
X  volatile uint32_t PCLKSEL0;
N  __IO uint32_t PCLKSEL1;
X  volatile uint32_t PCLKSEL1;
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
X  volatile uint32_t USBIntSt;                
N  __IO uint32_t DMAREQSEL;              /* DMA Request Select Register        */
X  volatile uint32_t DMAREQSEL;               
N  __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
X  volatile uint32_t CLKOUTCFG;               
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;
X  volatile uint32_t PINSEL0;
N  __IO uint32_t PINSEL1;
X  volatile uint32_t PINSEL1;
N  __IO uint32_t PINSEL2;
X  volatile uint32_t PINSEL2;
N  __IO uint32_t PINSEL3;
X  volatile uint32_t PINSEL3;
N  __IO uint32_t PINSEL4;
X  volatile uint32_t PINSEL4;
N  __IO uint32_t PINSEL5;
X  volatile uint32_t PINSEL5;
N  __IO uint32_t PINSEL6;
X  volatile uint32_t PINSEL6;
N  __IO uint32_t PINSEL7;
X  volatile uint32_t PINSEL7;
N  __IO uint32_t PINSEL8;
X  volatile uint32_t PINSEL8;
N  __IO uint32_t PINSEL9;
X  volatile uint32_t PINSEL9;
N  __IO uint32_t PINSEL10;
X  volatile uint32_t PINSEL10;
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;
X  volatile uint32_t PINMODE0;
N  __IO uint32_t PINMODE1;
X  volatile uint32_t PINMODE1;
N  __IO uint32_t PINMODE2;
X  volatile uint32_t PINMODE2;
N  __IO uint32_t PINMODE3;
X  volatile uint32_t PINMODE3;
N  __IO uint32_t PINMODE4;
X  volatile uint32_t PINMODE4;
N  __IO uint32_t PINMODE5;
X  volatile uint32_t PINMODE5;
N  __IO uint32_t PINMODE6;
X  volatile uint32_t PINMODE6;
N  __IO uint32_t PINMODE7;
X  volatile uint32_t PINMODE7;
N  __IO uint32_t PINMODE8;
X  volatile uint32_t PINMODE8;
N  __IO uint32_t PINMODE9;
X  volatile uint32_t PINMODE9;
N  __IO uint32_t PINMODE_OD0;
X  volatile uint32_t PINMODE_OD0;
N  __IO uint32_t PINMODE_OD1;
X  volatile uint32_t PINMODE_OD1;
N  __IO uint32_t PINMODE_OD2;
X  volatile uint32_t PINMODE_OD2;
N  __IO uint32_t PINMODE_OD3;
X  volatile uint32_t PINMODE_OD3;
N  __IO uint32_t PINMODE_OD4;
X  volatile uint32_t PINMODE_OD4;
N  __IO uint32_t I2CPADCFG;
X  volatile uint32_t I2CPADCFG;
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FIODIR;
X  volatile uint32_t FIODIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t FIOMASK;
X  volatile uint32_t FIOMASK;
N  __IO uint32_t FIOPIN;
X  volatile uint32_t FIOPIN;
N  __IO uint32_t FIOSET;
X  volatile uint32_t FIOSET;
N  __O  uint32_t FIOCLR;
X  volatile  uint32_t FIOCLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N  __I  uint32_t CR2;
X  volatile const  uint32_t CR2;
N  __I  uint32_t CR3;
X  volatile const  uint32_t CR3;
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;
X  volatile uint32_t MR4;
N  __IO uint32_t MR5;
X  volatile uint32_t MR5;
N  __IO uint32_t MR6;
X  volatile uint32_t MR6;
N  __IO uint32_t PCR;
X  volatile uint32_t PCR;
N  __IO uint32_t LER;
X  volatile uint32_t LER;
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART0_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t SPCR;
X  volatile uint32_t SPCR;
N  __I  uint32_t SPSR;
X  volatile const  uint32_t SPSR;
N  __IO uint32_t SPDR;
X  volatile uint32_t SPDR;
N  __IO uint32_t SPCCR;
X  volatile uint32_t SPCCR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;
X  volatile uint32_t SPINT;
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2CONSET;
X  volatile uint32_t I2CONSET;
N  __I  uint32_t I2STAT;
X  volatile const  uint32_t I2STAT;
N  __IO uint32_t I2DAT;
X  volatile uint32_t I2DAT;
N  __IO uint32_t I2ADR0;
X  volatile uint32_t I2ADR0;
N  __IO uint32_t I2SCLH;
X  volatile uint32_t I2SCLH;
N  __IO uint32_t I2SCLL;
X  volatile uint32_t I2SCLL;
N  __O  uint32_t I2CONCLR;
X  volatile  uint32_t I2CONCLR;
N  __IO uint32_t MMCTRL;
X  volatile uint32_t MMCTRL;
N  __IO uint32_t I2ADR1;
X  volatile uint32_t I2ADR1;
N  __IO uint32_t I2ADR2;
X  volatile uint32_t I2ADR2;
N  __IO uint32_t I2ADR3;
X  volatile uint32_t I2ADR3;
N  __I  uint32_t I2DATA_BUFFER;
X  volatile const  uint32_t I2DATA_BUFFER;
N  __IO uint32_t I2MASK0;
X  volatile uint32_t I2MASK0;
N  __IO uint32_t I2MASK1;
X  volatile uint32_t I2MASK1;
N  __IO uint32_t I2MASK2;
X  volatile uint32_t I2MASK2;
N  __IO uint32_t I2MASK3;
X  volatile uint32_t I2MASK3;
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2SDAO;
X  volatile uint32_t I2SDAO;
N  __IO uint32_t I2SDAI;
X  volatile uint32_t I2SDAI;
N  __O  uint32_t I2STXFIFO;
X  volatile  uint32_t I2STXFIFO;
N  __I  uint32_t I2SRXFIFO;
X  volatile const  uint32_t I2SRXFIFO;
N  __I  uint32_t I2SSTATE;
X  volatile const  uint32_t I2SSTATE;
N  __IO uint32_t I2SDMA1;
X  volatile uint32_t I2SDMA1;
N  __IO uint32_t I2SDMA2;
X  volatile uint32_t I2SDMA2;
N  __IO uint32_t I2SIRQ;
X  volatile uint32_t I2SIRQ;
N  __IO uint32_t I2STXRATE;
X  volatile uint32_t I2STXRATE;
N  __IO uint32_t I2SRXRATE;
X  volatile uint32_t I2SRXRATE;
N  __IO uint32_t I2STXBITRATE;
X  volatile uint32_t I2STXBITRATE;
N  __IO uint32_t I2SRXBITRATE;
X  volatile uint32_t I2SRXBITRATE;
N  __IO uint32_t I2STXMODE;
X  volatile uint32_t I2STXMODE;
N  __IO uint32_t I2SRXMODE;
X  volatile uint32_t I2SRXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint8_t  RICTRL;
X  volatile uint8_t  RICTRL;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  WDMOD;
X  volatile uint8_t  WDMOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t WDTC;
X  volatile uint32_t WDTC;
N  __O  uint8_t  WDFEED;
X  volatile  uint8_t  WDFEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t WDTV;
X  volatile const  uint32_t WDTV;
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t ADCR;
X  volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N       uint32_t RESERVED0;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile const  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile const  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile const  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile const  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile const  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile const  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile const  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile const  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile const  uint32_t ADSTAT;
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DACR;
X  volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t MCCON;
X  volatile const  uint32_t MCCON;
N  __O  uint32_t MCCON_SET;
X  volatile  uint32_t MCCON_SET;
N  __O  uint32_t MCCON_CLR;
X  volatile  uint32_t MCCON_CLR;
N  __I  uint32_t MCCAPCON;
X  volatile const  uint32_t MCCAPCON;
N  __O  uint32_t MCCAPCON_SET;
X  volatile  uint32_t MCCAPCON_SET;
N  __O  uint32_t MCCAPCON_CLR;
X  volatile  uint32_t MCCAPCON_CLR;
N  __IO uint32_t MCTIM0;
X  volatile uint32_t MCTIM0;
N  __IO uint32_t MCTIM1;
X  volatile uint32_t MCTIM1;
N  __IO uint32_t MCTIM2;
X  volatile uint32_t MCTIM2;
N  __IO uint32_t MCPER0;
X  volatile uint32_t MCPER0;
N  __IO uint32_t MCPER1;
X  volatile uint32_t MCPER1;
N  __IO uint32_t MCPER2;
X  volatile uint32_t MCPER2;
N  __IO uint32_t MCPW0;
X  volatile uint32_t MCPW0;
N  __IO uint32_t MCPW1;
X  volatile uint32_t MCPW1;
N  __IO uint32_t MCPW2;
X  volatile uint32_t MCPW2;
N  __IO uint32_t MCDEADTIME;
X  volatile uint32_t MCDEADTIME;
N  __IO uint32_t MCCCP;
X  volatile uint32_t MCCCP;
N  __IO uint32_t MCCR0;
X  volatile uint32_t MCCR0;
N  __IO uint32_t MCCR1;
X  volatile uint32_t MCCR1;
N  __IO uint32_t MCCR2;
X  volatile uint32_t MCCR2;
N  __I  uint32_t MCINTEN;
X  volatile const  uint32_t MCINTEN;
N  __O  uint32_t MCINTEN_SET;
X  volatile  uint32_t MCINTEN_SET;
N  __O  uint32_t MCINTEN_CLR;
X  volatile  uint32_t MCINTEN_CLR;
N  __I  uint32_t MCCNTCON;
X  volatile const  uint32_t MCCNTCON;
N  __O  uint32_t MCCNTCON_SET;
X  volatile  uint32_t MCCNTCON_SET;
N  __O  uint32_t MCCNTCON_CLR;
X  volatile  uint32_t MCCNTCON_CLR;
N  __I  uint32_t MCINTFLAG;
X  volatile const  uint32_t MCINTFLAG;
N  __O  uint32_t MCINTFLAG_SET;
X  volatile  uint32_t MCINTFLAG_SET;
N  __O  uint32_t MCINTFLAG_CLR;
X  volatile  uint32_t MCINTFLAG_CLR;
N  __O  uint32_t MCCAP_CLR;
X  volatile  uint32_t MCCAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t QEICON;
X  volatile  uint32_t QEICON;
N  __I  uint32_t QEISTAT;
X  volatile const  uint32_t QEISTAT;
N  __IO uint32_t QEICONF;
X  volatile uint32_t QEICONF;
N  __I  uint32_t QEIPOS;
X  volatile const  uint32_t QEIPOS;
N  __IO uint32_t QEIMAXPOS;
X  volatile uint32_t QEIMAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP;
X  volatile uint32_t INXCMP;
N  __IO uint32_t QEILOAD;
X  volatile uint32_t QEILOAD;
N  __I  uint32_t QEITIME;
X  volatile const  uint32_t QEITIME;
N  __I  uint32_t QEIVEL;
X  volatile const  uint32_t QEIVEL;
N  __I  uint32_t QEICAP;
X  volatile const  uint32_t QEICAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t QEIIEC;
X  volatile  uint32_t QEIIEC;
N  __O  uint32_t QEIIES;
X  volatile  uint32_t QEIIES;
N  __I  uint32_t QEIINTSTAT;
X  volatile const  uint32_t QEIINTSTAT;
N  __I  uint32_t QEIIE;
X  volatile const  uint32_t QEIIE;
N  __O  uint32_t QEICLR;
X  volatile  uint32_t QEICLR;
N  __O  uint32_t QEISET;
X  volatile  uint32_t QEISET;
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t CANTxSR;
X  volatile const  uint32_t CANTxSR;
N  __I  uint32_t CANRxSR;
X  volatile const  uint32_t CANRxSR;
N  __I  uint32_t CANMSR;
X  volatile const  uint32_t CANMSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t DMACIntStat;
X  volatile const  uint32_t DMACIntStat;
N  __I  uint32_t DMACIntTCStat;
X  volatile const  uint32_t DMACIntTCStat;
N  __O  uint32_t DMACIntTCClear;
X  volatile  uint32_t DMACIntTCClear;
N  __I  uint32_t DMACIntErrStat;
X  volatile const  uint32_t DMACIntErrStat;
N  __O  uint32_t DMACIntErrClr;
X  volatile  uint32_t DMACIntErrClr;
N  __I  uint32_t DMACRawIntTCStat;
X  volatile const  uint32_t DMACRawIntTCStat;
N  __I  uint32_t DMACRawIntErrStat;
X  volatile const  uint32_t DMACRawIntErrStat;
N  __I  uint32_t DMACEnbldChns;
X  volatile const  uint32_t DMACEnbldChns;
N  __IO uint32_t DMACSoftBReq;
X  volatile uint32_t DMACSoftBReq;
N  __IO uint32_t DMACSoftSReq;
X  volatile uint32_t DMACSoftSReq;
N  __IO uint32_t DMACSoftLBReq;
X  volatile uint32_t DMACSoftLBReq;
N  __IO uint32_t DMACSoftLSReq;
X  volatile uint32_t DMACSoftLSReq;
N  __IO uint32_t DMACConfig;
X  volatile uint32_t DMACConfig;
N  __IO uint32_t DMACSync;
X  volatile uint32_t DMACSync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t DMACCSrcAddr;
X  volatile uint32_t DMACCSrcAddr;
N  __IO uint32_t DMACCDestAddr;
X  volatile uint32_t DMACCDestAddr;
N  __IO uint32_t DMACCLLI;
X  volatile uint32_t DMACCLLI;
N  __IO uint32_t DMACCControl;
X  volatile uint32_t DMACCControl;
N  __IO uint32_t DMACCConfig;
X  volatile uint32_t DMACCConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t HcRevision;             /* USB Host Registers                 */
X  volatile const  uint32_t HcRevision;              
N  __IO uint32_t HcControl;
X  volatile uint32_t HcControl;
N  __IO uint32_t HcCommandStatus;
X  volatile uint32_t HcCommandStatus;
N  __IO uint32_t HcInterruptStatus;
X  volatile uint32_t HcInterruptStatus;
N  __IO uint32_t HcInterruptEnable;
X  volatile uint32_t HcInterruptEnable;
N  __IO uint32_t HcInterruptDisable;
X  volatile uint32_t HcInterruptDisable;
N  __IO uint32_t HcHCCA;
X  volatile uint32_t HcHCCA;
N  __I  uint32_t HcPeriodCurrentED;
X  volatile const  uint32_t HcPeriodCurrentED;
N  __IO uint32_t HcControlHeadED;
X  volatile uint32_t HcControlHeadED;
N  __IO uint32_t HcControlCurrentED;
X  volatile uint32_t HcControlCurrentED;
N  __IO uint32_t HcBulkHeadED;
X  volatile uint32_t HcBulkHeadED;
N  __IO uint32_t HcBulkCurrentED;
X  volatile uint32_t HcBulkCurrentED;
N  __I  uint32_t HcDoneHead;
X  volatile const  uint32_t HcDoneHead;
N  __IO uint32_t HcFmInterval;
X  volatile uint32_t HcFmInterval;
N  __I  uint32_t HcFmRemaining;
X  volatile const  uint32_t HcFmRemaining;
N  __I  uint32_t HcFmNumber;
X  volatile const  uint32_t HcFmNumber;
N  __IO uint32_t HcPeriodicStart;
X  volatile uint32_t HcPeriodicStart;
N  __IO uint32_t HcLSTreshold;
X  volatile uint32_t HcLSTreshold;
N  __IO uint32_t HcRhDescriptorA;
X  volatile uint32_t HcRhDescriptorA;
N  __IO uint32_t HcRhDescriptorB;
X  volatile uint32_t HcRhDescriptorB;
N  __IO uint32_t HcRhStatus;
X  volatile uint32_t HcRhStatus;
N  __IO uint32_t HcRhPortStatus1;
X  volatile uint32_t HcRhPortStatus1;
N  __IO uint32_t HcRhPortStatus2;
X  volatile uint32_t HcRhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t OTGIntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t OTGIntSt;                
N  __IO uint32_t OTGIntEn;
X  volatile uint32_t OTGIntEn;
N  __O  uint32_t OTGIntSet;
X  volatile  uint32_t OTGIntSet;
N  __O  uint32_t OTGIntClr;
X  volatile  uint32_t OTGIntClr;
N  __IO uint32_t OTGStCtrl;
X  volatile uint32_t OTGStCtrl;
N  __IO uint32_t OTGTmr;
X  volatile uint32_t OTGTmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t USBDevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t USBDevIntSt;             
N  __IO uint32_t USBDevIntEn;
X  volatile uint32_t USBDevIntEn;
N  __O  uint32_t USBDevIntClr;
X  volatile  uint32_t USBDevIntClr;
N  __O  uint32_t USBDevIntSet;
X  volatile  uint32_t USBDevIntSet;
N
N  __O  uint32_t USBCmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t USBCmdCode;              
N  __I  uint32_t USBCmdData;
X  volatile const  uint32_t USBCmdData;
N
N  __I  uint32_t USBRxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t USBRxData;               
N  __O  uint32_t USBTxData;
X  volatile  uint32_t USBTxData;
N  __I  uint32_t USBRxPLen;
X  volatile const  uint32_t USBRxPLen;
N  __O  uint32_t USBTxPLen;
X  volatile  uint32_t USBTxPLen;
N  __IO uint32_t USBCtrl;
X  volatile uint32_t USBCtrl;
N  __O  uint32_t USBDevIntPri;
X  volatile  uint32_t USBDevIntPri;
N
N  __I  uint32_t USBEpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t USBEpIntSt;              
N  __IO uint32_t USBEpIntEn;
X  volatile uint32_t USBEpIntEn;
N  __O  uint32_t USBEpIntClr;
X  volatile  uint32_t USBEpIntClr;
N  __O  uint32_t USBEpIntSet;
X  volatile  uint32_t USBEpIntSet;
N  __O  uint32_t USBEpIntPri;
X  volatile  uint32_t USBEpIntPri;
N
N  __IO uint32_t USBReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t USBReEp;                 
N  __O  uint32_t USBEpInd;
X  volatile  uint32_t USBEpInd;
N  __IO uint32_t USBMaxPSize;
X  volatile uint32_t USBMaxPSize;
N
N  __I  uint32_t USBDMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t USBDMARSt;               
N  __O  uint32_t USBDMARClr;
X  volatile  uint32_t USBDMARClr;
N  __O  uint32_t USBDMARSet;
X  volatile  uint32_t USBDMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t USBUDCAH;
X  volatile uint32_t USBUDCAH;
N  __I  uint32_t USBEpDMASt;
X  volatile const  uint32_t USBEpDMASt;
N  __O  uint32_t USBEpDMAEn;
X  volatile  uint32_t USBEpDMAEn;
N  __O  uint32_t USBEpDMADis;
X  volatile  uint32_t USBEpDMADis;
N  __I  uint32_t USBDMAIntSt;
X  volatile const  uint32_t USBDMAIntSt;
N  __IO uint32_t USBDMAIntEn;
X  volatile uint32_t USBDMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t USBEoTIntSt;
X  volatile const  uint32_t USBEoTIntSt;
N  __O  uint32_t USBEoTIntClr;
X  volatile  uint32_t USBEoTIntClr;
N  __O  uint32_t USBEoTIntSet;
X  volatile  uint32_t USBEoTIntSet;
N  __I  uint32_t USBNDDRIntSt;
X  volatile const  uint32_t USBNDDRIntSt;
N  __O  uint32_t USBNDDRIntClr;
X  volatile  uint32_t USBNDDRIntClr;
N  __O  uint32_t USBNDDRIntSet;
X  volatile  uint32_t USBNDDRIntSet;
N  __I  uint32_t USBSysErrIntSt;
X  volatile const  uint32_t USBSysErrIntSt;
N  __O  uint32_t USBSysErrIntClr;
X  volatile  uint32_t USBSysErrIntClr;
N  __O  uint32_t USBSysErrIntSet;
X  volatile  uint32_t USBSysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_WO;
X  volatile  uint32_t I2C_WO;
N  };
N  __I  uint32_t I2C_STS;
X  volatile const  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __IO uint32_t RxFilterWoLStatus;
X  volatile uint32_t RxFilterWoLStatus;
N  __IO uint32_t RxFilterWoLClear;
X  volatile uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N#pragma no_anon_unions
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART0_TypeDef     *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N#endif  // __LPC17xx_H__
L 26 "app\cfg\../../drivers/drivers.h" 2
N
N/* app */
Nextern volatile uint32_t g_current_tick;
Nextern volatile uint32_t g_motor_start_tick;
N//extern volatile uint32_t g_led_indicate_get_tick;
N//extern uint8_t g_MotorCheckFlag;
N
N/* bsp */
N#include "../bsp/bsp.h"
L 1 "app\cfg\../../drivers/../bsp/bsp.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : bsp.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-07-28 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    Begginning of application   
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __BSP_H__
N#define __BSP_H__
N
N/* Includes ------------------------------------------------------------------*/
N#include "libdef.h"
L 1 "app\cfg\../../drivers/../bsp/libdef.h" 1
N#ifndef __LIB_DEF_H__
N#define __LIB_DEF_H__
N
N/* ------------------- BIT DEFINES -------------------- */
N#define  DEF_BIT_NONE                                   0x00u
N
N#define  DEF_BIT_00                                     0x01u
N#define  DEF_BIT_01                                     0x02u
N#define  DEF_BIT_02                                     0x04u
N#define  DEF_BIT_03                                     0x08u
N#define  DEF_BIT_04                                     0x10u
N#define  DEF_BIT_05                                     0x20u
N#define  DEF_BIT_06                                     0x40u
N#define  DEF_BIT_07                                     0x80u
N
N#define  DEF_BIT_08                                   0x0100u
N#define  DEF_BIT_09                                   0x0200u
N#define  DEF_BIT_10                                   0x0400u
N#define  DEF_BIT_11                                   0x0800u
N#define  DEF_BIT_12                                   0x1000u
N#define  DEF_BIT_13                                   0x2000u
N#define  DEF_BIT_14                                   0x4000u
N#define  DEF_BIT_15                                   0x8000u
N
N#define  DEF_BIT_16                               0x00010000u
N#define  DEF_BIT_17                               0x00020000u
N#define  DEF_BIT_18                               0x00040000u
N#define  DEF_BIT_19                               0x00080000u
N#define  DEF_BIT_20                               0x00100000u
N#define  DEF_BIT_21                               0x00200000u
N#define  DEF_BIT_22                               0x00400000u
N#define  DEF_BIT_23                               0x00800000u
N
N#define  DEF_BIT_24                               0x01000000u
N#define  DEF_BIT_25                               0x02000000u
N#define  DEF_BIT_26                               0x04000000u
N#define  DEF_BIT_27                               0x08000000u
N#define  DEF_BIT_28                               0x10000000u
N#define  DEF_BIT_29                               0x20000000u
N#define  DEF_BIT_30                               0x40000000u
N#define  DEF_BIT_31                               0x80000000u
N
N
N#define  DEF_ABS(a)                               (((a) < 0) ? (-(a)) : (a))
N
N#define  DEF_TRUE                                 0
N#define  DEF_FALSE                                1
N
N#endif
N
L 19 "app\cfg\../../drivers/../bsp/bsp.h" 2
N
N/* public define -------------------------------------------------------------*/
N/* for GPIO DIR */ 
N/* 32bit Access */
N#define  FIO0DIR							(*(volatile unsigned int *)(0x2009C000)) 
N#define  FIO1DIR							(*(volatile unsigned int *)(0x2009C020))
N#define  FIO2DIR							(*(volatile unsigned int *)(0x2009C040))
N#define  FIO3DIR							(*(volatile unsigned int *)(0x2009C060))
N#define  FIO4DIR							(*(volatile unsigned int *)(0x2009C080))
N/* 8bit Access */																				 
N#define  FIO2DIR0							(*(volatile unsigned char*)(0x2009C040)) 
N
N/* for GPIO MASK */
N#define  FIO0MASK							(*(volatile unsigned int *)(0x2009C010))
N#define  FIO1MASK							(*(volatile unsigned int *)(0x2009C030))
N#define  FIO2MASK							(*(volatile unsigned int *)(0x2009C050))
N#define  FIO3MASK							(*(volatile unsigned int *)(0x2009C070))
N#define  FIO4MASK							(*(volatile unsigned int *)(0x2009C090))
N
N/* for GPIO value register */
N/* 32bit Access */
N#define  FIO0PIN							(*(volatile unsigned int *)(0x2009C014)) 
N#define  FIO1PIN							(*(volatile unsigned int *)(0x2009C034))
N#define  FIO2PIN							(*(volatile unsigned int *)(0x2009C054))
N#define  FIO3PIN							(*(volatile unsigned int *)(0x2009C074))
N#define  FIO4PIN							(*(volatile unsigned int *)(0x2009C094))
N/* 8bit Access */
N#define  FIO2PIN0							(*(volatile unsigned char*)(0x2009C054)) 
N
N/* for GPIO SET */
N#define  FIO0SET							(*(volatile unsigned int *)(0x2009C018))
N#define  FIO1SET							(*(volatile unsigned int *)(0x2009C038))
N#define  FIO2SET							(*(volatile unsigned int *)(0x2009C058))
N#define  FIO3SET							(*(volatile unsigned int *)(0x2009C078))
N#define  FIO4SET							(*(volatile unsigned int *)(0x2009C098))
N
N/* for GPIO CLR */
N#define  FIO0CLR							(*(volatile unsigned int *)(0x2009C01C))
N#define  FIO1CLR							(*(volatile unsigned int *)(0x2009C03C))
N#define  FIO2CLR							(*(volatile unsigned int *)(0x2009C05C))
N#define  FIO3CLR							(*(volatile unsigned int *)(0x2009C07C))
N#define  FIO4CLR							(*(volatile unsigned int *)(0x2009C09C))
N
N/* for pin select register */
N#define  PINSEL0							(*(volatile unsigned int *)(0x4002C000))
N#define  PINSEL1							(*(volatile unsigned int *)(0x4002C004))
N#define  PINSEL2							(*(volatile unsigned int *)(0x4002C008))
N#define  PINSEL3							(*(volatile unsigned int *)(0x4002C00c))
N#define  PINSEL4							(*(volatile unsigned int *)(0x4002C010))
N#define  PINSEL5							(*(volatile unsigned int *)(0x4002C014))
N#define  PINSEL6							(*(volatile unsigned int *)(0x4002C018))
N#define  PINSEL7							(*(volatile unsigned int *)(0x4002C01c))
N#define  PINSEL8							(*(volatile unsigned int *)(0x4002C020))
N#define  PINSEL9							(*(volatile unsigned int *)(0x4002C024))
N#define  PINSEL10							(*(volatile unsigned int *)(0x4002C028))
N
N#define  PINMODE0							(*(volatile unsigned int *)(0x4002C040))
N#define  PINMODE1							(*(volatile unsigned int *)(0x4002C044))
N#define  PINMODE2							(*(volatile unsigned int *)(0x4002C048))
N#define  PINMODE3							(*(volatile unsigned int *)(0x4002C04c))
N#define  PINMODE4							(*(volatile unsigned int *)(0x4002C050))
N#define  PINMODE7							(*(volatile unsigned int *)(0x4002C05C))
N#define  PINMODE9							(*(volatile unsigned int *)(0x4002C064))
N
N/* EXTERN Function Prototypes ------------------------------------------------*/
Nextern unsigned int CPU_SR_Save(void);
Nextern void CPU_SR_Restore(unsigned int cpu_sr);
N
N/* public define -------------------------------------------------------------*/
N#define  CPU_SR_ALLOC()        unsigned int  cpu_sr = (unsigned int)0;
N#define  CPU_CRITICAL_ENTER()  {cpu_sr = CPU_SR_Save();}
N#define  CPU_CRITICAL_EXIT()   {CPU_SR_Restore(cpu_sr);}
N
N#endif
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N
L 35 "app\cfg\../../drivers/drivers.h" 2
N
N/* drivers */
N#include "drivers_def.h"
L 1 "app\cfg\../../drivers/drivers_def.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : drivers.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-03-03 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx derivers define         
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __DRIVERS_DEF_H__
N#define __DRIVERS_DEF_H__
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *p_obj
N*
N*                           FnctName(p_obj);
N*********************************************************************************************************
N*/
N
N#define __W610_OFDM__
N//#define __W610_GRC__
N//#define __W610_CB__
N
N#if defined( __W610_OFDM__ )
X#if 1L
N    #define __CAN1_ENABLE__     (1)
N//    #define __CAN2_ENABLE__     (0)
N      #define __CAN1_PIN021_PIN022__
N//		#define __CAN1_PIN000_PIN001__
N//    #define __CAN2_PIN207_PIN208__
N#elif defined( __W610_GRC__ )
S    #define __USB_ENABLE__      (1)
S#elif defined( __W610_CB__ )
S    #define __CAN1_ENABLE__     (1)
S
N#endif
N
Ntypedef            void        CPU_VOID;
Ntypedef            char        CPU_CHAR;                        /*  8-bit character                                     */
Ntypedef  unsigned  char        CPU_BOOLEAN;                     /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char        CPU_INT08U;                      /*  8-bit unsigned integer                              */
Ntypedef    signed  char        CPU_INT08S;                      /*  8-bit   signed integer                              */
Ntypedef  unsigned  short       CPU_INT16U;                      /* 16-bit unsigned integer                              */
Ntypedef    signed  short       CPU_INT16S;                      /* 16-bit   signed integer                              */
Ntypedef  unsigned  int         CPU_INT32U;                      /* 32-bit unsigned integer                              */
Ntypedef    signed  int         CPU_INT32S;                      /* 32-bit   signed integer                              */
Ntypedef  unsigned  long  long  CPU_INT64U;                      /* 64-bit unsigned integer                              */
Ntypedef    signed  long  long  CPU_INT64S;                      /* 64-bit   signed integer                              */
N
Ntypedef            float       CPU_FP32;                        /* 32-bit floating point                                */
Ntypedef            double      CPU_FP64;                        /* 64-bit floating point                                */
N
N
Ntypedef  volatile  CPU_INT08U  CPU_REG08;                       /*  8-bit register                                      */
Ntypedef  volatile  CPU_INT16U  CPU_REG16;                       /* 16-bit register                                      */
Ntypedef  volatile  CPU_INT32U  CPU_REG32;                       /* 32-bit register                                      */
Ntypedef  volatile  CPU_INT64U  CPU_REG64;                       /* 64-bit register                                      */
N
N
Ntypedef            void      (*CPU_FNCT_VOID)(void);            /* See Note #2a.                                        */
Ntypedef            void      (*CPU_FNCT_PTR )(void *);          /* See Note #2b.                                        */
N
N
N/* Exported define -----------------------------------------------------------*/
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
N
N/* Status type definition */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N/* brief Flag Status and Interrupt Flag Status type definition */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
N
N/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/
N#endif
L 38 "app\cfg\../../drivers/drivers.h" 2
N#include "gpio/lpc17xx_gpio.h"
L 1 "app\cfg\../../drivers/gpio/lpc17xx_gpio.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       xp60.uvproj
N  * @File Name          : lpc17xx_clkpwr_ctl.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-01-27 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx clock and power control        
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __LPC17XX_GPIO_H__
N#define __LPC17XX_GPIO_H__
N
N/* Includes ------------------------------------------------------------------*/
N
N/* Exported define -----------------------------------------------------------*/
N/*         GPIO related register         */
N/* GPIO PINSEL REGISTER GROUP */
N#define  GPIO_REG_PINSEL_BASE_ADDR                             (CPU_INT32U  )(0x4002C000)
N
N#define  GPIO_REG_PINSEL0                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x00)
N#define  GPIO_REG_PINSEL1                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x04)
N#define  GPIO_REG_PINSEL2                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x08)
N#define  GPIO_REG_PINSEL3                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x0C)
N#define  GPIO_REG_PINSEL4                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x10)
N#define  GPIO_REG_PINSEL5                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x14)
N#define  GPIO_REG_PINSEL6                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x18)
N#define  GPIO_REG_PINSEL7                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x1C)
N#define  GPIO_REG_PINSEL8                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x20)
N#define  GPIO_REG_PINSEL9                                      (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x24)
N#define  GPIO_REG_PINSEL10                                     (*(CPU_REG32 *)GPIO_REG_PINSEL_BASE_ADDR + 0x28)
N
N/* GPIO PINMODE REGISTER GROUP */
N#define  GPIO_REG_PINMODE_BASE_ADDR                            (CPU_INT32U  )(0x4002C040)
N
N#define  GPIO_REG_PINMODE0                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x00)
N#define  GPIO_REG_PINMODE1                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x04)
N#define  GPIO_REG_PINMODE2                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x08)
N#define  GPIO_REG_PINMODE3                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x0C)
N#define  GPIO_REG_PINMODE4                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x10)
N#define  GPIO_REG_PINMODE5                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x14)
N#define  GPIO_REG_PINMODE6                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x18)
N#define  GPIO_REG_PINMODE7                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x1C)
N#define  GPIO_REG_PINMODE8                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x20)
N#define  GPIO_REG_PINMODE9                                     (*(CPU_REG32 *)GPIO_REG_PINMODE_BASE_ADDR + 0x24)
N
N/* GPIO PORTx_FAST REGISTER GROUP */
N#define  GPIO_REG_PORTx_FAST_BASE_ADDR                         ((CPU_INT32U)0x2009C000)
N#define  GPIO_REG_PORT0_FAST_BASE_ADDR                         ((CPU_INT32U)(GPIO_REG_PORTx_FAST_BASE_ADDR + 0x00))
N#define  GPIO_REG_PORT1_FAST_BASE_ADDR                         ((CPU_INT32U)(GPIO_REG_PORTx_FAST_BASE_ADDR + 0x20))
N#define  GPIO_REG_PORT2_FAST_BASE_ADDR                         ((CPU_INT32U)(GPIO_REG_PORTx_FAST_BASE_ADDR + 0x40))
N#define  GPIO_REG_PORT3_FAST_BASE_ADDR                         ((CPU_INT32U)(GPIO_REG_PORTx_FAST_BASE_ADDR + 0x60))
N#define  GPIO_REG_PORT4_FAST_BASE_ADDR                         ((CPU_INT32U)(GPIO_REG_PORTx_FAST_BASE_ADDR + 0x80))
N
N#define  GPIO_REG_PINMODE_ODx_BASE_ADDR                        ((CPU_INT32U)GPIO_REG_PINMODE_BASE_ADDR + 0x28)
N#define  GPIO_REG_PINMODE_OD0_BASE_ADDR                        ((CPU_INT32U)(GPIO_REG_PINMODE_ODx_BASE_ADDR + 0x00))
N#define  GPIO_REG_PINMODE_OD1_BASE_ADDR                        ((CPU_INT32U)(GPIO_REG_PINMODE_ODx_BASE_ADDR + 0x04))
N#define  GPIO_REG_PINMODE_OD2_BASE_ADDR                        ((CPU_INT32U)(GPIO_REG_PINMODE_ODx_BASE_ADDR + 0x08))
N#define  GPIO_REG_PINMODE_OD3_BASE_ADDR                        ((CPU_INT32U)(GPIO_REG_PINMODE_ODx_BASE_ADDR + 0x0C))
N#define  GPIO_REG_PINMODE_OD4_BASE_ADDR                        ((CPU_INT32U)(GPIO_REG_PINMODE_ODx_BASE_ADDR + 0x10))
N
N///* for GPIO DIR */ 
N///* 32bit Access */
N//#define  FIO0DIR							(*(__IO CPU_INT32U *)(0x2009C000)) 
N//#define  FIO1DIR							(*(__IO CPU_INT32U *)(0x2009C020))
N//#define  FIO2DIR							(*(__IO CPU_INT32U *)(0x2009C040))
N//#define  FIO3DIR							(*(__IO CPU_INT32U *)(0x2009C060))
N//#define  FIO4DIR							(*(__IO CPU_INT32U *)(0x2009C080))
N///* 8bit Access */																				 
N//#define  FIO2DIR0							(*(__IO CPU_INT08U *)(0x2009C040)) 
N//
N///* for GPIO MASK */
N//#define  FIO0MASK							(*(__IO CPU_INT32U *)(0x2009C010))
N//#define  FIO1MASK							(*(__IO CPU_INT32U *)(0x2009C030))
N//#define  FIO2MASK							(*(__IO CPU_INT32U *)(0x2009C050))
N//#define  FIO3MASK							(*(__IO CPU_INT32U *)(0x2009C070))
N//#define  FIO4MASK							(*(__IO CPU_INT32U *)(0x2009C090))
N//
N///* for GPIO value register */
N///* 32bit Access */
N//#define  FIO0PIN							(*(__IO CPU_INT32U *)(0x2009C014)) 
N//#define  FIO1PIN							(*(__IO CPU_INT32U *)(0x2009C034))
N//#define  FIO2PIN							(*(__IO CPU_INT32U *)(0x2009C054))
N//#define  FIO3PIN							(*(__IO CPU_INT32U *)(0x2009C074))
N//#define  FIO4PIN							(*(__IO CPU_INT32U *)(0x2009C094))
N///* 8bit Access */
N//#define  FIO2PIN0							(*(__IO CPU_INT08U *)(0x2009C054)) 
N//
N///* for GPIO SET */
N//#define  FIO0SET							(*(__IO CPU_INT32U *)(0x2009C018))
N//#define  FIO1SET							(*(__IO CPU_INT32U *)(0x2009C038))
N//#define  FIO2SET							(*(__IO CPU_INT32U *)(0x2009C058))
N//#define  FIO3SET							(*(__IO CPU_INT32U *)(0x2009C078))
N//#define  FIO4SET							(*(__IO CPU_INT32U *)(0x2009C098))
N//
N///* for GPIO CLR */
N//#define  FIO0CLR							(*(__IO CPU_INT32U *)(0x2009C01C))
N//#define  FIO1CLR							(*(__IO CPU_INT32U *)(0x2009C03C))
N//#define  FIO2CLR							(*(__IO CPU_INT32U *)(0x2009C05C))
N//#define  FIO3CLR							(*(__IO CPU_INT32U *)(0x2009C07C))
N//#define  FIO4CLR							(*(__IO CPU_INT32U *)(0x2009C09C))
N//
N///* for pin select register */
N//#define  PINSEL0							(*(__IO CPU_INT32U *)(0x4002C000))
N//#define  PINSEL1							(*(__IO CPU_INT32U *)(0x4002C004))
N//#define  PINSEL2							(*(__IO CPU_INT32U *)(0x4002C008))
N//#define  PINSEL3							(*(__IO CPU_INT32U *)(0x4002C00c))
N//#define  PINSEL4							(*(__IO CPU_INT32U *)(0x4002C010))
N//#define  PINSEL5							(*(__IO CPU_INT32U *)(0x4002C014))
N//#define  PINSEL6							(*(__IO CPU_INT32U *)(0x4002C018))
N//#define  PINSEL7							(*(__IO CPU_INT32U *)(0x4002C01c))
N//#define  PINSEL8							(*(__IO CPU_INT32U *)(0x4002C020))
N//#define  PINSEL9							(*(__IO CPU_INT32U *)(0x4002C024))
N//#define  PINSEL10							(*(__IO CPU_INT32U *)(0x4002C028))
N
N
N/* for GPIO inttrupt */
N#define  REG_IOIntStatus				    (*(__IO CPU_INT32U *)  (0x40028080))
N
N#define  REG_IO0IntEnR				    	(*(__IO CPU_INT32U *)  (0x40028090))
N#define  REG_IO2IntEnR                      (*(__IO CPU_INT32U *)  (0x400280B0)) 	 
N#define  REG_IO0IntEnF				    	(*(__IO CPU_INT32U *)  (0x40028094))
N#define  REG_IO2IntEnF				    	(*(__IO CPU_INT32U *)  (0x400280B4))
N
N#define  REG_IO0IntStatR				    (*(__IO CPU_INT32U *)  (0x40028084))
N#define  REG_IO2IntStatR				    (*(__IO CPU_INT32U *)  (0x400280A4))
N#define  REG_IO0IntStatF				    (*(__IO CPU_INT32U *)  (0x40028088))
N#define  REG_IO2IntStatF				    (*(__IO CPU_INT32U *)  (0x400280A8))
N
N#define  REG_IO0IntClr				    	(*(__IO CPU_INT32U *)  (0x4002808C))
N#define  REG_IO2IntClr				    	(*(__IO CPU_INT32U *)  (0x400280AC))
N
N
N/* GPIO constants */
N#define  GPIO_PORT0                                    0
N#define  GPIO_PORT1                                    1
N#define  GPIO_PORT0_FAST                               2
N#define  GPIO_PORT1_FAST                               3
N#define  GPIO_PORT2_FAST                               4
N#define  GPIO_PORT3_FAST                               5
N#define  GPIO_PORT4_FAST                               6
N
N
N#define  GPIO_OPT_NONE                       DEF_BIT_NONE
N#define  GPIO_OPT_OUT_EN                     DEF_BIT_01
N#define  GPIO_OPT_IN_EN                      DEF_BIT_02
N#define  GPIO_OPT_RD_WR_EN                   DEF_BIT_03
N#define  GPIO_OPT_RD_WR_DIS                  DEF_BIT_04
N
N#define  GPIO_OPT_FNCT_1                     DEF_BIT_05
N#define  GPIO_OPT_FNCT_2                     DEF_BIT_06
N#define  GPIO_OPT_FNCT_3                     DEF_BIT_07
N#define  GPIO_OPT_FNCT_4                     DEF_BIT_08
N
N#define  GPIO_OPT_MODE_PULLUP                DEF_BIT_09
N#define  GPIO_OPT_MODE_RESERVED              DEF_BIT_10
N#define  GPIO_OPT_MODE_NONE                  DEF_BIT_11
N#define  GPIO_OPT_MODE_PULLDOWN              DEF_BIT_12
N#define  GPIO_OPT_MODE_REPEATER              DEF_BIT_13
N#define  GPIO_OPT_MODE_OPEN_DRAIN            DEF_BIT_14
N
N#define  GPIO_OPT_FNCT_ANY                                     (GPIO_OPT_FNCT_1 | \
N                                                                    GPIO_OPT_FNCT_2 | \
N                                                                    GPIO_OPT_FNCT_3 | \
N                                                                    GPIO_OPT_FNCT_4)
X#define  GPIO_OPT_FNCT_ANY                                     (GPIO_OPT_FNCT_1 |                                                                     GPIO_OPT_FNCT_2 |                                                                     GPIO_OPT_FNCT_3 |                                                                     GPIO_OPT_FNCT_4)
N
N#define  GPIO_OPT_MODE_ANY                                     (GPIO_OPT_MODE_PULLUP   | \
N                                                                    GPIO_OPT_MODE_NONE     | \
N                                                                    GPIO_OPT_MODE_PULLDOWN | \
N                                                                    GPIO_OPT_MODE_REPEATER | \
N                                                                    GPIO_OPT_MODE_OPEN_DRAIN)
X#define  GPIO_OPT_MODE_ANY                                     (GPIO_OPT_MODE_PULLUP   |                                                                     GPIO_OPT_MODE_NONE     |                                                                     GPIO_OPT_MODE_PULLDOWN |                                                                     GPIO_OPT_MODE_REPEATER |                                                                     GPIO_OPT_MODE_OPEN_DRAIN)
N
N#define  GPIO_OPT_MODE_INVALID                                  0xFF
N#define  GPIO_OPT_FNCT_INVALID                                  0xFF
N
N/* for GPIO interrupt set ----------------------------------------------------*/
N/* for GPIO interrupt set */
N#define  EDGE_STATE_R                        0
N#define  EDGE_STATE_F            			 0x01u
N
N/* GPIO Interrupt pin define */
N#define  GPIO_INT0_PROT      0
N#define  GPIO_INT2_PROT      2u
N
N/* GPIO overrall interruppt Status */
N#define  IOINTSTATUS_P0		 DEF_BIT_00
N#define  IOINTSTATUS_P2		 DEF_BIT_02
N
N/* */
N#define  IO2IntStatR_P
N
N/*  */
N
N/* Function Prototypes -------------------------------------------------------*/
Nvoid GPIO_Init(void);
N
Nvoid         GPIO_Cfg         (unsigned char   gpio_port,
N                                   unsigned int   gpio_pin,
N                                   unsigned short   gpio_opt);
Nvoid         GPIO_Clr         (CPU_INT08U   gpio_port,
N                                   CPU_INT32U   gpio_pin);
Nvoid         GPIO_Set         (CPU_INT08U   gpio_port,
N                                   CPU_INT32U   gpio_pin);
N
Nvoid         GPIO_Toggle      (CPU_INT08U   gpio_port,
N                                   CPU_INT32U   gpio_pin);
N
NCPU_INT32U   GPIO_StatusGet   (CPU_INT08U   gpio_port);
N
Nvoid         GPIO_IntCmd      (CPU_INT08U gpio_port, 
N                               CPU_INT32U gpio_pin, 
N							   CPU_INT08U edgeState);
N
NCPU_INT32U   GPIO_GetIntStatus(CPU_INT08U gpio_port, 
N                               CPU_INT32U gpio_pin, 
N							   CPU_INT08U edgeState);
N
Nvoid         GPIO_ClearInt    (CPU_INT08U gpio_port, 
N                               CPU_INT32U gpio_pin);
N
N
N
N
N/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/    
N#endif                                                          /* End of module include.                               */
L 39 "app\cfg\../../drivers/drivers.h" 2
N#include "clkpwr/lpc17xx_clkpwr_ctl.h"
L 1 "app\cfg\../../drivers/clkpwr/lpc17xx_clkpwr_ctl.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       xp60.uvproj
N  * @File Name          : lpc17xx_clkpwr_ctl.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-01-27 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx clock and power control        
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __LPC17XX_CLKPWR_CTL_H__
N#define __LPC17XX_CLKPWR_CTL_H__
N
N/* Exported constants --------------------------------------------------------*/
N
N/* Clock Source Defines */
N#define  OSC_MAIN_OSC_FREQ_HZ               12000000L
N#define  OSC_INT_RC_FREQ_HZ                  4000000L
N#define  OSC_RTC_FREQ_HZ                        32768
N
N/* CPU Power Modes */
N#define  CPU_MODE_NORMAL                            0
N#define  CPU_MODE_PWR_DOWN                          1
N#define  CPU_MODE_IDLE                              2
N#define  CPU_MODE_SLEEP                             3
N
N/* Peripheral Number in PCONP and PCLKSEL */
N/*
N * Note(s) : (1) Some peripheral bit numbers doesn't match between the Power Coontrol for periphreal (PCONP) 
N *               register and the Peripheral Clock Selection register (PCLKSEL0/1)
N *
N *               For example the bit 15 in the PCONP register is for GPIO clock, but in the PCLKSEL0 register bits 30:31 
N *               (uses two bit per peripheral) is for CAN acceptance filtering (ACF). 
N *
N *               To solve this inconsistency SYS_CTRL_PER_NBR_GPIO and  SYS_CTRL_PER_NBR_PCLKSEL_ACF are defined
N *               to the same value. 
N *
N *               - SYS_CTRL_PER_NBR_GPIO  should be used with SysCtrl_PerClkDis() and SysCtrl_PerClkEn() 
N *                 functions.
N *
N *               - SYS_CTRL_PER_NBR_PCLKSEL_ACF should be used with SysCtrl_PerClkFreqCfg() and 
N *                 SysCtrl_PerClkFreqCfg() functions.
N */
N#define  PER_NBR_WDT                                0   /* Watchdog Timer                                     */
N#define  PER_NBR_RESERVED0                          0   /* Reserved                                           */
N
N#define  PER_NBR_TMR0                               1   /* Timer 0                                            */
N#define  PER_NBR_TMR1                               2   /* Timer 1                                            */
N#define  PER_NBR_UART0                              3   /* UART 0                                             */
N#define  PER_NBR_UART1                              4   /* UART 1                                             */
N
N#define  PER_NBR_RESERVED1                          5   /* Reserved                                           */
N#define  PER_NBR_PCLKSEL_RESERVED0                  5   /* Reserved (Peripheral Clock Selection)              */
N
N#define  PER_NBR_PWM1                               6   /* PWM1                                               */
N#define  PER_NBR_I2C0                               7   /* I2C 0                                              */
N#define  PER_NBR_SPI0                               8   /* SPI 0                                              */
N
N#define  PER_NBR_RTC                                9   /* RTC                                                */
N#define  PER_NBR_PCLKSEL_RESERVED1                  9   /* Reserved (Peripheral Clock Selection)              */
N
N#define  PER_NBR_SSP1                              10   /* SSP 1                                              */
N#define  PER_NBR_RESERVED2                         11   /* Reserved                                           */
N#define  PER_NBR_AD0                               12   /* A/D converter                                      */
N#define  PER_NBR_CAN1                              13   /* CAN 1                                              */
N#define  PER_NBR_CAN2                              14   /* CAN 2                                              */
N
N#define  PER_NBR_GPIO                              15   /* GPIO                                               */
N#define  PER_NBR_PCLKSEL_ACF                       15   /* CAN filtering. (Peripheral Clock Selection)        */
N
N#define  PER_NBR_RIT                               16   /* Repetitive Interrupt Timer                         */
N#define  PER_NBR_PCLKSEL_QEI                       16   /* QEI (Peripheral Clock Selection)                   */
N
N#define  PER_NBR_MCPWM                             17   /* Motor Control PWM                                  */
N#define  PER_NBR_PCLKSEL_GPIOINT                   17   /* QEI (Peripheral Clock Selection)                   */
N
N#define  PER_NBR_QEI                               18   /* Quadrature Encoder Interface                       */
N#define  PER_NBR_PCLKSEL_PCB                       18   /* Pin Connect Block (Peripheral Clock Selection)     */
N
N#define  PER_NBR_I2C1                              19   /* I2C1                                               */
N
N#define  PER_NBR_RESERVED3                         20   /* Reserved                                           */
N#define  PER_NBR_PCLKSEL_RESERVED2                 20   /* Reserved (Peripheral Clock Selection)              */
N
N#define  PER_NBR_SSP0                              21   /* SSP0                                               */
N#define  PER_NBR_TMR2                              22   /* TIMER 2                                            */
N#define  PER_NBR_TMR3                              23   /* TIMER 3                                            */
N#define  PER_NBR_UART2                             24   /* UART 2                                             */
N#define  PER_NBR_UART3                             25   /* UART 3                                             */
N#define  PER_NBR_I2C2                              26   /* I2C 2                                              */
N#define  PER_NBR_I2S                               27   /* I2S                                                */
N#define  PER_NBR_RESERVED4                         28   /* Reserved                                           */
N#define  PER_NBR_PCLKSEL_RESERVED3                 28   /* Reserved (Peripheral Clock Selection)              */
N
N
N#define  PER_NBR_GPDMA                             29   /* GP DMA function                                    */
N#define  PER_NBR_PCLKSEL_RIT                       29   /* RIT (Peripheral Clock Selection)                   */
N
N#define  PER_NBR_ENET                              30   /* Ethernet Controller                                */
N#define  PER_NBR_PCLKSEL_SYSCON                    30   /* Sytem Control Block (Peripheral Clock Selection)   */
N
N#define  PER_NBR_USB                               31   /* USB                                                */
N#define  PER_NBR_PCLKSEL_MCPWM                     31   /* Motor Control PWM (Peripheral Clock Selection)     */
N
N/* SYSTEM CONTROL AND STATUS REGISTER & BIT DEFINES --------------------------*/
N/* SYSTEM CONTROL REGISTER BASE ADDRESS DEFINES */
N#define  REG_SCS                             (*(CPU_REG32 *)(0x400FC1A0))
N
N#define  BIT_SCS_OSCRANGE                    DEF_BIT_04
N#define  BIT_SCS_OSCEN                       DEF_BIT_05
N#define  BIT_SCS_OSCSTAT                     DEF_BIT_06
N
N/* CLOCK DIVIDERS REGISTER & BIT DEFINES */
N#define  REG_CCLKCFG                         (*(CPU_REG32 *)(0x400FC104))
N#define  REG_USBCLKCFG                       (*(CPU_REG32 *)(0x400FC108))
N#define  REG_IRCTRIM                         (*(CPU_REG32 *)(0x400FC1A4))
N#define  REG_PCLKSEL0                        (*(CPU_REG32 *)(0x400FC1A8))
N#define  REG_PCLKSEL1                        (*(CPU_REG32 *)(0x400FC1AC))
N/* CLOCK SOURCE SELECT REGISTER DEFINE */
N#define  REG_CLKSRCSEL                       (*(CPU_REG32 *)(0x400FC10C))
N
N/* PLL REGISTER AND POWER CONTROL --------------------------------------------*/
N/* PLL REGISTER BASE ADDRESS DEFINES */
N#define  REG_PLL_BASE_ADDR                   (CPU_INT32U )0x400FC080
N
N#define  REG_PLLCTRL(pll_id)                 (*(CPU_REG32 *)(REG_PLL_BASE_ADDR + (0x20 * pll_id) + 0x00))
N#define  REG_PLLCFG(pll_id)                  (*(CPU_REG32 *)(REG_PLL_BASE_ADDR + (0x20 * pll_id) + 0x04))
N#define  REG_PLLSTAT(pll_id)                 (*(CPU_REG32 *)(REG_PLL_BASE_ADDR + (0x20 * pll_id) + 0x08))
N#define  REG_PLLFEED(pll_id)                 (*(CPU_REG32 *)(REG_PLL_BASE_ADDR + (0x20 * pll_id) + 0x0C))
N
N/* for PLL Control */
N#define  BIT_PLLCTRL_PLLE                    DEF_BIT_00     /* PLL enable                                           */
N#define  BIT_PLLCTRL_PLLC                    DEF_BIT_01     /* PLL connect                                          */
N
N/* for PLL0 State  */
N#define  BIT_PLLSTAT_PLL0_MSEL_MASK          DEF_BIT_FIELD(15,  0)
N#define  BIT_PLLSTAT_PLL0_PSEL_MASK          DEF_BIT_FIELD(8 , 16)
N#define  BIT_PLLSTAT_PLLE0_STAT              DEF_BIT_24     /* Read-back for the PLL0 enable bit                     */
N#define  BIT_PLLSTAT_PLLC0_STAT              DEF_BIT_25     /* Read-back for the PLL0 connect bit                    */
N#define  BIT_PLLSTAT_PLOCK0                  DEF_BIT_26     /* Refkect the PLL0 lock status                          */
N
N/* for PLL1 State*/
N#define  BIT_PLLSTAT_PLLE1_STAT              DEF_BIT_08     /* Read-back for the PLL1 enable bit                     */
N#define  BIT_PLLSTAT_PLLC1_STAT              DEF_BIT_09     /* Read-back for the PLL1 connect bit                    */
N#define  BIT_PLLSTAT_PLOCK1                  DEF_BIT_10     /* Refkect the PLL1 lock status                          */
N
N/* PLL FEED VALUE */
N#define  BIT_PLLFEED_VAL0                   (CPU_INT32U)(0x000000AA)
N#define  BIT_PLLFEED_VAL1                   (CPU_INT32U)(0x00000055)
N
N/* POWER CONTROL REGISTER DEFINES */
N#define  REG_PCON                            (*(CPU_REG32 *)(0x400FC0C0))
N#define  REG_PCONP                           (*(CPU_REG32 *)(0x400FC0C4))
N
N/* APB DIVIDER REGISTER BIT DEFINES */
N#define  BIT_APBDIV_MASK                     DEF_BIT_FIELD(2, 0)
N#define  BIT_APBDIV_4                        DEF_BIT_NONE
N#define  BIT_APBDIV_1                        DEF_BIT_MASK(1, 0)
N#define  BIT_APBDIV_2                        DEF_BIT_MASK(2, 0)
N
N/* --- FLASH ACCELERATOR CFG REGISTER & BIT DEFINES --- */
N#define  REG_FLASHCFG                        (*(CPU_REG32 *)(0x400FC000))      
N
N#define  REG_FLASHCFG_CLK_1                  DEF_BIT_MASK(1, 12)
N#define  REG_FLASHCFG_CLK_2                  DEF_BIT_MASK(2, 12)
N#define  REG_FLASHCFG_CLK_3                  DEF_BIT_MASK(3, 12)
N#define  REG_FLASHCFG_CLK_4                  DEF_BIT_MASK(4, 12)
N#define  REG_FLASHCFG_CLK_5                  DEF_BIT_MASK(5, 12)
N#define  REG_FLASHCFG_CLK_6                  DEF_BIT_MASK(6, 12)
N
N/* Function Prototypes -------------------------------------------------------*/
NCPU_BOOLEAN  LPC17xx_System_Init (void);
N
NCPU_INT32U   CPU_FreqGet    (void);
N
Nvoid         PerClkEn       (CPU_INT08U  per_nbr);
Nvoid         PerClkDis      (CPU_INT08U  per_nbr);
NCPU_INT32U   PerClkFreqGet  (CPU_INT08U  per_nbr);
N/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/
N#endif 
L 40 "app\cfg\../../drivers/drivers.h" 2
N#include "uart/lpc17xx_uart.h"
L 1 "app\cfg\../../drivers/uart/lpc17xx_uart.h" 1
N/**
N  ******************** (C) COPYRIGHT 2012 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : lpc17xx_uart.c
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2012-05-24 
N  * @Version            : 1.10 
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx uart module functions        
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __LPC17XX_UART_H__
N#define __LPC17XX_UART_H__
N
N/* EXTERNS -------------------------------------------------------------------*/
N#ifdef   UART_MODULE
S#define  EXT
N#else
N#define  EXT  extern
N#endif
N
N/* Private define ------------------------------------------------------------*/
N/* uart enable */
N//#ifdef __DEBUG_UART2_PRINTF__
N//#define UART0_EN   1
N//#else
N//#define UART0_EN   0
N//#endif
N#define UART0_EN   1
N#define UART1_EN   1
N#define UART2_EN   1
N#define UART3_EN   1
N
N/* uart pin bit field */
N#define UART0_PINS                 (DEF_BIT_02 | DEF_BIT_03)
N#define UART1_PINS                 (DEF_BIT_15 | DEF_BIT_16)
N#define UART2_PINS				   (DEF_BIT_11 | DEF_BIT_10)   /* P0.10,P0.11,FUNC2 -- RXD2,TXD2 */
N//#define UART3_PINS                 (DEF_BIT_29 | DEF_BIT_28) /* P4.29,P4.28,FUNC4 -- RXD3,TXD3 */
N#define UART3_PINS                 (DEF_BIT_00 | DEF_BIT_01)  /* P0.0,P0.1,FUNC3 -- RXD3,TXD3 */
N
N/* LCR REGISTER bit field */
N/* Divisor Latch Access Bit */
N#define SET_DLAB                   DEF_BIT_07
N#define CLR_DLAB                   DEF_BIT_NONE
N
N/* FCR bit field & bit mask & bit set */  
N#define FCR_FE                      0u         
N#define FCR_RFR                     1u	  
N#define FCR_TFR                     2u	  
N#define FCR_RTLS                    6u
N
N#define FIFO_ENABLE              	DEF_BIT_00
N#define RX_FIFO_RESET               DEF_BIT_01	  
N#define TX_FIFO_RESET               DEF_BIT_02
N	  
N#define RX_TRI_LS0                  DEF_BIT_NONE
N#define RX_TRI_LS1                  DEF_BIT_06
N#define RX_TRI_LS2                  DEF_BIT_07
N#define RX_TRI_LS3                  (DEF_BIT_06 | DEF_BIT_07)	  
N
N/* FDR div and mul bit filed */
N#define FDR_DIVADDVAL 	 0	  /* DIVADDVAL 3:0 */  
N#define FDR_MULVAL	     4	  /* MULVAL 4:7    */
N
N/* LSR bit filed */
N#define LSR_RDR                    DEF_BIT_00
N#define LSR_OE			           DEF_BIT_01
N#define LSR_PE			           DEF_BIT_02
N#define LSR_FE			           DEF_BIT_03
N#define LSR_BI			           DEF_BIT_04
N#define LSR_THRE		           DEF_BIT_05
N#define LSR_TEMT		           DEF_BIT_06
N#define LSR_RXFE		           DEF_BIT_07
N
N/* IER bit filed  */
N#define IER_RBR_EN				   DEF_BIT_00
N#define IER_THRE_EN				   DEF_BIT_01
N#define IER_RXLS_EN				   DEF_BIT_02
N
N/* Macro defines for Macro defines for UART interrupt identification register */
N#define UART_IIR_INTSTAT_PEND	   ((uint32_t)(1<<0))	/*!<Interrupt Status - Active low */
N#define UART_IIR_INTID_RLS		   ((uint32_t)(3<<1)) 	/*!<Interrupt identification: Receive line status*/
N#define UART_IIR_INTID_RDA		   ((uint32_t)(2<<1)) 	/*!<Interrupt identification: Receive data available*/
N#define UART_IIR_INTID_CTI		   ((uint32_t)(6<<1)) 	/*!<Interrupt identification: Character time-out indicator*/
N#define UART_IIR_INTID_THRE		   ((uint32_t)(1<<1)) 	/*!<Interrupt identification: THRE interrupt*/
N#define UART1_IIR_INTID_MODEM	   ((uint32_t)(0<<1)) 	/*!<Interrupt identification: Modem interrupt*/
N#define UART_IIR_INTID_MASK		   ((uint32_t)(7<<1))	/*!<Interrupt identification: Interrupt ID mask */
N#define UART_IIR_FIFO_EN		   ((uint32_t)(3<<6)) 	/*!<These bits are equivalent to UnFCR[0] */
N#define UART_IIR_ABEO_INT		   ((uint32_t)(1<<8)) 	/*!< End of auto-baud interrupt */
N#define UART_IIR_ABTO_INT		   ((uint32_t)(1<<9)) 	/*!< Auto-baud time-out interrupt */
N#define UART_IIR_BITMASK		   ((uint32_t)(0x3CF))	/*!< UART interrupt identification register bit mask */
N
N
N/* Exported typedef ----------------------------------------------------------*/
N/* uart init struct */
Ntypedef struct
N{
N    uint32_t UART_BaudRate;
N	uint16_t UART_WordLength;
N	uint16_t UART_StopBits;
N    uint16_t UART_Parity;
N    uint16_t UART_Mode;
N    uint16_t UART_HardwareFlowControl;
N}UART_InitTypeDef;
N
N/* uart send or recieve ring buffer */
Ntypedef struct
N{
N    uint32_t volatile wrIdx;
N	uint32_t volatile rdIdx;
N	uint32_t          mask;
N	uint8_t          *pBuf;
N}RING_BUF;
N
N/*  */
N#define RING_BUF_IS_FULL(ring_buf)      ((ring_buf.wrIdx+1)&ring_buf.mask == (ring_buf.rdIdx)&ring_buf.mask) /* Check buf is full or not */
N#define RING_BUF_IS_EMPTY(ring_buf)     ((ring_buf.wrIdx&ring_buf.mask) == (ring_buf.rdIdx&ring_buf.mask))   /* Check buf is empty       */
N#define RING_BUF_COUNT(ring_buf)        ((ring_buf.wrIdx - ring_buf.rdIdx)&ring_buf.mask)                    /* get buf count  */
N#define RING_BUF_RD(ring_buf)           (ring_buf.pBuf[ring_buf.rdIdx++&ring_buf.mask])                      /* get one byte   */
N#define RING_BUF_WR(ring_buf,DataIn) 	(ring_buf.pBuf[ring_buf.wrIdx++&ring_buf.mask] = DataIn)             /* write one byte */
N
N
N/* Exported variables --------------------------------------------------------*/
N#if UART0_EN > 0
X#if 1 > 0
N#define TX_BUFFER_SIZE0 256
N#define RX_BUFFER_SIZE0 256
N
NEXT RING_BUF UART0_tx_buf;
Xextern RING_BUF UART0_tx_buf;
NEXT RING_BUF UART0_rx_buf;
Xextern RING_BUF UART0_rx_buf;
N
NEXT uint8_t tx_buffer0[TX_BUFFER_SIZE0];
Xextern uint8_t tx_buffer0[256];
NEXT uint8_t rx_buffer0[RX_BUFFER_SIZE0];
Xextern uint8_t rx_buffer0[256];
N#endif 
N
N#if UART1_EN > 0
X#if 1 > 0
N#define TX_BUFFER_SIZE1 256
N#define RX_BUFFER_SIZE1 256
N
NEXT RING_BUF UART1_tx_buf;
Xextern RING_BUF UART1_tx_buf;
NEXT RING_BUF UART1_rx_buf;
Xextern RING_BUF UART1_rx_buf;
N
NEXT uint8_t tx_buffer1[TX_BUFFER_SIZE1];
Xextern uint8_t tx_buffer1[256];
NEXT uint8_t rx_buffer1[RX_BUFFER_SIZE1];
Xextern uint8_t rx_buffer1[256];
N#endif 
N
N#if UART2_EN > 0
X#if 1 > 0
N#define TX_BUFFER_SIZE2 512
N#define RX_BUFFER_SIZE2 512
N
NEXT RING_BUF UART2_tx_buf;
Xextern RING_BUF UART2_tx_buf;
NEXT RING_BUF UART2_rx_buf;
Xextern RING_BUF UART2_rx_buf;
NEXT RING_BUF UART2_rx_buf_copy;
Xextern RING_BUF UART2_rx_buf_copy;
N
NEXT uint8_t tx_buffer2[TX_BUFFER_SIZE2];
Xextern uint8_t tx_buffer2[512];
NEXT uint8_t rx_buffer2[RX_BUFFER_SIZE2];
Xextern uint8_t rx_buffer2[512];
NEXT uint8_t rx_buffer2_copy[RX_BUFFER_SIZE2];
Xextern uint8_t rx_buffer2_copy[512];
N
N#endif
N
N#if UART3_EN > 0
X#if 1 > 0
N#define TX_BUFFER_SIZE3 256
N#define RX_BUFFER_SIZE3 256
N
NEXT RING_BUF UART3_tx_buf;
Xextern RING_BUF UART3_tx_buf;
NEXT RING_BUF UART3_rx_buf;
Xextern RING_BUF UART3_rx_buf;
N
NEXT uint8_t tx_buffer3[TX_BUFFER_SIZE3];
Xextern uint8_t tx_buffer3[256];
NEXT uint8_t rx_buffer3[RX_BUFFER_SIZE3];
Xextern uint8_t rx_buffer3[256];
N#endif
N
N/* Function Prototypes -------------------------------------------------------*/
Nvoid UARTS_Init(void);
N
N
N#if UART0_EN > 0
X#if 1 > 0
Nvoid UART0_BufClr(void);
N/* polling */
Nvoid UART0_putchar(uint8_t c);
Nuint8_t UART0_getchar(void);
N
Nvoid UART0_SendByte(uint8_t data);
Nuint8_t UART0_ReicieveByte(void);
N
Nvoid UART0_send_pack(uint8_t *buf,uint16_t len);
N#endif
N
N#if UART1_EN > 0
X#if 1 > 0
Nvoid UART1_BufClr(void);
N/* polling */
Nvoid UART1_putchar(uint8_t c);
Nuint8_t UART1_getchar(void);
N
Nvoid UART1_SendByte(uint8_t data);
Nuint8_t UART1_ReicieveByte(void);
N
Nvoid UART1_send_pack(uint8_t *buf,uint16_t len);
N
N//#define RS485_WR()  LPC_GPIO1->FIOSET|=1<< 14
N//#define RS485_RD()  LPC_GPIO1->FIOCLR|=1<< 14
N#endif
N
N#if UART2_EN > 0
X#if 1 > 0
Nvoid UART2_BufClr(void);
N/* polling */
Nvoid UART2_putchar(uint8_t c);
Nuint8_t UART2_getchar(void);
N
Nvoid UART2_SendByte(uint8_t data);
Nuint8_t UART2_ReicieveByte(void);
N
Nvoid UART2_send_pack(uint8_t *buf,uint16_t len);
N
N#define Radar_RS485_WR()  LPC_GPIO1->FIOSET|=1<< 0
N#define Radar_RS485_RD()  LPC_GPIO1->FIOCLR|=1<< 0
N#endif
N
N#if UART3_EN > 0
X#if 1 > 0
Nvoid UART3_BufClr(void);
N/* polling */
Nvoid UART3_putchar(uint8_t c);
Nuint8_t UART3_getchar(void);
N
Nvoid UART3_SendByte(uint8_t data);
Nuint8_t UART3_ReicieveByte(void);
Nvoid UART3_send_pack(uint8_t *buf,uint16_t len);
N#endif
Nvoid uart_printf(uint8_t uart_n,char *pstr, ...);
Nvoid TX_RX1_ON(void);
Nvoid TX_RX2_ON(void);
Nvoid uart_swtich_init(void);
N
N/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/
N#endif
L 41 "app\cfg\../../drivers/drivers.h" 2
N#include "timer/lpc17xx_timer.h"
L 1 "app\cfg\../../drivers/timer/lpc17xx_timer.h" 1
N#ifndef __LPC17XX_TIMER_H
N#define __LPC17XX_TIMER_H
N
N#include "lpc17xx.h"
N
Nvoid TIMER0_Init( void );
Nvoid TIMER0_Start( void );
Nvoid TIMER0_Stop( void );
Nvoid TIMER0_Reset( void );
N
Nuint8_t TIMER0_1Ms_Timeout( void );
N
Nvoid TIMER1_Init( void );
Nvoid TIMER1_Start( void );
Nvoid TIMER1_Stop( void );
N
Nvoid TIMER2_Init( void );
N
N#define TIMER2_START  LPC_TIM2->TC = 0 ; LPC_TIM2->TCR = 0x01
N#define TIMER2_STOP 	LPC_TIM2->TCR &= ~0x01
N
N#endif
L 42 "app\cfg\../../drivers/drivers.h" 2
N#include "wdt/lpc17xx_wdt.h"
L 1 "app\cfg\../../drivers/wdt/lpc17xx_wdt.h" 1
N#ifndef __LPC17XX_WDT_H__
N#define __LPC17XX_WDT_H__
N
N#include "..\drivers.h"
L 1 "app\cfg\../../drivers/wdt/..\drivers.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : drivers.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-01-27 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx on chip peripheral derivers        
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __DRIVERS_H__
S#define __DRIVERS_H__
S
S/* Includes ------------------------------------------------------------------*/
S/* STANDARD LIBRARIES */
S#include  <string.h>
S#include  <stdarg.h>
S#include  <stdio.h>
S#include  <stdlib.h>
S#include <LPC17xx.h>
S
S/* app */
Sextern volatile uint32_t g_current_tick;
Sextern volatile uint32_t g_motor_start_tick;
S//extern volatile uint32_t g_led_indicate_get_tick;
S//extern uint8_t g_MotorCheckFlag;
S
S/* bsp */
S#include "../bsp/bsp.h"
S
S/* drivers */
S#include "drivers_def.h"
S#include "gpio/lpc17xx_gpio.h"
S#include "clkpwr/lpc17xx_clkpwr_ctl.h"
S#include "uart/lpc17xx_uart.h"
S#include "timer/lpc17xx_timer.h"
S#include "wdt/lpc17xx_wdt.h"
S#include "user_led.h"	
S#include "user_interrupt.h"
S#include "user_pwm.h"
S#include "user_sensor.h"
S#include "adc/lpc17xx_adc.h"
S#define MOTOR_NUM  2
S#define ArgBoardFirmwareVersion (0x010407ff)// 19
S/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/
N#endif
L 5 "app\cfg\../../drivers/wdt/lpc17xx_wdt.h" 2
N
Nvoid WDT_Init( void );
Nvoid WDT_Start( uint32_t ms );
Nvoid WDT_Feed( void );
Nvoid WDT_UpdateTimeOut( uint32_t ms );
Nuint32_t WDT_GetCurrentCount( void );
Nuint8_t WDT_ResetCheck( void );
Nvoid WDT_Lock( void );
Nvoid WDT_UnLock( void );
N
N#endif
L 43 "app\cfg\../../drivers/drivers.h" 2
N#include "user_led.h"	
L 1 "app\cfg\../../drivers/user_led.h" 1
N
N#ifndef __USER_LED_H__
N#define __USER_LED_H__
N#define LED_GREEN_TOGGLE   LPC_GPIO0->FIOPIN^=1<< 5
N#define LED_GREEN_ON       LPC_GPIO0->FIOCLR|=1<< 5
N#define LED_GREEN_OFF      LPC_GPIO0->FIOSET|=1<< 5
N
N//#define LED_RED_TOGGLE   LPC_GPIO2->FIOPIN^=1<< 11
N//#define LED_RED_ON       LPC_GPIO2->FIOCLR|=1<< 11
N//#define LED_RED_OFF      LPC_GPIO2->FIOSET|=1<< 11
N
Nvoid LedInit( void );
N
N#endif
L 44 "app\cfg\../../drivers/drivers.h" 2
N#include "user_interrupt.h"
L 1 "app\cfg\../../drivers/user_interrupt.h" 1
N
N#ifndef __USER_INTERRUPT_H__
N#define __USER_INTERRUPT_H__
N#include <LPC17xx.h>
N#include "stdint.h"
N
Nvoid Interrupt_Init( void );
N
N
Nextern uint32_t g_u32PluseCnt1;
Nextern uint32_t g_u32PluseCnt2;
N
N//extern uint16_t g_Distance ;
Nextern uint32_t g_SonarGetTime;
N#include "cfg_decoder.h"
L 1 ".\app\cfg\cfg_decoder.h" 1
N#ifndef __CFG_DECODER_H
N#define __CFG_DECODER_H
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 6 ".\app\cfg\cfg_decoder.h" 2
N
Ntypedef struct {
N    uint8_t     step;
N	uint16_t    idx;
N    uint16_t    len;
N    uint16_t    max;
N    uint8_t     ver;
N	uint8_t     *p_data;
N} cfg_decoder_object_t;
N
Nvoid cfg_decoder_init( cfg_decoder_object_t *obj, uint8_t *p, uint16_t max );
Nbool cfg_decoder_upack( cfg_decoder_object_t *obj, uint8_t data );
X_Bool cfg_decoder_upack( cfg_decoder_object_t *obj, uint8_t data );
Nvoid  Flow_Sensor_Unpack( cfg_decoder_object_t *obj, uint8_t data );
Nuint8_t get_control_flag(void);
N#endif
L 16 "app\cfg\../../drivers/user_interrupt.h" 2
Nbool radar_upack( cfg_decoder_object_t *obj, uint8_t data );
X_Bool radar_upack( cfg_decoder_object_t *obj, uint8_t data );
N
Nvoid flow_cali_enble(void);
Nvoid flow_cali_clear(void);
Nuint32_t get_cali_flow_pulses_total(void);
Nuint16_t get_cali_flow_freq(void);
Nuint32_t get_cail_flow_time(void);
N#endif
L 45 "app\cfg\../../drivers/drivers.h" 2
N#include "user_pwm.h"
L 1 "app\cfg\../../drivers/user_pwm.h" 1
N#ifndef __USER_PWM_H__
N#define __USER_PWM_H__
N
N#include <LPC17xx.h>
N#include "stdint.h"
N
N#define MIN_CNT   940
N#define MAX_CNT   2000
N
N//#define Get_Spary_Limit_Value(MIN_SPRAY_ID)    1230
N//#define MAX_SPARY    1360
N
N#define MAX_FLOW 127
N#define MIN_FLOW 20
N
N#define STOP_PWM  100000
N#define MIN_PWM   115000
N#define MAX_PWM   200000
N
Nvoid User_PWM_Init(void);
Nvoid Set_Pwm_Value(uint8_t persent);
N
N//void SetPWM(uint8_t num , uint32_t persent);
N
N#define WAIT_SET_H2L_TIMEOUT(time)  ( (SetPWMFrom_H2L > 0 )&& (g_current_tick - SetPWMFrom_H2L > time) )
N#define WAIT_SET_FROM_ZERO( time )  ( /*(SetPWMFrom_Zero > 0 )&&*/ (g_current_tick - SetPWMFrom_Zero > time) )
N#endif
L 46 "app\cfg\../../drivers/drivers.h" 2
N#include "user_sensor.h"
L 1 "app\cfg\../../drivers/user_sensor.h" 1
N#ifndef __USER_SENSOR_H__
N#define __USER_SENSOR_H__
N
N#include <LPC17xx.h>
N#include "stdint.h"
N
N
N//
N#define Pump_Normal     0 
N#define Pipe_Blockage   1
N#define Air_In_The_Pipe 2
N#define Sensor_Failure  3
N
N#define Press_Sensor_0 0
N#define Press_Sensor_1 1
N
N#define Data_Exists_Flag 0x55
N
N#define State_Normal  0
N#define State_Warning 1
N#define State_Err     2
N
N
N
N#define Temperature_Warning  110
N#define Temperature_Err      130
N
N
N//typedef __packed struct {
N//	uint8_t save_flag; // 0x55 ,  
N//	__packed struct {
N//	uint8_t  need_cali_flag;// 0:; 1  
N//	uint16_t throttle_value_min; // 
N//	uint16_t throttle_value_default;
N//	uint16_t throttle_value_max;
N//	uint16_t pressure_user; // 
N//	}pressure_sensor0;
N//	
N//	__packed struct {
N//	uint8_t  need_cali_flag;// 0:; 1  
N//	uint16_t throttle_value_min; // 
N//	uint16_t throttle_value_default;
N//	uint16_t throttle_value_max;
N//	uint16_t pressure_user; // 
N//	}pressure_sensor1;	
N//}spray_system_pressure_cali_para_t;
N
N/**   **/
Ntypedef __packed struct {
N	uint8_t save_flag; // 0x55 ,  
N	uint8_t  need_cali_flag;// 0:; 1  
N	uint16_t throttle_value_min; // 
N	uint16_t throttle_value_default;
N	uint16_t throttle_value_max;
N	uint16_t pressure_user; // 
N}spray_system_pressure_cali_para_t;
N
N
N
Ntypedef __packed struct {
N	uint8_t   save_flag; // 0x55 ,  
N	uint8_t   cali_freq; // 
N	uint16_t  capacity;// 
N	uint32_t  cali_pulses; // 
N	uint32_t  cali_time; // 
N
N}spray_system_flow_cali_para_t;
N
N
N
N#define WORKING_PRESSURE_MIN    		1260//  0.20MP  sensor  adc value 1450mv 
N#define WORKING_PRESSURE_MAX    		1750//  0.33MP  sensor  adc value 1750mv 
N#define WORKING_PRESSURE_DEFAULT    1630//  0.30MP  sensor  adc value 1660mv 
N//#define SLOPE_DEFAULT 71.45
N
N#define MAX_SPRAY_ID 1
N#define MIN_SPRAY_ID 2
N#define DEBUG_FLOW_LEVEL
N
N#define flow_cali_idle 0 
N#define flow_cali_complted 1 
N#define flow_cali_failed   2 
N#define flow_cali_working  3
N
Nuint16_t get_buf_min_value(uint16_t buf[],uint16_t data_num);
Nuint16_t get_capacity_by_level_sensor(uint8_t liquid_level);
Nfloat get_temperature(uint16_t tempe_sensor_value);
N//uint16_t get_capacity_by_potentiometer(uint16_t potentiometer_value);
Nvoid capacity_by_flow_sensor(void);
Nuint16_t get_press_value(uint8_t id);
Nfloat get_flow_value(uint16_t freq);
Nvoid press_sensor_handle(void);
Nuint16_t Set_FOC2_Value_By_Pressure1(uint16_t start_foc_value ,uint16_t target_pressure_value);
Nuint16_t Set_FOC1_Value_By_Pressure0(uint16_t start_foc_value ,uint16_t target_pressure_value);
Nvoid spray_system_press_para_init_check(void);
Nvoid spray_sysem_flow_para_init_check(void);
Nvoid flow2_calibration_process(void);
N
N//uint8_t pressure_check_process(uint8_t sensor_id);// 10hz 
Nvoid pressure1_calibration_process(void);// 
Nvoid pressure2_calibration_process(void);// 
N//uint16_t flow_sensor_test(uint8_t run_flag); // 10hz
Nvoid level_sensor_init(void);
Nvoid level_data_process(void);
Nuint8_t get_capacity_flag_1L(void);
Nvoid set_flow_cali_flag(uint8_t state);
Nvoid Set_Spary_Limit_Value(uint8_t foc_id,uint8_t value_id ,uint16_t value );
Nuint16_t Get_Spary_Limit_Value(uint8_t foc_id,uint8_t value_id);
Nvoid set_cali_capaciy(uint16_t value);
Nuint16_t get_current_capacity_d(void);
Nuint8_t get_flow_value_total(void);
Nvoid Set_Volume_Each_Pulse(float value);
Nvoid flow1_calibration_process(void);
Nvoid flow2_calibration_process(void);
Nuint8_t Get_XT100_State(void);
Nuint8_t Get_XT90_State(void);
Nvoid temperature_sensor_handle(void);
Nvoid spray_residual_volume_init_check(void);
Nvoid set_MedeRunoutFlag(uint8_t state);
Nuint8_t get_pump1_state(void);
Nuint8_t get_pump2_state(void);
N#define User_Max_Throttle 1700
N//extern uint8_t pipe_status;
N#endif
L 47 "app\cfg\../../drivers/drivers.h" 2
N#include "adc/lpc17xx_adc.h"
L 1 "app\cfg\../../drivers/adc/lpc17xx_adc.h" 1
N/**
N  ******************** (C) COPYRIGHT 2010 DJI **********************************
N  *
N  * @Project Name       xp60.uvproj
N  * @File Name          : lpc17xx_wdt.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-08-25 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    lpc17xx wdt module,reference for nxp        
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __LPC17XX_ADC_H__
N#define __LPC17XX_ADC_H__
N
N/* Includes ------------------------------------------------------------------- */
N#include "..\drivers.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Private macros ------------------------------------------------------------- */
N#define ADC0_PIN_PORT_0_3           (GPIO_PORT0_FAST)
N#define ADC_CH0_PIN                 DEF_BIT_23        /*p0.23 FNCT2 -- AD0.0*/
N#define ADC_CH1_PIN					DEF_BIT_24		  /*p0.24 FNCT2 -- AD0.1*/
N#define ADC_CH2_PIN                 DEF_BIT_25        /*p0.25 FNCT2 -- AD0.2*/
N#define ADC_CH3_PIN					DEF_BIT_26		  /*p0.26 FNCT2 -- AD0.3*/
N
N#define ADC0_PIN_PORT_6_7           (GPIO_PORT0_FAST)
N#define ADC_CH6_PIN                 DEF_BIT_03        /*p0.3  FNCT3 -- AD0.6*/
N#define ADC_CH7_PIN					DEF_BIT_02		  /*p0.2  FNCT3 -- AD0.7*/
N
N#define ADC0_PIN_PORT_4_5           (GPIO_PORT1_FAST)
N#define ADC_CH4_PIN                 DEF_BIT_30        /*p1.30 FNCT3 -- AD0.4*/
N#define ADC_CH5_PIN					DEF_BIT_31		  /*p1.31 FNCT3 -- AD0.5*/
N
N
N
N
N/* -------------------------- BIT DEFINITIONS ----------------------------------- */
N/*********************************************************************//**
N * Macro defines for ADC  control register
N **********************************************************************/
N/**  Selects which of the AD0.0:7 pins is (are) to be sampled and converted */
N#define ADC_CR_CH_SEL(n)	((1UL << n))
N/**  The APB clock (PCLK) is divided by (this value plus one)
N* to produce the clock for the A/D */
N#define ADC_CR_CLKDIV(n)	((n<<8))
N/**  Repeated conversions A/D enable bit */
N#define ADC_CR_BURST		((1UL<<16))
N/**  ADC convert in power down mode */
N#define ADC_CR_PDN			((1UL<<21))
N/**  Start mask bits */
N#define ADC_CR_START_MASK	((7UL<<24))
N/**  Select Start Mode */
N#define ADC_CR_START_MODE_SEL(SEL)	((SEL<<24))
N/**  Start conversion now */
N#define ADC_CR_START_NOW	((1UL<<24))
N/**  Start conversion when the edge selected by bit 27 occurs on P2.10/EINT0 */
N#define ADC_CR_START_EINT0	((2UL<<24))
N/** Start conversion when the edge selected by bit 27 occurs on P1.27/CAP0.1 */
N#define ADC_CR_START_CAP01	((3UL<<24))
N/**  Start conversion when the edge selected by bit 27 occurs on MAT0.1 */
N#define ADC_CR_START_MAT01	((4UL<<24))
N/**  Start conversion when the edge selected by bit 27 occurs on MAT0.3 */
N#define ADC_CR_START_MAT03	((5UL<<24))
N/**  Start conversion when the edge selected by bit 27 occurs on MAT1.0 */
N#define ADC_CR_START_MAT10	((6UL<<24))
N/**  Start conversion when the edge selected by bit 27 occurs on MAT1.1 */
N#define ADC_CR_START_MAT11	((7UL<<24))
N/**  Start conversion on a falling edge on the selected CAP/MAT signal */
N#define ADC_CR_EDGE			((1UL<<27))
N
N/*********************************************************************//**
N * Macro defines for ADC Global Data register
N **********************************************************************/
N/** When DONE is 1, this field contains result value of ADC conversion */
N#define ADC_GDR_RESULT(n)		(((n>>4)&0xFFF))
N/** These bits contain the channel from which the LS bits were converted */
N#define ADC_GDR_CH(n)			(((n>>24)&0x7))
N/** This bit is 1 in burst mode if the results of one or
N * more conversions was (were) lost */
N#define ADC_GDR_OVERRUN_FLAG	((1UL<<30))
N/** This bit is set to 1 when an A/D conversion completes */
N#define ADC_GDR_DONE_FLAG		((1UL<<31))
N
N/** This bits is used to mask for Channel */
N#define ADC_GDR_CH_MASK		((7UL<<24))
N/*********************************************************************//**
N * Macro defines for ADC Interrupt register
N **********************************************************************/
N/** These bits allow control over which A/D channels generate
N * interrupts for conversion completion */
N#define ADC_INTEN_CH(n)			((1UL<<n))
N/** When 1, enables the global DONE flag in ADDR to generate an interrupt */
N#define ADC_INTEN_GLOBAL		((1UL<<8))
N
N/*********************************************************************//**
N * Macro defines for ADC Data register
N **********************************************************************/
N/** When DONE is 1, this field contains result value of ADC conversion */
N#define ADC_DR_RESULT(n)		(((n>>4)&0xFFF))
N/** These bits mirror the OVERRRUN status flags that appear in the
N * result register for each A/D channel */
N#define ADC_DR_OVERRUN_FLAG		((1UL<<30))
N/** This bit is set to 1 when an A/D conversion completes. It is cleared
N * when this register is read */
N#define ADC_DR_DONE_FLAG		((1UL<<31))
N
N/*********************************************************************//**
N * Macro defines for ADC Status register
N**********************************************************************/
N/** These bits mirror the DONE status flags that appear in the result
N * register for each A/D channel */
N#define ADC_STAT_CH_DONE_FLAG(n)		((n&0xFF))
N/** These bits mirror the OVERRRUN status flags that appear in the
N * result register for each A/D channel */
N#define ADC_STAT_CH_OVERRUN_FLAG(n)		(((n>>8)&0xFF))
N/** This bit is the A/D interrupt flag */
N#define ADC_STAT_INT_FLAG				((1UL<<16))
N
N/*********************************************************************//**
N * Macro defines for ADC Trim register
N**********************************************************************/
N/** Offset trim bits for ADC operation */
N#define ADC_ADCOFFS(n)		(((n&0xF)<<4))
N/** Written to boot code*/
N#define ADC_TRIM(n)		    (((n&0xF)<<8))
N
N/* ------------------- CHECK PARAM DEFINITIONS ------------------------- */
N/** Check ADC parameter */
N#define PARAM_ADCx(n)    (((CPU_INT32U *)n)==((CPU_INT32U *)LPC_ADC))
N
N/** Check ADC state parameter */
N#define PARAM_ADC_START_ON_EDGE_OPT(OPT)    ((OPT == ADC_START_ON_RISING)||(OPT == ADC_START_ON_FALLING))
N
N/** Check ADC state parameter */
N#define PARAM_ADC_DATA_STATUS(OPT)    ((OPT== ADC_DATA_BURST)||(OPT== ADC_DATA_DONE))
N
N/** Check ADC rate parameter */
N#define PARAM_ADC_RATE(rate)	((rate>0)&&(rate<=200000))
N
N/** Check ADC channel selection parameter */
N#define PARAM_ADC_CHANNEL_SELECTION(SEL)	((SEL == ADC_CHANNEL_0)||(ADC_CHANNEL_1)\
N||(SEL == ADC_CHANNEL_2)|(ADC_CHANNEL_3)\
N||(SEL == ADC_CHANNEL_4)||(ADC_CHANNEL_5)\
N||(SEL == ADC_CHANNEL_6)||(ADC_CHANNEL_7))
X#define PARAM_ADC_CHANNEL_SELECTION(SEL)	((SEL == ADC_CHANNEL_0)||(ADC_CHANNEL_1)||(SEL == ADC_CHANNEL_2)|(ADC_CHANNEL_3)||(SEL == ADC_CHANNEL_4)||(ADC_CHANNEL_5)||(SEL == ADC_CHANNEL_6)||(ADC_CHANNEL_7))
N
N/** Check ADC start option parameter */
N#define PARAM_ADC_START_OPT(OPT)    ((OPT == ADC_START_CONTINUOUS)||(OPT == ADC_START_NOW)\
N||(OPT == ADC_START_ON_EINT0)||(OPT == ADC_START_ON_CAP01)\
N||(OPT == ADC_START_ON_MAT01)||(OPT == ADC_START_ON_MAT03)\
N||(OPT == ADC_START_ON_MAT10)||(OPT == ADC_START_ON_MAT11))
X#define PARAM_ADC_START_OPT(OPT)    ((OPT == ADC_START_CONTINUOUS)||(OPT == ADC_START_NOW)||(OPT == ADC_START_ON_EINT0)||(OPT == ADC_START_ON_CAP01)||(OPT == ADC_START_ON_MAT01)||(OPT == ADC_START_ON_MAT03)||(OPT == ADC_START_ON_MAT10)||(OPT == ADC_START_ON_MAT11))
N
N/** Check ADC interrupt type parameter */
N#define PARAM_ADC_TYPE_INT_OPT(OPT)    ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)\
N||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)\
N||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)\
N||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)\
N||(OPT == ADC_ADGINTEN))
X#define PARAM_ADC_TYPE_INT_OPT(OPT)    ((OPT == ADC_ADINTEN0)||(OPT == ADC_ADINTEN1)||(OPT == ADC_ADINTEN2)||(OPT == ADC_ADINTEN3)||(OPT == ADC_ADINTEN4)||(OPT == ADC_ADINTEN5)||(OPT == ADC_ADINTEN6)||(OPT == ADC_ADINTEN7)||(OPT == ADC_ADGINTEN))
N
N/**
N * @}
N */
N
N
N/* Public Types --------------------------------------------------------------- */
N/*********************************************************************//**
N * @brief ADC enumeration
N **********************************************************************/
N/** @brief Channel Selection */
N//typedef enum
N//{
N//	ADC_CHANNEL_0  = 0x01,      /*!<  Channel 0 */
N//	ADC_CHANNEL_1  = 0x02,		/*!<  Channel 1 */
N//	ADC_CHANNEL_2  = 0x04,		/*!<  Channel 2 */
N//	ADC_CHANNEL_3  = 0x08,		/*!<  Channel 3 */
N//	ADC_CHANNEL_4  = 0x10,		/*!<  Channel 4 */
N//	ADC_CHANNEL_5  = 0x20,		/*!<  Channel 5 */
N//	ADC_CHANNEL_6  = 0x40,		/*!<  Channel 6 */
N//	ADC_CHANNEL_7  = 0x80		/*!<  Channel 7 */
N//}ADC_CHANNEL_SELECTION;
N
N
N/** @brief Channel Selection */
Ntypedef enum
N{
N	ADC_CHANNEL_0  = 0, /*!<  Channel 0 */
N	ADC_CHANNEL_1,		/*!<  Channel 1 */
N	ADC_CHANNEL_2,		/*!<  Channel 2 */
N	ADC_CHANNEL_3,		/*!<  Channel 3 */
N	ADC_CHANNEL_4,		/*!<  Channel 4 */
N	ADC_CHANNEL_5,		/*!<  Channel 5 */
N	ADC_CHANNEL_6,		/*!<  Channel 6 */
N	ADC_CHANNEL_7		/*!<  Channel 7 */
N}ADC_CHANNEL_SELECTION;
N
N/** @brief Type of start option */
Ntypedef enum
N{
N	ADC_START_CONTINUOUS =0,	/*!< Continuous mode */
N	ADC_START_NOW,				/*!< Start conversion now */
N	ADC_START_ON_EINT0,			/*!< Start conversion when the edge selected
N								 * by bit 27 occurs on P2.10/EINT0 */
N	ADC_START_ON_CAP01,			/*!< Start conversion when the edge selected
N								 * by bit 27 occurs on P1.27/CAP0.1 */
N	ADC_START_ON_MAT01,			/*!< Start conversion when the edge selected
N								 * by bit 27 occurs on MAT0.1 */
N	ADC_START_ON_MAT03,			/*!< Start conversion when the edge selected
N								 * by bit 27 occurs on MAT0.3 */
N	ADC_START_ON_MAT10,			/*!< Start conversion when the edge selected
N								  * by bit 27 occurs on MAT1.0 */
N	ADC_START_ON_MAT11			/*!< Start conversion when the edge selected
N								  * by bit 27 occurs on MAT1.1 */
N} ADC_START_OPT;
N
N
N/** @brief Type of edge when start conversion on the selected CAP/MAT signal */
Ntypedef enum
N{
N	ADC_START_ON_RISING = 0,	/*!< Start conversion on a rising edge
N								*on the selected CAP/MAT signal */
N	ADC_START_ON_FALLING		/*!< Start conversion on a falling edge
N								*on the selected CAP/MAT signal */
N} ADC_START_ON_EDGE_OPT;
N
N/** @brief* ADC type interrupt enum */
Ntypedef enum
N{
N    ADC_ADINTDIS = 0,
N	ADC_ADINTEN0 = 0x01,		/*!< Interrupt channel 0 */
N	ADC_ADINTEN1 = 0x02,		/*!< Interrupt channel 1 */
N	ADC_ADINTEN2 = 0x04,		/*!< Interrupt channel 2 */
N	ADC_ADINTEN3 = 0x08,		/*!< Interrupt channel 3 */
N	ADC_ADINTEN4 = 0x10,		/*!< Interrupt channel 4 */
N	ADC_ADINTEN5 = 0x20,		/*!< Interrupt channel 5 */
N	ADC_ADINTEN6 = 0x40,		/*!< Interrupt channel 6 */
N	ADC_ADINTEN7 = 0x80,		/*!< Interrupt channel 7 */
N	ADC_ADGINTEN = 0x0100,		/*!< Individual channel/global flag done generate an interrupt */
N}ADC_TYPE_INT_OPT;
N
N/** @brief ADC Data  status */
Ntypedef enum
N{
N	ADC_DATA_BURST = 0,	    /*Burst bit*/
N	ADC_DATA_DONE		    /*Done bit*/
N}ADC_DATA_STATUS;
N
Ntypedef struct
N{
N    CPU_INT32U gpio_pins;            
N	CPU_INT16U gpio_opt;
N	CPU_INT08U gpio_port;
N	CPU_INT08U rvsd;
N}ADC_PIN_CFG_Type;
N
Ntypedef struct{
N    CPU_INT32U            adc_rate;
N	ADC_START_ON_EDGE_OPT adc_start_edge;
N	ADC_TYPE_INT_OPT	  adc_int_opt;
N	CPU_INT32U            adc_ch_sel;
N	FunctionalState       adc_burst_en;
N	FunctionalState       adc_pwd_en;
N}ADC_CFG_Type;
N
N/* Public Functions ----------------------------------------------------------- */
N/* ADC0 init and get data */
Nvoid ADC0_Init(void);
NCPU_INT16U ADC0_GetData(CPU_INT32U channel);
N//CPU_INT32S ADC0_GetData(CPU_INT32U channel,CPU_INT16U *pvl);
N
N/* Init/DeInit ADC peripheral ----------------*/
Nvoid ADC_Init(LPC_ADC_TypeDef *ADCx, uint32_t rate);
Nvoid ADC_DeInit(LPC_ADC_TypeDef *ADCx);
N
N/* Enable/Disable ADC functions --------------*/
Nvoid ADC_BurstCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState);
Nvoid ADC_PowerdownCmd(LPC_ADC_TypeDef *ADCx, FunctionalState NewState);
Nvoid ADC_StartCmd(LPC_ADC_TypeDef *ADCx, CPU_INT08U start_mode);
Nvoid ADC_ChannelCmd (LPC_ADC_TypeDef *ADCx, CPU_INT08U Channel, FunctionalState NewState);
N
N/* Configure ADC functions -------------------*/
Nvoid ADC_EdgeStartConfig(LPC_ADC_TypeDef *ADCx, CPU_INT08U EdgeOption);
Nvoid ADC_IntConfig (LPC_ADC_TypeDef *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState);
N
N/* Get ADC information functions -------------------*/
NCPU_INT16U ADC_ChannelGetData(LPC_ADC_TypeDef *ADCx, CPU_INT08U channel);
NFlagStatus ADC_ChannelGetStatus(LPC_ADC_TypeDef *ADCx, CPU_INT08U channel, CPU_INT32U StatusType);
NCPU_INT32U ADC_GlobalGetData(LPC_ADC_TypeDef *ADCx);
NFlagStatus ADC_GlobalGetStatus(LPC_ADC_TypeDef *ADCx, CPU_INT32U StatusType);
N
N
N
Nunsigned int press0_sensor_get(void);
Nunsigned int press1_sensor_get(void);
N
Nunsigned int temperature0_sensor_get(void);
Nunsigned int temperature1_sensor_get(void);
Nunsigned int water_level_get(void);
Nvoid sensor_adc_init(void);
N#ifdef __cplusplus
S}
N#endif
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif 
N
L 48 "app\cfg\../../drivers/drivers.h" 2
N#define MOTOR_NUM  2
N#define ArgBoardFirmwareVersion (0x010407ff)// 19
N/*******************  (C) COPYRIGHT 2010 DJI ************END OF FILE***********/
N#endif
L 16 "app\cfg\cfg_unpack.c" 2
N#include "../../can/can_inc.h"
L 1 "app\cfg\../../can/can_inc.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : WKM2_CAN_LOADER.uvproj
N  * @File Name          : can_def.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-10-17
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_INC_H__
N#define __CAN_INC_H__
N
N/* Includes ------------------------------------------------------------------*/
N#include "can_def.h"
L 1 "app\cfg\../../can/can_def.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : WKM2_CAN_LOADER.uvproj
N  * @File Name          : can_def.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-10-17
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_DEF_H__
N#define __CAN_DEF_H__
N
N#include "../drivers/drivers_def.h"
N
N/* public define -------------------------------------------------------------*/
N/* can buffer size */
N#define  A2  1
N#define  A3  2
N
N#define  FC_TYPE  A2
N
N#define CAN_BUFSIZE	          (512)	      /* 2n */
N
N/* unpack can package in ISR or task tick */
N#define UNPACK_ON_ISR         (0)
N
N/* ID */
N//ID
N//#define CAN1_RX_ID3		  (0x0417)
N//ID  
N//define CAN1_RX_ID		    (0x0417)
N#define UPGRADE_RX_FARMING_BOARD_ID	   (0x04fa)
N#define UPGRADE_TX_FARMING_BOARD_ID	   (0x05fa)
N
N
N//LightBridge()
N#define CAN1_RX_ID		  (0x0412)
N//CAN id  
N#define CAN1_UPGRADE_ID		(UPGRADE_RX_FARMING_BOARD_ID)
N
N#if FC_TYPE==A2
X#if 1==1
N//ID  617
N#define CAN1_RX_ID2		  (0x0617) // ID    0x519 
N
N// ID V0   0xA3 radar->MC  0xA2 mc->radar 
N#define CAN1_TX_ID2       (0x0095)
N#else 
S#define CAN1_RX_ID2		  (0x0519)
S#define CAN1_TX_ID2     (0x00A3)
S
N#endif
N
N//OFDMID (
N#define CAN1_TX_ID		  (0x0413)  
N
N
N////
N#define CAN1_TX_ID3       (0x0616) // ID
N
N// CANID
N#define CAN1_UPGRADE_ACK_ID  (UPGRADE_TX_FARMING_BOARD_ID )
N
N//LEDCAN ID
N#define CAN1_TX_LED_ID      (0xA1)
N
N// sensor 
N#define CAN1_RX_RADAR      (0x180)
N
N#define CAN2_RX_ID		    (0x0517)
N#define CAN2_TX_ID		    (0x0412)
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 19 "app\cfg\../../can/can_inc.h" 2
N#include "can_hw.h"
L 1 "app\cfg\../../can/can_hw.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_MAIN.uvproj
N  * @File Name          : can_hw.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-08-31
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_HW_H__
N#define __CAN_HW_H__
N
N/* Private define ------------------------------------------------------------*/
N/* for can pin p0.0,p0.1 */
N//#define CAN1_RD_PIN           DEF_BIT_00  /* p0.0,p0.1 FCNT2 -- RD1,TD1 */
N//#define CAN1_TD_PIN  		    DEF_BIT_01
N
N#define CAN1_RD_PIN             DEF_BIT_21  /* p0.21,p0.22 FCNT4 -- RD1,TD1 */
N#define CAN1_TD_PIN  		    DEF_BIT_22
N
N#define CAN1_PORT           	GPIO_PORT0_FAST
N#define CAN1_PINS				(CAN1_RD_PIN | CAN1_TD_PIN)
N
N#define CAN2_RD_PIN             DEF_BIT_04  /* p0.4,p0.5 FCNT3 -- RD2,TD2 */
N#define CAN2_TD_PIN  		    DEF_BIT_05
N
N/* ICR bit field & bit mask & bit set */
N#define ICR_RI_SET						DEF_BIT_00
N#define ICR_RI_MASK                     DEF_BIT_00
N
N#define ICR_TI1_SET						DEF_BIT_01
N#define ICR_TI1_MASK                    DEF_BIT_01
N
N#define ICR_EI_SET                      DEF_BIT_02
N#define ICR_EI_MASK                     DEF_BIT_02
N
N#define ICR_DOI_SET                     DEF_BIT_03
N#define ICR_DOI_MASK                    DEF_BIT_03
N
N#define ICR_WUI_SET                     DEF_BIT_04
N#define ICR_WUI_MASK                    DEF_BIT_04
N
N#define ICR_EPI_SET                     DEF_BIT_05
N#define ICR_EPI_MASK                    DEF_BIT_05
N
N#define ICR_ALI_SET                     DEF_BIT_06
N#define ICR_ALI_MASK                    DEF_BIT_06
N
N#define ICR_BEI_SET                     DEF_BIT_07
N#define ICR_BEI_SET                     DEF_BIT_07
N
N#define ICR_IDI_SET                     DEF_BIT_08
N#define ICR_IDI_MASK                    DEF_BIT_08
N
N#define ICR_TI2_SET                     DEF_BIT_09
N#define ICR_TI2_MASK                    DEF_BIT_09
N
N#define ICR_TI3_SET                     DEF_BIT_10
N#define ICR_TI3_MASK                    DEF_BIT_10
N
N#define ICR_ERRBIT_MASK                 0x001f0000
N
N#define ICR_ERRDIR_MASK                 DEF_BIT_21
N
N#define ICR_ERRC_MASK                   0x00C00000
N
N#define ICR_ALCBIT_MASK                 0xff000000
N
N#define ICR_ERRSTA_BIT_MASK             0x000001fc
N
N/* IER bit field & bit mask & bit set */
N#define IER_RIE						    DEF_BIT_00
N#define IER_TIE1						DEF_BIT_01
N#define IER_EIE						    DEF_BIT_02
N#define IER_DOIE						DEF_BIT_03
N#define IER_WUIE						DEF_BIT_04
N#define IER_EPIE						DEF_BIT_05
N#define IER_ALIE						DEF_BIT_06
N#define IER_BEIE						DEF_BIT_07
N#define IER_IDIE						DEF_BIT_08
N#define IER_TIE2						DEF_BIT_09
N#define IER_TIE3						DEF_BIT_10
N
N#define CAN_TBS1_EN( x )                     { x->CMR = 0x21; }
N#define CAN_TBS2_EN( x )                     { x->CMR = 0x41; }
N#define CAN_TBS3_EN( x )                     { x->CMR = 0x81; }
N#define CAN_TBS123_EN( x )                   { x->CMR = 0xE1; }
N
N#define RELEASE_RECEIVE_BUFF_HW(x)         do{ x->CMR = 0x04;}while(0)
N
N/*
N * CAN_BITRATE  = (1/Fpclk)*(BRP+1)*(M+1+N+1+1)
N * Sample point = (N+1+1)/(M+1+N+1+1)
N * register BTR = (BRP << 0) | (SJW << 14) | (N << 16) | (M << 20) | (SAM << 23)
N */
N//#define BITRATE_1000K36MHZ              (0 << 23)|(0 << 20)|(6 << 16)|(0 << 14)|3  /* BRP=3,SJW=0,TESG1=6,TESG2=0,SAM=0 -- 36/(3+1)*(6+3)*/
N#define BITRATE_1000K25MHZ            (0 << 23)|(0 << 20)|(2 << 16)|(0 << 14)|4  /* BRP=4,SJW=0,TESG1=2,TESG2=0,SAM=0 -- 25/(4+1)*(2+3)*/
N//#define BITRATE_1000K25MHZ			    (0 << 23)|(6 << 20)|(16 << 16)|(0 << 14)|0   /* BRP=0,SJW=0,TESG1=16,TESG2=6,SAM=0 -- 25/(0+1)*(16+6+3)*/
N
N
N
N/* public typedef ------------------------------------------------------------*/
N/* : */
Ntypedef struct
N{
N	uint32_t cnt;
N	uint32_t id;
N	union
N	{
N	    uint32_t dwData[2];
N	    uint8_t  bData[8];
N	}data;	
N} CAN_MSG_Type;
N
N/* CAN send or recieve ring buffer */
Ntypedef struct
N{
N    uint32_t volatile wrIdx;
N	uint32_t volatile rdIdx;
N	uint32_t          mask;
N	uint32_t		  size;
N	uint32_t          id;
N	uint8_t           *pBuf;
N	
N	uint8_t           state;      /* ,,,4 */         
N}CAN_RING_BUF_Type;
N
N/* public function declaration -----------------------------------------------*/
Nvoid CAN_Init(void);
Nvoid CAN_DeInit(void);
Nvoid CAN_tx_action( LPC_CAN_TypeDef *pCANx, CAN_RING_BUF_Type* buf,uint32_t cnt,uint32_t flag );
Nvoid CAN_tx_action_all( LPC_CAN_TypeDef *pCANx, CAN_RING_BUF_Type* buf,uint32_t cnt );
Nvoid CAN_TxINTRoute( LPC_CAN_TypeDef *pCANx );
Nvoid CAN_RxINTRoute( LPC_CAN_TypeDef *pCANx );
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 20 "app\cfg\../../can/can_inc.h" 2
N#include "can_af.h"
L 1 "app\cfg\../../can/can_af.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : WKM2_CAN_LOADER.uvproj
N  * @File Name          : can_af.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-08-31 
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *	      
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_AF_H__
N#define __CAN_AF_H__
N
N/* Includes ------------------------------------------------------------------*/
N#include <LPC17xx.h>
N
N/* Private define ------------------------------------------------------------*/
N#define MSG_ENABLE				        ((CPU_INT08U)(0))
N#define MSG_DISABLE				        ((CPU_INT08U)(1))
N#define CAN_CTL1                        (0)
N#define CAN_CTL2                        (1) 
N
N/* CHECK PARAMETER DEFINITIONS  ----------------------------------------------*/ 
N/* Macro to determine if it is valid CAN peripheral or not */
N#define PARAM_CANx(x)			((((CPU_INT32U*)x)==((CPU_INT32U *)LPC_CAN1)) || (((CPU_INT32U*)x)==((CPU_INT32U *)LPC_CAN2)))
N
N/*	Macro to determine if it is valid CANAF or not*/
N#define PARAM_CANAFx(x)			(((uint32_t*)x)== ((uint32_t*)LPC_CANAF))
N
N/*	Macro to determine if it is valid CANAF RAM or not*/
N#define PARAM_CANAFRAMx(x)		(((uint32_t*)x)== (uint32_t*)LPC_CANAF_RAM)
N
N/** Macro define for struct AF_Section parameter */
N#define PARAM_CTRL(n)	        ((n==CAN_CTL1)|(n==CAN_CTL2))
N
N/*	Macro to determine if it is valid CANCR or not*/
N#define PARAM_CANCRx(x)			(((uint32_t*)x)==((uint32_t*)LPC_CANCR))
N
N/** Macro to check Frame Identifier */
N#define PARAM_ID_11(n)			((n>>11)==0) /*-- 11 bit --*/
N#define PARAM_ID_29(n)			((n>>29)==0) /*-- 29 bit --*/
N
N/** Macro define for struct AF_Section parameter */
N#define PARAM_MSG_DISABLE(n)	((n==MSG_ENABLE)|(n==MSG_DISABLE))
N
N/** Macro to check ID format type */
N#define PARAM_ID_FORMAT(n)		((n==STD_ID_FORMAT)||(n==EXT_ID_FORMAT))
N
N/** CAN configuration structure */
N/***********************************************************************
N * CAN device configuration commands (IOCTL commands and arguments)
N **********************************************************************/
N/**
N * @brief CAN ID format definition
N */
Ntypedef enum {
N	STD_ID_FORMAT = 0, 	/**< Use standard ID format (11 bit ID) */
N	EXT_ID_FORMAT = 1	/**< Use extended ID format (29 bit ID) */
N} CAN_ID_FORMAT_Type;
N
N/**
N * @brief AFLUT Entry type definition
N */
Ntypedef enum {
N	FULLCAN_ENTRY = 0,
N	EXPLICIT_STANDARD_ENTRY,
N	GROUP_STANDARD_ENTRY,
N	EXPLICIT_EXTEND_ENTRY,
N	GROUP_EXTEND_ENTRY,
N} AFLUT_ENTRY_Type;
N
N/**
N * @brief Symbolic names for type of CAN message
N */
Ntypedef enum {
N	DATA_FRAME = 0, 	/**< Data frame */
N	REMOTE_FRAME = 1	/**< Remote frame */
N} CAN_FRAME_Type;
N
N/**
N * @brief Error values that functions can return
N */
Ntypedef enum {
N	CAN_OK = 1, 				/**< No error */
N	CAN_OBJECTS_FULL_ERROR, 	/**< No more rx or tx objects available */
N	CAN_FULL_OBJ_NOT_RCV, 		/**< Full CAN object not received */
N	CAN_NO_RECEIVE_DATA, 		/**< No have receive data available */
N	CAN_AF_ENTRY_ERROR, 		/**< Entry load in AFLUT is unvalid */
N	CAN_CONFLICT_ID_ERROR, 		/**< Conflict ID occur */
N	CAN_ENTRY_NOT_EXIT_ERROR	/**< Entry remove outo AFLUT is not exit */
N} CAN_ERROR;
N
N/**
N * @brief FullCAN Entry structure
N */
Ntypedef struct {
N	CPU_INT08U controller;		/**< CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT08U disable;		/**< Disable bit, should be:
N								 - MSG_ENABLE: disable bit = 0
N								 - MSG_DISABLE: disable bit = 1
N							*/
N	CPU_INT16U id_11;			/**< Standard ID, should be 11-bit value */
N} FullCAN_Entry;
N
N/**
N * @brief Standard ID Frame Format Entry structure
N */
Ntypedef struct {
N	CPU_INT08U controller; 	/**< CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT08U disable; 		/**< Disable bit, should be:
N								 - MSG_ENABLE: disable bit = 0
N								 - MSG_DISABLE: disable bit = 1
N							*/
N	CPU_INT16U id_11; 		/**< Standard ID, should be 11-bit value */
N} SFF_Entry;
N
N/**
N * @brief Group of Standard ID Frame Format Entry structure
N */
Ntypedef struct {
N	CPU_INT08U controller1; 	/**< First CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT08U disable1; 		/**< First Disable bit, should be:
N								 - MSG_ENABLE: disable bit = 0)
N								 - MSG_DISABLE: disable bit = 1
N							*/
N	CPU_INT16U lowerID; 		/**< ID lower bound, should be 11-bit value */
N	CPU_INT08U controller2; 	/**< Second CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT08U disable2; 		/**< Second Disable bit, should be:
N								 - MSG_ENABLE: disable bit = 0
N								 - MSG_DISABLE: disable bit = 1
N							*/
N	CPU_INT16U upperID; 		/**< ID upper bound, should be 11-bit value and
N								 equal or greater than lowerID
N							*/
N} SFF_GPR_Entry;
N
N/**
N * @brief Extended ID Frame Format Entry structure
N */
Ntypedef struct {
N	CPU_INT08U controller; 	/**< CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT32U ID_29; 		/**< Extend ID, shoud be 29-bit value */
N} EFF_Entry;
N
N
N/**
N * @brief Group of Extended ID Frame Format Entry structure
N */
Ntypedef struct {
N	CPU_INT08U controller1; 	/**< First CAN Controller, should be:
N								 - CAN1_CTRL: CAN1 Controller
N								 - CAN2_CTRL: CAN2 Controller
N							*/
N	CPU_INT08U controller2; 	/**< Second Disable bit, should be:
N								 - MSG_ENABLE: disable bit = 0(default)
N								 - MSG_DISABLE: disable bit = 1
N							*/
N	CPU_INT32U lowerEID; 		/**< Extended ID lower bound, should be 29-bit value */
N	CPU_INT32U upperEID; 		/**< Extended ID upper bound, should be 29-bit value */
N} EFF_GPR_Entry;
N
N/**
N * @brief Acceptance Filter Section Table structure
N */
Ntypedef struct {
N	FullCAN_Entry* FullCAN_Sec; 	/**< The pointer point to FullCAN_Entry */
N	CPU_INT08U FC_NumEntry;			/**< FullCAN Entry Number */
N	SFF_Entry* SFF_Sec; 			/**< The pointer point to SFF_Entry */
N	CPU_INT08U SFF_NumEntry;			/**< Standard ID Entry Number */
N	SFF_GPR_Entry* SFF_GPR_Sec; 	/**< The pointer point to SFF_GPR_Entry */
N	CPU_INT08U SFF_GPR_NumEntry;		/**< Group Standard ID Entry Number */
N	EFF_Entry* EFF_Sec; 			/**< The pointer point to EFF_Entry */
N	CPU_INT08U EFF_NumEntry;			/**< Extended ID Entry Number */
N	EFF_GPR_Entry* EFF_GPR_Sec; 	/**< The pointer point to EFF_GPR_Entry */
N	CPU_INT08U EFF_GPR_NumEntry;		/**< Group Extended ID Entry Number */
N} AF_SectionDef;
N
N/* Function declaration ------------------------------------------------------*/
N 
Nvoid CAN_InitAFTable(void);
NCAN_ERROR CAN_SetupAFLUT(LPC_CANAF_TypeDef* CANAFx, AF_SectionDef* AFSection);
NCAN_ERROR CAN_LoadExplicitEntry(LPC_CAN_TypeDef* CANx, uint32_t id, CAN_ID_FORMAT_Type format);
NCAN_ERROR CAN_LoadFullCANEntry (LPC_CAN_TypeDef* CANx, uint16_t id);
NCAN_ERROR CAN_LoadGroupEntry(LPC_CAN_TypeDef* CANx, uint32_t lowerID, uint32_t upperID, CAN_ID_FORMAT_Type format);
NCAN_ERROR CAN_RemoveEntry(AFLUT_ENTRY_Type EntryType, uint16_t position);
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 21 "app\cfg\../../can/can_inc.h" 2
N#include "can_package.h"
L 1 "app\cfg\../../can/can_package.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : WKM2_CAN_LOADER.uvproj
N  * @File Name          : can_package.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-10-14 
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *	           
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_PACKAGE_H__
N#define __CAN_PACKAGE_H__
N
N/* Includes ------------------------------------------------------------------*/
N/* Standlib */
N
N/* Private define ------------------------------------------------------------*/
N
N
N/* Function declaration ------------------------------------------------------*/
N/*  */
Nuint8_t CAN_RING_BUF_RD(CAN_RING_BUF_Type *ring_buf);
Nvoid CAN_RING_BUF_WR(CAN_RING_BUF_Type *ring_buf, uint8_t DataIn);
Nuint32_t CAN_RING_BUF_COUNT(CAN_RING_BUF_Type *ring_buf); 
Nuint32_t CAN_RING_BUF_IS_FULL(CAN_RING_BUF_Type *ring_buf);
Nuint32_t CAN_RING_BUF_IS_EMPTY(CAN_RING_BUF_Type *ring_buf);
Nvoid CAN_RING_BUF_CLEAR(CAN_RING_BUF_Type *ring_buf);
N
Nvoid CAN_RING_BUF_Init(void);
NCPU_INT32U CAN_RING_BUF_WR_BLOCK(CAN_RING_BUF_Type *dst,CPU_INT08U *src,CPU_INT32U cnt);
NCPU_INT32U CAN_RING_BUF_RD_BLOCK(CPU_INT08U *dst,CAN_RING_BUF_Type *src,CPU_INT32U cnt);
Nvoid CAN_tx_function(LPC_CAN_TypeDef *pCANx, CAN_RING_BUF_Type *buf,CPU_INT32U index_TBS);
Nvoid CAN_SendPackage(CPU_INT08U to, CPU_INT16U len, CPU_INT16U cmd,CPU_INT08U *p_package);
Nvoid CAN_SendPackage_View(CPU_INT08U to, CPU_INT16U len,CPU_INT08U *p_package);
N
Nvoid CAN_rx_function_ctrl(void);
N
N/* can send bytes */
Nvoid CAN_sendbytes_View( LPC_CAN_TypeDef *LPC_CANx, CAN_RING_BUF_Type *dst, CPU_INT08U *src, CPU_INT16U length );
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 22 "app\cfg\../../can/can_inc.h" 2
N
N#include "can_ext_declares.h"
L 1 "app\cfg\../../can/can_ext_declares.h" 1
N/**
N  ******************** (C) COPYRIGHT 2011 DJI **********************************
N  *
N  * @Project Name       : WKM2_CAN_LOADER.uvproj
N  * @File Name          : can_ext_declares.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2011-10-17 
N  * @Version            : 1.10
N  ******************************************************************************
N  * @Description
N  *	      
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CAN_EXT_DECLARES_H__
N#define __CAN_EXT_DECLARES_H__
N
N/* extern variables ----------------------------------------------------------*/
Nextern CAN_MSG_Type       msgRxBuf;
N
Nextern CPU_INT08U         can1RxBuf[CAN_BUFSIZE] ;	   //
Xextern CPU_INT08U         can1RxBuf[(512)] ;	   
Nextern CAN_RING_BUF_Type  can1RxRingBuf          ;
N
Nextern CPU_INT08U         can1Rx2Buf[CAN_BUFSIZE] ;	   //
Xextern CPU_INT08U         can1Rx2Buf[(512)] ;	   
Nextern CAN_RING_BUF_Type  can1Rx2RingBuf          ;
N
Nextern CPU_INT08U         can1RxUpgradeBuf[CAN_BUFSIZE] ;	   //
Xextern CPU_INT08U         can1RxUpgradeBuf[(512)] ;	   
Nextern CAN_RING_BUF_Type  can1RxUpgradeRingBuf          ;
N
Nextern CPU_INT08U         can1RxLEDBuf[CAN_BUFSIZE] ;	   //
Xextern CPU_INT08U         can1RxLEDBuf[(512)] ;	   
Nextern CAN_RING_BUF_Type  can1RxLEDRingBuf          ;
N
Nextern CPU_INT08U         can1TxBuf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can1TxBuf[(512)] ;
Nextern CAN_RING_BUF_Type  can1TxRingBuf          ;
N
Nextern CPU_INT08U         can1Tx2Buf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can1Tx2Buf[(512)] ;
Nextern CAN_RING_BUF_Type  can1Tx2RingBuf          ;
N
Nextern CPU_INT08U         can1Tx3Buf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can1Tx3Buf[(512)] ;
Nextern CAN_RING_BUF_Type  can1Tx3RingBuf          ;
N
Nextern CPU_INT08U         can1UpgradeAckTxBuf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can1UpgradeAckTxBuf[(512)] ;
Nextern CAN_RING_BUF_Type  can1UpgradeAckTxRingBuf          ;
N
Nextern CPU_INT08U         can1LEDTxBuf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can1LEDTxBuf[(512)] ;
Nextern CAN_RING_BUF_Type  can1LEDTxRingBuf          ;
N#if __CAN2_ENABLE__
Sextern CPU_INT08U         can2RxBuf[CAN_BUFSIZE] ;	   //
Sextern CAN_RING_BUF_Type  can2RxRingBuf          ;
N#endif
Nextern CPU_INT08U         can2TxBuf[CAN_BUFSIZE] ;
Xextern CPU_INT08U         can2TxBuf[(512)] ;
Nextern CAN_RING_BUF_Type  can2TxRingBuf          ;
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 24 "app\cfg\../../can/can_inc.h" 2
N
N
N#define CAN_FORMAT_SD
N
N
N/*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
N#endif
L 17 "app\cfg\cfg_unpack.c" 2
N#include "../../usb/vcom_app.h"
L 1 "app\cfg\../../usb/vcom_app.h" 1
N/*
N********************************************************************************
N**                       DJI xp40 code
N** project: xp40.Uv2                        file: usb_app.h
N** environment: keil mdk3.7/lpc2368/72M cclock
N** history:
N**   v1.0 2009-11-06   Motorfeng
N********************************************************************************
N*/
N#ifndef __VCOM_APP_H
N#define	__VCOM_APP_H
N
Nvoid VCOM_Init(void);
Nvoid VCOM_Test(void);
Nvoid VCOM_putc(char c);
Nvoid VCOM_sendpackage(const char* buffer,int length);
Nchar VCOM_getc(void);
Nvoid VCOM_SendByte(char c);
Nvoid SendStr(const char *str);
Nvoid VCOM_printf(const unsigned char *pstr, ...);
Nvoid VCOM_printf_debug(const unsigned char *pstr, ...);
Nunsigned char VCOM_GetByte(void);
Nshort OutBufAvailBytes(void);
Nvoid VCOM_Clear(void);
N#endif
N/*
N********************************************************************************
N*                        END
N********************************************************************************
N*/
N
L 18 "app\cfg\cfg_unpack.c" 2
N#include "cfg_inc.h"
L 1 "app\cfg\cfg_inc.h" 1
N/**
N  ******************** (C) COPYRIGHT 2012 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : cfg_inc.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2012-05-28 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    Begginning of application   
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CFG_INC_H__
N#define __CFG_INC_H__
N
N/* Includes ------------------------------------------------------------------*/
N#include "cfg_unpack.h"
L 1 "app\cfg\cfg_unpack.h" 1
N/**
N  ******************** (C) COPYRIGHT 2012 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : cfg_unpack.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2012-05-28 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    Begginning of application   
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CFG_UNPACK_H__
N#define __CFG_UNPACK_H__
N
N#define CFG_CMD_MAX_SIZE							(512)
N
Nvoid cfg_unpack_init( void );
Nvoid cfg_unpack_tick( void );
N
N/*******************  (C) COPYRIGHT 2012 DJI ************END OF FILE***********/
N#endif
N
L 19 "app\cfg\cfg_inc.h" 2
N#include "cfg_handler.h"
L 1 "app\cfg\cfg_handler.h" 1
N/**
N  ******************** (C) COPYRIGHT 2012 DJI **********************************
N  *
N  * @Project Name       : BL_WKM2_LED_IAP.uvproj
N  * @File Name          : cfg_handler.h
N  * @Environment        : keil mdk4.12/LPC1765/100M cclock
N  * @Author&Date        : 2012-05-28 
N  * @Version            : 1.00
N  ******************************************************************************
N  * @Description
N  *	    Begginning of application   
N  */
N#ifndef __CFG_HANDLER_H__
N#define __CFG_HANDLER_H__
N
Nenum {
N    EP_NULL,
N#if __USB_ENABLE__
S    EP_USB,
N#endif
N#if __CAN1_ENABLE__
X#if (1)
N    EP_CAN1,
N    EP_CAN1_LED,
N		EP_CAN1_LB,
N#endif
N#if __CAN2_ENABLE__
S    EP_CAN2,
N#endif
N#if __UART0_ENABLE__
X#if 1
N    EP_UART0,
N#endif
N#if __UART1_ENABLE__
X#if 1
N    EP_UART1,
N#endif
N#if __UART2_ENABLE__
X#if 1
N    EP_UART2,
N#endif
N#if __UART3_ENABLE__
X#if 1
N    EP_UART3,
N#endif
N};
N
N#define	DJI_PRO_DEVICE_TYPE_CAMERA	        1
N#define	DJI_PRO_DEVICE_TYPE_APP	            2
N#define	DJI_PRO_DEVICE_TYPE_FLIGHT_CONTROL	3
N#define	DJI_PRO_DEVICE_TYPE_GIMBAL	        4
N#define	DJI_PRO_DEVICE_TYPE_CENTER	        5
N#define	DJI_PRO_DEVICE_TYPE_REMOTE_CONTROL	6
N#define	DJI_PRO_DEVICE_TYPE_STA_WIFI	        7
N#define	DJI_PRO_DEVICE_TYPE_AB_DM368	    8
N#define	DJI_PRO_DEVICE_TYPE_AB_OFDM	        9
N#define	DJI_PRO_DEVICE_TYPE_PC	            10
N#define	DJI_PRO_DEVICE_TYPE_SMART_BATTERY	11
N#define	DJI_PRO_DEVICE_TYPE_ESC		        12
N#define	DJI_PRO_DEVICE_TYPE_GS_DM368		13
N#define	DJI_PRO_DEVICE_TYPE_GS_OFDM		    14
N#define	DJI_PRO_DEVICE_TYPE_AB_68013		15
N#define	DJI_PRO_DEVICE_TYPE_GS_68013		16
N#define	DJI_PRO_DEVICE_TYPE_MONOCULAR_VISION	17
N#define	DJI_PRO_DEVICE_TYPE_BINOCULAR_VISION	18
N#define DJI_PRO_DEVICE_TYPE_GS_FPGA         20
N#define DJI_PRO_DEVICE_TYPE_AP_WIFI    27
N#define	DJI_PRO_DEVICE_TYPE_1765_TEST		29
N#define	DJI_PRO_DEVICE_TYPE_BROADCAST		31
N#define	CRC_16_LENGTH	2
N
Ntypedef __packed struct {
N	uint8_t sof;
N	__packed struct {
N		uint16_t length		    : 10;
N		uint16_t version 	    : 6;
N	} vl;
N	uint8_t crc8;
N	uint16_t id;
N} cmd_header_v0_t;
N
Ntypedef __packed struct {
N	uint8_t sof;
N	__packed struct {
N		uint16_t length		    : 10;
N		uint16_t version 	    : 6;
N	} vl;
N	uint8_t crc8;
N	__packed struct {
N		uint8_t sender_id		: 5;
N		uint8_t sender_index	: 3;
N	} sender;
N	__packed struct {
N		uint8_t receiver_id		: 5;
N		uint8_t receiver_index	: 3;
N	} receiver;
N	uint16_t seqnum;
N	__packed struct {
N		uint8_t	encrypt_type	: 4;
N		uint8_t reserve			: 1;
N		uint8_t cmd_ack			: 2;
N		uint8_t cmd_type		: 1;
N	} type;
N	uint8_t set;
N	uint8_t id;
N} cmd_header_v1_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N	__packed struct {
N		uint8_t minor	: 4;
N		uint8_t major : 4;
N	} command_version;
N	uint8_t hardware_ver[16];
N    uint32_t loader_ver;
N    uint32_t firmware_ver;
N	uint32_t command_set;
N} cmd_device_info_ack_t;
N
Ntypedef __packed struct {
N	uint8_t encrypt;
N	uint8_t reserve[8];
N} cmd_entry_upgrade_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N} cmd_entry_upgrade_ack_t;
N
Ntypedef __packed struct {
N	uint8_t encrypt;
N	uint32_t firmware_size;
N	uint8_t reserve[8];
N} cmd_start_upgrade_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N	uint16_t data_size;
N} cmd_start_upgrade_ack_t;
N
Ntypedef __packed struct {
N	uint8_t encrypt;
N	int32_t package_index;
N	uint16_t package_length;
N	uint8_t data[1000];
N} cmd_data_upgrade_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N	uint32_t package_index;
N} cmd_data_upgrade_ack_t;
N
Ntypedef __packed struct {
N	uint8_t encrypt;
N	uint8_t md5[16];
N} cmd_end_upgrade_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N} cmd_end_upgrade_ack_t;
N
Ntypedef __packed struct {
N	uint8_t encrypt;
N    uint8_t type;
N	uint32_t delay_ms;
N	uint8_t reserve[8];
N} cmd_reboot_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N} cmd_reboot_ack_t;
N
Ntypedef __packed struct {
N	__packed struct {
N		uint8_t minor : 4;
N		uint8_t major : 4;
N	} ver;
N} cmd_status_report_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N	__packed struct {
N		uint8_t minor : 4;
N		uint8_t major : 4;
N	} ver;
N	uint32_t status;
N} cmd_status_report_ack_t;
N
Ntypedef __packed struct {
N	__packed struct {
N		uint8_t minor : 4;
N		uint8_t major : 4;
N	} ver;
N    uint8_t hardware_ver[16];
N} cmd_set_version_req_t;
N
Ntypedef __packed struct {
N	uint8_t result;
N	__packed struct {
N		uint8_t minor : 4;
N		uint8_t major : 4;
N	} ver;
N	uint8_t hardware_ver[16];
N} cmd_set_version_ack_t;
N
Ntypedef __packed struct {
N  uint8_t cmdtype ;
N	uint8_t value;
N} cmd_camera_remote_req_t;
N
Ntypedef __packed struct {
N  uint8_t reserved:7;
N	uint8_t health_flag:1;
N} pump_esc_status_t;
N
Ntypedef __packed struct {
N  uint8_t pump2_state:4;
N	uint8_t pump1_state:4;
N} pump_presure_state_t;
N
Ntypedef __packed struct {
N  uint8_t cur_flow:6;
N	uint8_t cali_result:2; // 0: 1  2
N} pump_flow_state_t;
N
N
Ntypedef __packed struct {
N  uint8_t enable_flag:1;
N	uint8_t flow_speed: 7;// 0.02L/min
N	uint8_t valid_spray;
N} spray_sys_esc_status_t;
N
Ntypedef __packed struct {
N  uint8_t enable_flag:1;
N	uint8_t flow_speed: 7;// 0.02L/min
N} esc_status_t;
N
N
N//typedef __packed struct {
N//	uint8_t flow_speed: 7;// 0.02L/min
N//	uint8_t enable_flag:1;
N//} debug_esc_status_t;
N
Ntypedef __packed struct {
N	pump_esc_status_t pump_esc_status[6]; //  4
N	pump_flow_state_t flow_para[2]; // 0.1L/min
N	pump_presure_state_t pump_presure_state; // 
N	uint8_t remaining_capacity;//L 
N	__packed struct{
N		uint8_t XT100:4;
N		uint8_t XT90:4;
N	} plug_temp_level;
N//	debug_esc_status_t debug_esc_status[2]; //esc_status_t
N//	uint16_t debug_pump1_foc_value;
N//	uint16_t debug_pump1_press_value;
N//	uint16_t debug_pump2_foc_value;
N//	uint16_t debug_pump2_press_value;
N//	uint8_t  debug_flow_freq;
N//	uint8_t  level_status;
N	uint8_t count; // 
N} cmd_spary_sys_status_push_t;
N
N
N
Ntypedef __packed struct {
N	esc_status_t spray_cmd[6];
N	uint8_t valid_spray; //
N	uint8_t reserved;
N}cmd_spary_sys_esc_ctrl_t;
N
N
Ntypedef __packed struct {
N	uint8_t cali_capacity; // L
N}cmd_flow_cali_t;
N
Ntypedef __packed struct { // 
N	uint8_t ack_code; // 0
N}cmd_flow_cali_ack_t;
N
Ntypedef __packed struct { // 
N	uint8_t result; // 0 1
N}cmd_flow_cali_completed_t;
N
Ntypedef __packed struct {
N	uint8_t level_status; // 
N}cmd_level_switch_t;
N
Ntypedef __packed struct {
N  uint8_t waring_mode:7;
N	uint8_t read_or_write:1;
N}cmd_residual_volume_t;
N
Ntypedef __packed struct {
N  uint8_t ack_code;
N  uint8_t ack_waring_mode;
N}cmd_residual_volume_ack_t;
N
Ntypedef __packed struct {
N  uint8_t flowmeter_value:7;
N	uint8_t read_or_write:1;
N}cmd_flowmeter_K_control_t;
N
Ntypedef __packed struct {
N  uint8_t ack_code;
N  uint8_t ack_flowmeter_value;
N}cmd_flowmeter_ack_t;
N
N//typedef __packed struct {
N//  uint8_t  default_capacity;
N//	uint8_t  dosage_mu;
N//	uint16_t complted_mu;
N//	uint16_t plan_flow;
N//}cmd_spray_results_t;
N
Ntypedef __packed struct {
N  uint8_t ack_code;
N}cmd_spray_results_ack_t;
N
N
N
Ntypedef __packed struct {
N	float vlx;
N	float vly;
N}speed_xy_t;
N
Ntypedef __packed struct {
N	__packed struct {
N		uint8_t foc_encoder : 6;
N		uint8_t cmd:2;
N	} cmd;
N	__packed struct {
N		uint8_t feckbackID: 5;
N		uint8_t youmen_type:3;
N	} type;
N	__packed struct {
N		uint16_t acc_value:14;
N		uint16_t led_g:1;
N		uint16_t led_r:1;
N	} foc0;
N		__packed struct {
N		uint16_t acc_value:14;
N		uint16_t led_g:1;
N		uint16_t led_r:1;
N	} foc1;
N		__packed struct {
N		uint16_t acc_value:14;
N		uint16_t led_g:1;
N		uint16_t led_r:1;
N	} foc2;
N		__packed struct {
N		uint16_t acc_value:14;
N		uint16_t led_g:1;
N		uint16_t led_r:1;
N	} foc3;
N	
N} cmd_foc_req_t;
N
N
Ntypedef __packed struct {
N	uint8_t  ID;
N	uint8_t  statu;
N	int16_t  line_U;
N	int16_t  foc_I;
N	int16_t  temperature;
N	int16_t  speed;
N  int16_t  acc_signal;
N	int16_t  out_U;
N	uint8_t  resever[6];
N}cmd_foc_ack_t ;
Nextern cmd_foc_ack_t g_stFOC_Value[] ;
N
Ntypedef __packed struct {
N  uint16_t distance;
N	uint8_t  flag;
N  uint8_t  cnt;  
N}cmd_radar_push_t ;
N
Ntypedef __packed struct {
N	cmd_radar_push_t radar_data;
N	uint8_t          data_flash;
N}radar_data_t;
N
Ntypedef void ( *ptr_func_handler )( uint8_t *p_buf, uint16_t len );
N
Ntypedef struct {
N	ptr_func_handler 	handler;	
N	uint16_t      		id;
N} handler_pair_v0_t;
N
Ntypedef struct {
N	ptr_func_handler 	handler;	
N	uint8_t   	   		id;
N	uint8_t 		    set;
N} handler_pair_v1_t;
N
N/*****************/
N
Ntypedef __packed struct {
N	uint8_t enable_flag;
N	float   flow_speed;// 0.02L/min
N} control_pump_status_t;
N
Ntypedef __packed struct
N{
N	control_pump_status_t control_pump_status[2];
N	uint16_t foc1_value;
N	uint16_t press1_value;
N	uint16_t foc2_value;
N	uint16_t press2_value;
N	uint8_t  flow_freq;
N	uint8_t  level_status;
N	uint16_t cali_capacity;
N	uint16_t cali_pulses;
N} spray_system_para_save_iosd_t;
N
N// block id 
N#define MY_DEVICE_TAG 1
Ntypedef __packed struct
N{
N  uint8_t tag;
N} cmd_iosd_req_t;
N
Ntypedef __packed struct
N{
N	uint8_t ack_code;
N	uint8_t result;
N	uint16_t Block_ID;
N  uint8_t tag;
N} cmd_iosd_ack_t;
N
N// 
Ntypedef __packed struct
N{
N  uint8_t reserve;
N} cmd_iosd_status_inquire_t;
N
Ntypedef __packed struct
N{
N  uint8_t ack_code;
N	uint8_t status_flag;
N} cmd_iosd_status_ack_t;
N
N// 
N#define data_name_length 92// < 240 
Ntypedef __packed struct
N{
N  uint16_t block_id;
N	uint8_t  number_of_packet_entries;
N	uint8_t  config_data_length;
N	uint8_t  data_name[data_name_length];// 
X	uint8_t  data_name[92];
N} cmd_iosd_config_t;
N
Ntypedef __packed struct
N{
N  uint8_t ack_code;
N	uint8_t config_result;
N	uint16_t block_id;
N} cmd_iosd_config_ack_t;
N
N//
Ntypedef __packed struct
N{
N  uint16_t block_id;
N	uint8_t  iosd_data_length;
N  spray_system_para_save_iosd_t spray_system_para;//uint8_t  ; 
N} cmd_iosd_data_push_t;
N
Ntypedef __packed struct
N{
N  uint8_t ack_code;
N	uint8_t iosd_save_result;
N	uint16_t block_id;
N} cmd_iosd_data_push_ack_t;
N
N#define DEVICE_ID             (28)
N#define DEVICE_INDEX	        (0)
N#define DEVICE_LOADER_VERSION   (0x02000000)
N
N#define FOC_1   1 // 1  
N#define FOC_2   2 // 3
N
N#define  CMD_SET_ADDR  1
N#define  CMD_NO_ORDER  0
N
N#define Throttle_Value_Type 0 //  1000-2000
N#define Rotating_Speed_Type 1
N#define Voltage 2
N
N
N#define Pump_Wroking 1      
N#define Pump_Stop    0  
N#define Pump_Presure_Normal   0
N#define Pump_One_Pipe_Block   1
N#define Pump_Two_Pipe_Block   2
N
N#define ESC_Normal  0
N#define ESC_Fault   1
N
N#define STOP_SPARY  0
N#define START_SPARY   1
N
N#define No_Liquid      0 // 
N#define Small_Liquid   1 // 
N
N#define Single_Pump 1
N#define Double_Pump 2
N
N#define CANCEL_FLOW_CALI      0
N#define START_FLOW_CALI       1
N#define CLEAR_FLOW_CALI_PARA  2
N
Nextern int32_t g_cfg_end_point;
Nuint8_t get_command_version( uint8_t *p_buf, uint8_t len );
Nvoid command_process_v0( uint8_t *p_buf, uint16_t len );
Nvoid command_process_v1( uint8_t *p_buf, uint16_t len );
N
Nvoid cfg_status_report( void );
Nvoid cmd_hander_foc_request( uint8_t cmd , uint8_t foc_id );
Nvoid PC_LOG( uint8_t num , const uint8_t *pstr, ... );
Nvoid can_upgrade_ack( uint8_t * buf , uint16_t len );
Nvoid cmd_handler_foc_ver_request( uint8_t idx );
Nvoid spary_sys_status_push( void );
Nextern radar_data_t g_stRadarData;
Nextern spray_sys_esc_status_t FOC_1_STATUS;
Nextern spray_sys_esc_status_t FOC_2_STATUS;
Nvoid set_foc_throttle_value(uint8_t foc_id,spray_sys_esc_status_t  foc_status);
Nuint16_t get_foc_throttle_value(uint8_t foc_id);
Nvoid cmd_handler_flow_cali(  uint8_t *p_buf, uint16_t len);
Nvoid  Set_Throttle_Value_1(uint16_t value);
Nvoid  Set_Throttle_Value_2(uint16_t value);
Nuint8_t get_pwm_present_value(void);
Nuint8_t get_cali_capacity(void);
N//void flow_cali_result_push( uint8_t cali_result);
Nvoid SET_FOC1_MUTEX_FLAG(uint8_t state);
Nvoid SET_FOC2_MUTEX_FLAG(uint8_t state);
Nuint8_t get_level_status_by_radar(void);
Nvoid cmd_handler_level_switch( uint8_t *p_buf, uint16_t len);
Nvoid cmd_handler_residual_volume_warning(uint8_t *p_buf, uint16_t len);
Nvoid set_flow_cali_result(uint8_t value);
Nextern void Set_Foc_Value_By_Flow_Double_Pump(spray_sys_esc_status_t foc_status );// 0.02L/min
Nextern void Set_Foc_Value_By_Flow_Single_Pump(uint8_t foc_id,spray_sys_esc_status_t foc_status );
Nvoid set_residual_volume_warning_mode(uint8_t mode);//
N//void cmd_handler_spray_results_corrected(uint8_t *p_buf, uint16_t len); 
Nextern uint8_t get_pump1_state(void);
Nextern uint8_t get_pump2_state(void);
N
Nvoid cmd_handler_Block_ID_ack(uint8_t *p_buf, uint16_t len) ;
Nvoid cmd_handler_iosd_status_ack(uint8_t *p_buf, uint16_t len);
Nvoid cmd_handler_iosd_config_ack(uint8_t *p_buf, uint16_t len);
Nvoid cmd_handler_data_push_ack(uint8_t *p_buf, uint16_t len);
Nvoid cmd_handler_flowmeter_K_control(uint8_t *p_buf, uint16_t len);
Nvoid IOSD_Block_ID_Request(void);
Nvoid IOSD_status_inquire(void);
Nvoid IOSD_Config_Info_Push(void);
Nvoid spray_system_data_Push(void);
Nvoid spray_system_para_recoder(void);
N/*******************  (C) COPYRIGHT 2012 DJI ************END OF FILE***********/
N#endif
N
L 20 "app\cfg\cfg_inc.h" 2
N
N/*******************  (C) COPYRIGHT 2012 DJI ************END OF FILE***********/
N#endif
N
L 19 "app\cfg\cfg_unpack.c" 2
N#include "../crc/MF_CRC8.h"
L 1 "app\cfg\../crc/MF_CRC8.h" 1
N/******************************************************************************* 
N*                      CRC16  functions algorithm  liboray                     * 
N*   file : MF_CRC8.c                                                       *
N*                                                                              *
N*   history :                                                                  * 
N*     v1.0 2013-09-13   feng                                              *
N*******************************************************************************/ 
N#ifndef  __MF_CRC8_H__
N#define  __MF_CRC8_H__
N
N/*
N** global function
N*/ 
Nextern unsigned char Get_CRC8_Check_Sum(unsigned char *pchMessage,unsigned int dwLength,unsigned char ucCRC8);
Nextern unsigned int Verify_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength); 
Nextern void Append_CRC8_Check_Sum(unsigned char *pchMessage, unsigned int dwLength); 
N
N/*
N** global const variable 
N*/ 
Nextern const unsigned char CRC8_TAB[256];
Nextern const unsigned char CRC8_INIT;  
N
N#endif
N/*
N********************************************************************************
N*                        END
N********************************************************************************
N*/
L 20 "app\cfg\cfg_unpack.c" 2
N#include "../crc/MF_CRC16.h"
L 1 "app\cfg\../crc/MF_CRC16.h" 1
N/******************************************************************************* 
N*                      CRC16  functions algorithm  liboray                     * 
N*   file : MF_CRC16.h                                                          *
N*                                                                              *
N*   history :                                                                  * 
N*     v1.0 2010-07-07   Motorfeng                                              *
N*******************************************************************************/ 
N#ifndef  __MF_CRC16_CPP__
N#define  __MF_CRC16_CPP__
N
N#include "../../cstartup/type.h"
L 1 "app\cfg\../crc/../../cstartup/type.h" 1
N/*****************************************************************************
N *   type.h:  Type definition Header file for NXP LPC17xx Family 
N *   Microprocessors
N *
N *   Copyright(C) 2009, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2009.05.25  ver 1.00    Prelimnary version, first Release
N *
N******************************************************************************/
N#include <stdint.h>
N
N#ifndef __TYPE_H__
S#define __TYPE_H__
S
S#ifndef NULL
S#define NULL    ((void *)0)
S#endif
S
S#ifndef FALSE
S#define FALSE   (0)
S#endif
S
S#ifndef TRUE
S#define TRUE    (1)
S#endif
S
S#ifndef __FALSE
S#define __FALSE   (0)
S#endif
S
S#ifndef __TRUE
S#define __TRUE    (1)
S#endif
S
Stypedef char			   C08;			/* 8 bit character					*/
Stypedef char               S08;
Stypedef unsigned char      U08;
Stypedef short              S16;
Stypedef unsigned short     U16;
Stypedef int                S32;
Stypedef unsigned int       U32;
Stypedef long long          S64;
Stypedef unsigned long long U64;
Stypedef unsigned char      BIT;
Stypedef void*			   VP;				/* pointer to variable data type	*/
Stypedef unsigned int       BOOL;
S
N#endif  /* __TYPE_H__ */
L 12 "app\cfg\../crc/MF_CRC16.h" 2
N
N#define CRC_INIT 			0x3692 
N
N
Nuint16_t Get_CRC16_Check_Sum( uint8_t *pchMessage, uint32_t dwLength, uint16_t wCRC ); 
Nuint32_t Verify_CRC16_Check_Sum( uint8_t *pchMessage, uint32_t dwLength ); 
Nvoid Append_CRC16_Check_Sum( uint8_t *pchMessage, uint32_t dwLength ); 
N
N#endif
N/*
N********************************************************************************
N*                        END
N********************************************************************************
N*/
L 21 "app\cfg\cfg_unpack.c" 2
N#include "cfg_decoder.h"
N#include "cfg_handler.h"
N#include "lpc17xx_uart.h"
N
N#if __USB_ENABLE__
S#define USB_UNPACK_MAX_SIZE     (512)
S    static uint8_t usb_data_buff[USB_UNPACK_MAX_SIZE];
S    cfg_decoder_object_t usb_decoder_obj;
N#endif
N#if __CAN1_ENABLE__
X#if (1)
N#define CAN1_UNPACK_MAX_SIZE     (512)
N    static uint8_t can1_data_buff[CAN1_UNPACK_MAX_SIZE];
X    static uint8_t can1_data_buff[(512)];
N    cfg_decoder_object_t can1_decoder_obj;
N
N		static uint8_t can1_data_buff2[CAN1_UNPACK_MAX_SIZE];
X		static uint8_t can1_data_buff2[(512)];
N    cfg_decoder_object_t can1_decoder_obj2;
N
N		static uint8_t can1_data_buff_LED[CAN1_UNPACK_MAX_SIZE];
X		static uint8_t can1_data_buff_LED[(512)];
N    cfg_decoder_object_t can1_decoder_obj_LED;
N
N		static uint8_t can1_data_buff_upgrade[CAN1_UNPACK_MAX_SIZE];
X		static uint8_t can1_data_buff_upgrade[(512)];
N    cfg_decoder_object_t can1_decoder_obj_upgrade;
N#endif
N#if __CAN2_ENABLE__
S#define CAN2_UNPACK_MAX_SIZE     (512)
S    static uint8_t can2_data_buff[CAN2_UNPACK_MAX_SIZE];
S    cfg_decoder_object_t can2_decoder_obj;
N#endif
N#ifdef __UART0__
N#define UART0_UNPACK_MAX_SIZE     (512)
N    static uint8_t uart0_data_buff[UART0_UNPACK_MAX_SIZE];
X    static uint8_t uart0_data_buff[(512)];
N    cfg_decoder_object_t uart0_decoder_obj;
N#endif
N#ifdef __UART1__
N#define UART1_UNPACK_MAX_SIZE     (512)
N    static uint8_t uart1_data_buff[UART1_UNPACK_MAX_SIZE]; 
X    static uint8_t uart1_data_buff[(512)]; 
N    cfg_decoder_object_t uart1_decoder_obj;
N#endif
N#ifdef __UART2__
N#define UART2_UNPACK_MAX_SIZE     (512)
N    static uint8_t uart2_data_buff[UART2_UNPACK_MAX_SIZE];
X    static uint8_t uart2_data_buff[(512)];
N    cfg_decoder_object_t uart2_decoder_obj;
N    static uint8_t uart2_data_buff_copy[UART2_UNPACK_MAX_SIZE];
X    static uint8_t uart2_data_buff_copy[(512)];
N    cfg_decoder_object_t uart2_decoder_obj_copy;		
N#endif
N#ifdef __UART3__
N#define UART3_UNPACK_MAX_SIZE     (512)
N    static uint8_t uart3_data_buff[UART3_UNPACK_MAX_SIZE];
X    static uint8_t uart3_data_buff[(512)];
N    cfg_decoder_object_t uart3_decoder_obj;
N#endif
N
Nvoid cfg_unpack_init( void )
N{
N#if __USB_ENABLE__
S    cfg_decoder_init( &usb_decoder_obj, usb_data_buff, USB_UNPACK_MAX_SIZE );
N#endif
N#if __CAN1_ENABLE__
X#if (1)
N    cfg_decoder_init( &can1_decoder_obj, can1_data_buff, CAN1_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &can1_decoder_obj, can1_data_buff, (512) );
N		cfg_decoder_init( &can1_decoder_obj2, can1_data_buff2, CAN1_UNPACK_MAX_SIZE );
X		cfg_decoder_init( &can1_decoder_obj2, can1_data_buff2, (512) );
N    cfg_decoder_init( &can1_decoder_obj_LED, can1_data_buff_LED, CAN1_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &can1_decoder_obj_LED, can1_data_buff_LED, (512) );
N		cfg_decoder_init( &can1_decoder_obj_upgrade, can1_data_buff_upgrade, CAN1_UNPACK_MAX_SIZE );
X		cfg_decoder_init( &can1_decoder_obj_upgrade, can1_data_buff_upgrade, (512) );
N#endif
N#if __CAN2_ENABLE__
S    cfg_decoder_init( &can2_decoder_obj, can2_data_buff, CAN2_UNPACK_MAX_SIZE );
N#endif
N#ifdef __UART0__
N    cfg_decoder_init( &uart0_decoder_obj, uart0_data_buff, UART0_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &uart0_decoder_obj, uart0_data_buff, (512) );
N#endif
N#ifdef __UART1__
N    cfg_decoder_init( &uart1_decoder_obj, uart1_data_buff, UART1_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &uart1_decoder_obj, uart1_data_buff, (512) );
N#endif
N#ifdef __UART2__
N    cfg_decoder_init( &uart2_decoder_obj, uart2_data_buff, UART2_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &uart2_decoder_obj, uart2_data_buff, (512) );
N		cfg_decoder_init( &uart2_decoder_obj_copy, uart2_data_buff_copy, UART2_UNPACK_MAX_SIZE );
X		cfg_decoder_init( &uart2_decoder_obj_copy, uart2_data_buff_copy, (512) );
N#endif
N#ifdef __UART3__
N    cfg_decoder_init( &uart3_decoder_obj, uart3_data_buff, UART3_UNPACK_MAX_SIZE );
X    cfg_decoder_init( &uart3_decoder_obj, uart3_data_buff, (512) );
N#endif
N}
N
Nvoid cfg_unpack_tick( void )        
N{
N	uint8_t data = 0;
N    uint16_t length = 0;
N
N#if __USB_ENABLE__
S	length = OutBufAvailBytes();
S    while( length-- ) {
S        data = VCOM_GetByte();
S        if( cfg_decoder_upack( &usb_decoder_obj, data ) ) {
S            g_cfg_end_point = EP_USB;
S            command_process_v1( usb_decoder_obj.p_data, usb_decoder_obj.len );
S            g_cfg_end_point = EP_NULL;
S        }
S    }
N#endif
N#if __CAN1_ENABLE__
X#if (1)
N	length = CAN_RING_BUF_COUNT( &can1RxRingBuf );
N    while( length-- ) {
N        data = CAN_RING_BUF_RD( &can1RxRingBuf );
N        if( cfg_decoder_upack( &can1_decoder_obj, data ) ) {
N            g_cfg_end_point = EP_CAN1;
N            command_process_v1( can1_decoder_obj.p_data, can1_decoder_obj.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N//CAN1BUF2
N	length = CAN_RING_BUF_COUNT( &can1Rx2RingBuf );
N    while( length-- ) {
N        data = CAN_RING_BUF_RD( &can1Rx2RingBuf );
N        if( cfg_decoder_upack( &can1_decoder_obj2, data ) ) {
N            g_cfg_end_point = EP_CAN1;
N						command_process_v1( can1_decoder_obj2.p_data, can1_decoder_obj2.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N//CAN1BUF3
N	length = CAN_RING_BUF_COUNT( &can1RxLEDRingBuf );
N    while( length-- ) {
N        data = CAN_RING_BUF_RD( &can1RxLEDRingBuf );
N        if( cfg_decoder_upack( &can1_decoder_obj_LED, data ) ) {
N            g_cfg_end_point = EP_CAN1_LED;
N            command_process_v1( can1_decoder_obj_LED.p_data, can1_decoder_obj_LED.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N#endif
N#if __CAN2_ENABLE__
S	length = CAN_RING_BUF_COUNT( &can2RxRingBuf );
S    while( length-- ) {
S        data = CAN_RING_BUF_RD( &can2RxRingBuf );
S        if( cfg_decoder_upack( &can2_decoder_obj, data ) ) {
S            g_cfg_end_point = EP_CAN2;
S            command_process_v1( can2_decoder_obj.p_data, can2_decoder_obj.len );
S            g_cfg_end_point = EP_NULL;
S        }
S    }
N#endif
N#if __UART0__
X#if 1
N	length = RING_BUF_COUNT( UART0_rx_buf );
X	length = ((UART0_rx_buf . wrIdx - UART0_rx_buf . rdIdx)&UART0_rx_buf . mask);
N    while( length-- ) {
N        data = RING_BUF_RD( UART0_rx_buf );
X        data = (UART0_rx_buf . pBuf[UART0_rx_buf . rdIdx++ &UART0_rx_buf . mask]);
N        if( cfg_decoder_upack( &uart0_decoder_obj, data ) ) {
N            g_cfg_end_point = EP_UART0;
N            command_process_v1( uart0_decoder_obj.p_data, uart0_decoder_obj.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N#endif
N		
N
N#if __UART1__
X#if 1
N	length = RING_BUF_COUNT( UART1_rx_buf );
X	length = ((UART1_rx_buf . wrIdx - UART1_rx_buf . rdIdx)&UART1_rx_buf . mask);
N		if( length != 0 )
N    while( length-- ) {
N        data = RING_BUF_RD( UART1_rx_buf );
X        data = (UART1_rx_buf . pBuf[UART1_rx_buf . rdIdx++ &UART1_rx_buf . mask]);
N        if( cfg_decoder_upack( &uart1_decoder_obj, data ) ) {
N            g_cfg_end_point = EP_UART1;
N            command_process_v1( uart1_decoder_obj.p_data, uart1_decoder_obj.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N#endif	
N
N#if __UART2__
X#if 1
N{
N	
N	length = RING_BUF_COUNT( UART2_rx_buf_copy );	
X	length = ((UART2_rx_buf_copy . wrIdx - UART2_rx_buf_copy . rdIdx)&UART2_rx_buf_copy . mask);	
N	if( length != 0 ){	
N    while( length-- ) {
N        data = RING_BUF_RD( UART2_rx_buf_copy );
X        data = (UART2_rx_buf_copy . pBuf[UART2_rx_buf_copy . rdIdx++ &UART2_rx_buf_copy . mask]);
N
N        if( cfg_decoder_upack( &uart2_decoder_obj_copy, data ) ) {
N            g_cfg_end_point = EP_UART2;
N            command_process_v1( uart2_decoder_obj_copy.p_data, uart2_decoder_obj_copy.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N	}
N//	length = RING_BUF_COUNT( UART2_rx_buf_copy );	
N//	if( length != 0 ){	
N//    while( length-- ) {
N//        data = RING_BUF_RD( UART2_rx_buf_copy );
N
N////        if( cfg_decoder_upack( &uart2_decoder_obj_copy, data ) ) {
N////            g_cfg_end_point = EP_UART2;
N////            command_process_v1( uart2_decoder_obj_copy.p_data, uart2_decoder_obj_copy.len );
N////            g_cfg_end_point = EP_NULL;
N////        }
N//			 g_cfg_end_point = EP_UART2;
N//			 Flow_Sensor_Unpack(&uart2_decoder_obj_copy, data);
N//			 g_cfg_end_point = EP_NULL;
N		
N}
N#endif	
N
N#if __UART3__
X#if 1
N	length = RING_BUF_COUNT( UART3_rx_buf );
X	length = ((UART3_rx_buf . wrIdx - UART3_rx_buf . rdIdx)&UART3_rx_buf . mask);
N		if( length != 0 )
N    while( length-- ) {
N        data = RING_BUF_RD( UART3_rx_buf );
X        data = (UART3_rx_buf . pBuf[UART3_rx_buf . rdIdx++ &UART3_rx_buf . mask]);
N        if( cfg_decoder_upack( &uart3_decoder_obj, data ) ) {
N            g_cfg_end_point = EP_UART3;
N            command_process_v1( uart3_decoder_obj.p_data, uart3_decoder_obj.len );
N            g_cfg_end_point = EP_NULL;
N        }
N    }
N#endif	
N}
N
Nvoid PC_LOG( uint8_t num , const uint8_t *pstr, ... )
N{
N	static uint8_t pc_log_buf[128] ;
N	va_list arglist;
N	uint16_t len ;
N	cmd_header_v1_t *p_cmd = ( cmd_header_v1_t * )pc_log_buf;
N
N	va_start(arglist, pstr);
X	__va_start(arglist, pstr);
N  len = vsnprintf((void*)&pc_log_buf[sizeof( cmd_header_v1_t )+1],114,(void*)pstr, arglist);
N  va_end(arglist);
X  __va_end(arglist);
N	
N	p_cmd->sof = 0x55;
N	p_cmd->vl.version = 1;
N	p_cmd->sender.sender_id = DEVICE_ID;
X	p_cmd->sender.sender_id = (28);
N	p_cmd->sender.sender_index = DEVICE_INDEX;
X	p_cmd->sender.sender_index = (0);
N	p_cmd->receiver.receiver_id = 0x19 ; 
N	p_cmd->receiver.receiver_index = 0 ;
N	p_cmd->seqnum ++ ;
N	p_cmd->seqnum = (p_cmd->seqnum > 7000)?0:p_cmd->seqnum ; 
N	p_cmd->type.cmd_type = 0;
N	p_cmd->type.cmd_ack = 0;
N	p_cmd->type.encrypt_type = 0;
N	p_cmd->set = 0x0;
N	p_cmd->id  = 0x0e;
N
N	pc_log_buf[sizeof( cmd_header_v1_t )]=num;
N	pc_log_buf[sizeof( cmd_header_v1_t )+len + 1]='\0' ;
N	p_cmd->vl.length = sizeof( cmd_header_v1_t )  + len + 2 + 2 ;
N
N	Append_CRC8_Check_Sum( pc_log_buf , 4 );
N	Append_CRC16_Check_Sum( pc_log_buf , p_cmd->vl.length );
N	
N	CAN_sendbytes_View( LPC_CAN1, &can1TxRingBuf, pc_log_buf, p_cmd->vl.length );
X	CAN_sendbytes_View( ((LPC_CAN_TypeDef *) ((0x40000000UL) + 0x44000) ), &can1TxRingBuf, pc_log_buf, p_cmd->vl.length );
N}
N
